/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const t = 0,
  e = 1,
  n = 2,
  i = 0,
  s = 1,
  r = 2,
  o = 3
class a {
  addEventListener(t, e) {
    void 0 === this._listeners && (this._listeners = {})
    const n = this._listeners
    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
  }
  hasEventListener(t, e) {
    if (void 0 === this._listeners) return !1
    const n = this._listeners
    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
  }
  removeEventListener(t, e) {
    if (void 0 === this._listeners) return
    const n = this._listeners[t]
    if (void 0 !== n) {
      const t = n.indexOf(e)
      ;-1 !== t && n.splice(t, 1)
    }
  }
  dispatchEvent(t) {
    if (void 0 === this._listeners) return
    const e = this._listeners[t.type]
    if (void 0 !== e) {
      t.target = this
      const n = e.slice(0)
      for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
      t.target = null
    }
  }
}
const l = []
for (let t = 0; t < 256; t++) l[t] = (t < 16 ? '0' : '') + t.toString(16)
let h = 1234567
const c = Math.PI / 180,
  u = 180 / Math.PI
function d() {
  const t = (4294967295 * Math.random()) | 0,
    e = (4294967295 * Math.random()) | 0,
    n = (4294967295 * Math.random()) | 0,
    i = (4294967295 * Math.random()) | 0
  return (
    l[255 & t] +
    l[(t >> 8) & 255] +
    l[(t >> 16) & 255] +
    l[(t >> 24) & 255] +
    '-' +
    l[255 & e] +
    l[(e >> 8) & 255] +
    '-' +
    l[((e >> 16) & 15) | 64] +
    l[(e >> 24) & 255] +
    '-' +
    l[(63 & n) | 128] +
    l[(n >> 8) & 255] +
    '-' +
    l[(n >> 16) & 255] +
    l[(n >> 24) & 255] +
    l[255 & i] +
    l[(i >> 8) & 255] +
    l[(i >> 16) & 255] +
    l[(i >> 24) & 255]
  ).toUpperCase()
}
function p(t, e, n) {
  return Math.max(e, Math.min(n, t))
}
function g(t, e) {
  return ((t % e) + e) % e
}
function f(t, e, n) {
  return (1 - n) * t + n * e
}
function m(t) {
  return 0 == (t & (t - 1)) && 0 !== t
}
function y(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
}
function x(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
}
var v = Object.freeze({
  __proto__: null,
  DEG2RAD: c,
  RAD2DEG: u,
  generateUUID: d,
  clamp: p,
  euclideanModulo: g,
  mapLinear: function (t, e, n, i, s) {
    return i + ((t - e) * (s - i)) / (n - e)
  },
  inverseLerp: function (t, e, n) {
    return t !== e ? (n - t) / (e - t) : 0
  },
  lerp: f,
  damp: function (t, e, n, i) {
    return f(t, e, 1 - Math.exp(-n * i))
  },
  pingpong: function (t, e = 1) {
    return e - Math.abs(g(t, 2 * e) - e)
  },
  smoothstep: function (t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
  },
  smootherstep: function (t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
  },
  randInt: function (t, e) {
    return t + Math.floor(Math.random() * (e - t + 1))
  },
  randFloat: function (t, e) {
    return t + Math.random() * (e - t)
  },
  randFloatSpread: function (t) {
    return t * (0.5 - Math.random())
  },
  seededRandom: function (t) {
    void 0 !== t && (h = t)
    let e = (h += 1831565813)
    return (
      (e = Math.imul(e ^ (e >>> 15), 1 | e)),
      (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
      ((e ^ (e >>> 14)) >>> 0) / 4294967296
    )
  },
  degToRad: function (t) {
    return t * c
  },
  radToDeg: function (t) {
    return t * u
  },
  isPowerOfTwo: m,
  ceilPowerOfTwo: y,
  floorPowerOfTwo: x,
  setQuaternionFromProperEuler: function (t, e, n, i, s) {
    const r = Math.cos,
      o = Math.sin,
      a = r(n / 2),
      l = o(n / 2),
      h = r((e + i) / 2),
      c = o((e + i) / 2),
      u = r((e - i) / 2),
      d = o((e - i) / 2),
      p = r((i - e) / 2),
      g = o((i - e) / 2)
    switch (s) {
      case 'XYX':
        t.set(a * c, l * u, l * d, a * h)
        break
      case 'YZY':
        t.set(l * d, a * c, l * u, a * h)
        break
      case 'ZXZ':
        t.set(l * u, l * d, a * c, a * h)
        break
      case 'XZX':
        t.set(a * c, l * g, l * p, a * h)
        break
      case 'YXY':
        t.set(l * p, a * c, l * g, a * h)
        break
      case 'ZYZ':
        t.set(l * g, l * p, a * c, a * h)
        break
      default:
        console.warn(
          'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + s
        )
    }
  }
})
class _ {
  constructor(t = 0, e = 0) {
    ;(this.x = t), (this.y = e)
  }
  get width() {
    return this.x
  }
  set width(t) {
    this.x = t
  }
  get height() {
    return this.y
  }
  set height(t) {
    this.y = t
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), this)
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), this)
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = t.elements
    return (this.x = i[0] * e + i[3] * n + i[6]), (this.y = i[1] * e + i[4] * n + i[7]), this
  }
  min(t) {
    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
  }
  max(t) {
    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y
  }
  cross(t) {
    return this.x * t.y - this.y * t.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y
    return e * e + n * n
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
  }
  lerpVectors(t, e, n) {
    return (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
  }
  equals(t) {
    return t.x === this.x && t.y === this.y
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().'),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      this
    )
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      s = this.x - t.x,
      r = this.y - t.y
    return (this.x = s * n - r * i + t.x), (this.y = s * i + r * n + t.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
_.prototype.isVector2 = !0
class w {
  constructor() {
    ;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'
        )
  }
  set(t, e, n, i, s, r, o, a, l) {
    const h = this.elements
    return (
      (h[0] = t),
      (h[1] = i),
      (h[2] = o),
      (h[3] = e),
      (h[4] = s),
      (h[5] = a),
      (h[6] = n),
      (h[7] = r),
      (h[8] = l),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    )
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(t) {
    const e = t.elements
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
  }
  multiply(t) {
    return this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      s = this.elements,
      r = n[0],
      o = n[3],
      a = n[6],
      l = n[1],
      h = n[4],
      c = n[7],
      u = n[2],
      d = n[5],
      p = n[8],
      g = i[0],
      f = i[3],
      m = i[6],
      y = i[1],
      x = i[4],
      v = i[7],
      _ = i[2],
      w = i[5],
      E = i[8]
    return (
      (s[0] = r * g + o * y + a * _),
      (s[3] = r * f + o * x + a * w),
      (s[6] = r * m + o * v + a * E),
      (s[1] = l * g + h * y + c * _),
      (s[4] = l * f + h * x + c * w),
      (s[7] = l * m + h * v + c * E),
      (s[2] = u * g + d * y + p * _),
      (s[5] = u * f + d * x + p * w),
      (s[8] = u * m + d * v + p * E),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      o = t[5],
      a = t[6],
      l = t[7],
      h = t[8]
    return e * r * h - e * o * l - n * s * h + n * o * a + i * s * l - i * r * a
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      o = t[5],
      a = t[6],
      l = t[7],
      h = t[8],
      c = h * r - o * l,
      u = o * a - h * s,
      d = l * s - r * a,
      p = e * c + n * u + i * d
    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const g = 1 / p
    return (
      (t[0] = c * g),
      (t[1] = (i * l - h * n) * g),
      (t[2] = (o * n - i * r) * g),
      (t[3] = u * g),
      (t[4] = (h * e - i * a) * g),
      (t[5] = (i * s - o * e) * g),
      (t[6] = d * g),
      (t[7] = (n * a - l * e) * g),
      (t[8] = (r * e - n * s) * g),
      this
    )
  }
  transpose() {
    let t
    const e = this.elements
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    )
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose()
  }
  transposeIntoArray(t) {
    const e = this.elements
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    )
  }
  setUvTransform(t, e, n, i, s, r, o) {
    const a = Math.cos(s),
      l = Math.sin(s)
    return (
      this.set(
        n * a,
        n * l,
        -n * (a * r + l * o) + r + t,
        -i * l,
        i * a,
        -i * (-l * r + a * o) + o + e,
        0,
        0,
        1
      ),
      this
    )
  }
  scale(t, e) {
    const n = this.elements
    return (n[0] *= t), (n[3] *= t), (n[6] *= t), (n[1] *= e), (n[4] *= e), (n[7] *= e), this
  }
  rotate(t) {
    const e = Math.cos(t),
      n = Math.sin(t),
      i = this.elements,
      s = i[0],
      r = i[3],
      o = i[6],
      a = i[1],
      l = i[4],
      h = i[7]
    return (
      (i[0] = e * s + n * a),
      (i[3] = e * r + n * l),
      (i[6] = e * o + n * h),
      (i[1] = -n * s + e * a),
      (i[4] = -n * r + e * l),
      (i[7] = -n * o + e * h),
      this
    )
  }
  translate(t, e) {
    const n = this.elements
    return (
      (n[0] += t * n[2]),
      (n[3] += t * n[5]),
      (n[6] += t * n[8]),
      (n[1] += e * n[2]),
      (n[4] += e * n[5]),
      (n[7] += e * n[8]),
      this
    )
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
function E(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] > 65535) return !0
  return !1
}
function b(t) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', t)
}
w.prototype.isMatrix3 = !0
const M = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  },
  S = { h: 0, s: 0, l: 0 },
  A = { h: 0, s: 0, l: 0 }
function T(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + 6 * (e - t) * n : n < 0.5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
  )
}
function I(t) {
  return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
}
function R(t) {
  return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055
}
class L {
  constructor(t, e, n) {
    return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
  }
  set(t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : 'number' == typeof t
          ? this.setHex(t)
          : 'string' == typeof t && this.setStyle(t),
      this
    )
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this
  }
  setHex(t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (255 & t) / 255),
      this
    )
  }
  setRGB(t, e, n) {
    return (this.r = t), (this.g = e), (this.b = n), this
  }
  setHSL(t, e, n) {
    if (((t = g(t, 1)), (e = p(e, 0, 1)), (n = p(n, 0, 1)), 0 === e)) this.r = this.g = this.b = n
    else {
      const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        s = 2 * n - i
      ;(this.r = T(s, i, t + 1 / 3)), (this.g = T(s, i, t)), (this.b = T(s, i, t - 1 / 3))
    }
    return this
  }
  setStyle(t) {
    function e(e) {
      void 0 !== e &&
        parseFloat(e) < 1 &&
        console.warn('THREE.Color: Alpha component of ' + t + ' will be ignored.')
    }
    let n
    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
      let t
      const i = n[1],
        s = n[2]
      switch (i) {
        case 'rgb':
        case 'rgba':
          if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)))
            return (
              (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
              e(t[4]),
              this
            )
          if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)))
            return (
              (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
              e(t[4]),
              this
            )
          break
        case 'hsl':
        case 'hsla':
          if (
            (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
          ) {
            const n = parseFloat(t[1]) / 360,
              i = parseInt(t[2], 10) / 100,
              s = parseInt(t[3], 10) / 100
            return e(t[4]), this.setHSL(n, i, s)
          }
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const t = n[1],
        e = t.length
      if (3 === e)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
          (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
          (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
          this
        )
      if (6 === e)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
          (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
          (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
          this
        )
    }
    return t && t.length > 0 ? this.setColorName(t) : this
  }
  setColorName(t) {
    const e = M[t.toLowerCase()]
    return void 0 !== e ? this.setHex(e) : console.warn('THREE.Color: Unknown color ' + t), this
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
  }
  copySRGBToLinear(t) {
    return (this.r = I(t.r)), (this.g = I(t.g)), (this.b = I(t.b)), this
  }
  copyLinearToSRGB(t) {
    return (this.r = R(t.r)), (this.g = R(t.g)), (this.b = R(t.b)), this
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex() {
    return (
      (p(255 * this.r, 0, 255) << 16) ^
      (p(255 * this.g, 0, 255) << 8) ^
      (p(255 * this.b, 0, 255) << 0)
    )
  }
  getHexString() {
    return ('000000' + this.getHex().toString(16)).slice(-6)
  }
  getHSL(t) {
    const e = this.r,
      n = this.g,
      i = this.b,
      s = Math.max(e, n, i),
      r = Math.min(e, n, i)
    let o, a
    const l = (r + s) / 2
    if (r === s) (o = 0), (a = 0)
    else {
      const t = s - r
      switch (((a = l <= 0.5 ? t / (s + r) : t / (2 - s - r)), s)) {
        case e:
          o = (n - i) / t + (n < i ? 6 : 0)
          break
        case n:
          o = (i - e) / t + 2
          break
        case i:
          o = (e - n) / t + 4
      }
      o /= 6
    }
    return (t.h = o), (t.s = a), (t.l = l), t
  }
  getStyle() {
    return (
      'rgb(' + ((255 * this.r) | 0) + ',' + ((255 * this.g) | 0) + ',' + ((255 * this.b) | 0) + ')'
    )
  }
  offsetHSL(t, e, n) {
    return this.getHSL(S), (S.h += t), (S.s += e), (S.l += n), this.setHSL(S.h, S.s, S.l), this
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
  }
  addColors(t, e) {
    return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    )
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    )
  }
  lerpColors(t, e, n) {
    return (
      (this.r = t.r + (e.r - t.r) * n),
      (this.g = t.g + (e.g - t.g) * n),
      (this.b = t.b + (e.b - t.b) * n),
      this
    )
  }
  lerpHSL(t, e) {
    this.getHSL(S), t.getHSL(A)
    const n = f(S.h, A.h, e),
      i = f(S.s, A.s, e),
      s = f(S.l, A.l, e)
    return this.setHSL(n, i, s), this
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    )
  }
  toJSON() {
    return this.getHex()
  }
}
let C
;(L.NAMES = M),
  (L.prototype.isColor = !0),
  (L.prototype.r = 1),
  (L.prototype.g = 1),
  (L.prototype.b = 1)
class N {
  static getDataURL(t) {
    if (/^data:/i.test(t.src)) return t.src
    if ('undefined' == typeof HTMLCanvasElement) return t.src
    let e
    if (t instanceof HTMLCanvasElement) e = t
    else {
      void 0 === C && (C = b('canvas')), (C.width = t.width), (C.height = t.height)
      const n = C.getContext('2d')
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
        (e = C)
    }
    return e.width > 2048 || e.height > 2048
      ? (console.warn(
          'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
          t
        ),
        e.toDataURL('image/jpeg', 0.6))
      : e.toDataURL('image/png')
  }
  static sRGBToLinear(t) {
    if (
      ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
      ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
      ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
    ) {
      const e = b('canvas')
      ;(e.width = t.width), (e.height = t.height)
      const n = e.getContext('2d')
      n.drawImage(t, 0, 0, t.width, t.height)
      const i = n.getImageData(0, 0, t.width, t.height),
        s = i.data
      for (let t = 0; t < s.length; t++) s[t] = 255 * I(s[t] / 255)
      return n.putImageData(i, 0, 0), e
    }
    if (t.data) {
      const e = t.data.slice(0)
      for (let t = 0; t < e.length; t++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray
          ? (e[t] = Math.floor(255 * I(e[t] / 255)))
          : (e[t] = I(e[t]))
      return { data: e, width: t.width, height: t.height }
    }
    return (
      console.warn(
        'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
      ),
      t
    )
  }
}
class P {
  constructor(t = null) {
    ;(this.uuid = d()), (this.data = t), (this.version = 0)
  }
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t
    if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid]
    const n = { uuid: this.uuid, url: '' },
      i = this.data
    if (null !== i) {
      let t
      if (Array.isArray(i)) {
        t = []
        for (let e = 0, n = i.length; e < n; e++)
          i[e].isDataTexture ? t.push(D(i[e].image)) : t.push(D(i[e]))
      } else t = D(i)
      n.url = t
    }
    return e || (t.images[this.uuid] = n), n
  }
}
function D(t) {
  return ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
    ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
    ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
    ? N.getDataURL(t)
    : t.data
      ? {
          data: Array.prototype.slice.call(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name
        }
      : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
}
P.prototype.isSource = !0
let O = 0
class F extends a {
  constructor(
    t = F.DEFAULT_IMAGE,
    e = F.DEFAULT_MAPPING,
    n = 1001,
    i = 1001,
    s = 1006,
    r = 1008,
    o = 1023,
    a = 1009,
    l = 1,
    h = 3e3
  ) {
    super(),
      Object.defineProperty(this, 'id', { value: O++ }),
      (this.uuid = d()),
      (this.name = ''),
      (this.source = new P(t)),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = r),
      (this.anisotropy = l),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = a),
      (this.offset = new _(0, 0)),
      (this.repeat = new _(1, 1)),
      (this.center = new _(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new w()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1)
  }
  get image() {
    return this.source.data
  }
  set image(t) {
    this.source.data = t
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.source = t.source),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.encoding = t.encoding),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t
    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]
    const n = {
      metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    }
    return (
      '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
      e || (t.textures[this.uuid] = n),
      n
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  transformUv(t) {
    if (300 !== this.mapping) return t
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case 1e3:
          t.x = t.x - Math.floor(t.x)
          break
        case 1001:
          t.x = t.x < 0 ? 0 : 1
          break
        case 1002:
          1 === Math.abs(Math.floor(t.x) % 2)
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x))
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case 1e3:
          t.y = t.y - Math.floor(t.y)
          break
        case 1001:
          t.y = t.y < 0 ? 0 : 1
          break
        case 1002:
          1 === Math.abs(Math.floor(t.y) % 2)
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y))
      }
    return this.flipY && (t.y = 1 - t.y), t
  }
  set needsUpdate(t) {
    !0 === t && (this.version++, (this.source.needsUpdate = !0))
  }
}
;(F.DEFAULT_IMAGE = null), (F.DEFAULT_MAPPING = 300), (F.prototype.isTexture = !0)
class G {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(this.x = t), (this.y = e), (this.z = n), (this.w = i)
  }
  get width() {
    return this.z
  }
  set width(t) {
    this.z = t
  }
  get height() {
    return this.w
  }
  set height(t) {
    this.w = t
  }
  set(t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setW(t) {
    return (this.w = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      case 3:
        this.w = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this)
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this
    )
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this)
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this
    )
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      r = t.elements
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * i + r[12] * s),
      (this.y = r[1] * e + r[5] * n + r[9] * i + r[13] * s),
      (this.z = r[2] * e + r[6] * n + r[10] * i + r[14] * s),
      (this.w = r[3] * e + r[7] * n + r[11] * i + r[15] * s),
      this
    )
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w)
    const e = Math.sqrt(1 - t.w * t.w)
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, s
    const r = 0.01,
      o = 0.1,
      a = t.elements,
      l = a[0],
      h = a[4],
      c = a[8],
      u = a[1],
      d = a[5],
      p = a[9],
      g = a[2],
      f = a[6],
      m = a[10]
    if (Math.abs(h - u) < r && Math.abs(c - g) < r && Math.abs(p - f) < r) {
      if (
        Math.abs(h + u) < o &&
        Math.abs(c + g) < o &&
        Math.abs(p + f) < o &&
        Math.abs(l + d + m - 3) < o
      )
        return this.set(1, 0, 0, 0), this
      e = Math.PI
      const t = (l + 1) / 2,
        a = (d + 1) / 2,
        y = (m + 1) / 2,
        x = (h + u) / 4,
        v = (c + g) / 4,
        _ = (p + f) / 4
      return (
        t > a && t > y
          ? t < r
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(t)), (i = x / n), (s = v / n))
          : a > y
            ? a < r
              ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
              : ((i = Math.sqrt(a)), (n = x / i), (s = _ / i))
            : y < r
              ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
              : ((s = Math.sqrt(y)), (n = v / s), (i = _ / s)),
        this.set(n, i, s, e),
        this
      )
    }
    let y = Math.sqrt((f - p) * (f - p) + (c - g) * (c - g) + (u - h) * (u - h))
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (f - p) / y),
      (this.y = (c - g) / y),
      (this.z = (u - h) / y),
      (this.w = Math.acos((l + d + m - 1) / 2)),
      this
    )
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    )
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().'),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
G.prototype.isVector4 = !0
class z extends a {
  constructor(t, e, n = {}) {
    super(),
      (this.width = t),
      (this.height = e),
      (this.depth = 1),
      (this.scissor = new G(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new G(0, 0, t, e))
    const i = { width: t, height: e, depth: 1 }
    ;(this.texture = new F(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps),
      (this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null),
      (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
      (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
      (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
      (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null),
      (this.samples = void 0 !== n.samples ? n.samples : 0)
  }
  setSize(t, e, n = 1) {
    ;(this.width === t && this.height === e && this.depth === n) ||
      ((this.width = t),
      (this.height = e),
      (this.depth = n),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, t, e),
      this.scissor.set(0, 0, t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (
      (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.viewport.copy(t.viewport),
      (this.texture = t.texture.clone()),
      (this.texture.image = Object.assign({}, t.texture.image)),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
      (this.samples = t.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
z.prototype.isWebGLRenderTarget = !0
class B extends F {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.wrapR = 1001),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
B.prototype.isDataArrayTexture = !0
;(class extends z {
  constructor(t, e, n) {
    super(t, e),
      (this.depth = n),
      (this.texture = new B(null, t, e, n)),
      (this.texture.isRenderTargetTexture = !0)
  }
}).prototype.isWebGLArrayRenderTarget = !0
class U extends F {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.wrapR = 1001),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
U.prototype.isData3DTexture = !0
;(class extends z {
  constructor(t, e, n) {
    super(t, e),
      (this.depth = n),
      (this.texture = new U(null, t, e, n)),
      (this.texture.isRenderTargetTexture = !0)
  }
}).prototype.isWebGL3DRenderTarget = !0
;(class extends z {
  constructor(t, e, n, i = {}) {
    super(t, e, i)
    const s = this.texture
    this.texture = []
    for (let t = 0; t < n; t++)
      (this.texture[t] = s.clone()), (this.texture[t].isRenderTargetTexture = !0)
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      ;(this.width = t), (this.height = e), (this.depth = n)
      for (let i = 0, s = this.texture.length; i < s; i++)
        (this.texture[i].image.width = t),
          (this.texture[i].image.height = e),
          (this.texture[i].image.depth = n)
      this.dispose()
    }
    return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
  }
  copy(t) {
    this.dispose(),
      (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      (this.texture.length = 0)
    for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone()
    return this
  }
}).prototype.isWebGLMultipleRenderTargets = !0
class V {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(this._x = t), (this._y = e), (this._z = n), (this._w = i)
  }
  static slerp(t, e, n, i) {
    return (
      console.warn(
        'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.'
      ),
      n.slerpQuaternions(t, e, i)
    )
  }
  static slerpFlat(t, e, n, i, s, r, o) {
    let a = n[i + 0],
      l = n[i + 1],
      h = n[i + 2],
      c = n[i + 3]
    const u = s[r + 0],
      d = s[r + 1],
      p = s[r + 2],
      g = s[r + 3]
    if (0 === o) return (t[e + 0] = a), (t[e + 1] = l), (t[e + 2] = h), void (t[e + 3] = c)
    if (1 === o) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = g)
    if (c !== g || a !== u || l !== d || h !== p) {
      let t = 1 - o
      const e = a * u + l * d + h * p + c * g,
        n = e >= 0 ? 1 : -1,
        i = 1 - e * e
      if (i > Number.EPSILON) {
        const s = Math.sqrt(i),
          r = Math.atan2(s, e * n)
        ;(t = Math.sin(t * r) / s), (o = Math.sin(o * r) / s)
      }
      const s = o * n
      if (
        ((a = a * t + u * s),
        (l = l * t + d * s),
        (h = h * t + p * s),
        (c = c * t + g * s),
        t === 1 - o)
      ) {
        const t = 1 / Math.sqrt(a * a + l * l + h * h + c * c)
        ;(a *= t), (l *= t), (h *= t), (c *= t)
      }
    }
    ;(t[e] = a), (t[e + 1] = l), (t[e + 2] = h), (t[e + 3] = c)
  }
  static multiplyQuaternionsFlat(t, e, n, i, s, r) {
    const o = n[i],
      a = n[i + 1],
      l = n[i + 2],
      h = n[i + 3],
      c = s[r],
      u = s[r + 1],
      d = s[r + 2],
      p = s[r + 3]
    return (
      (t[e] = o * p + h * c + a * d - l * u),
      (t[e + 1] = a * p + h * u + l * c - o * d),
      (t[e + 2] = l * p + h * d + o * u - a * c),
      (t[e + 3] = h * p - o * c - a * u - l * d),
      t
    )
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(t) {
    ;(this._w = t), this._onChangeCallback()
  }
  set(t, e, n, i) {
    return (
      (this._x = t), (this._y = e), (this._z = n), (this._w = i), this._onChangeCallback(), this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(t, e) {
    if (!t || !t.isEuler)
      throw new Error(
        'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
      )
    const n = t._x,
      i = t._y,
      s = t._z,
      r = t._order,
      o = Math.cos,
      a = Math.sin,
      l = o(n / 2),
      h = o(i / 2),
      c = o(s / 2),
      u = a(n / 2),
      d = a(i / 2),
      p = a(s / 2)
    switch (r) {
      case 'XYZ':
        ;(this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p)
        break
      case 'YXZ':
        ;(this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p)
        break
      case 'ZXY':
        ;(this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p)
        break
      case 'ZYX':
        ;(this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p)
        break
      case 'YZX':
        ;(this._x = u * h * c + l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c - u * d * p)
        break
      case 'XZY':
        ;(this._x = u * h * c - l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c + u * d * p)
        break
      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + r)
    }
    return !1 !== e && this._onChangeCallback(), this
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      i = Math.sin(n)
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      s = e[8],
      r = e[1],
      o = e[5],
      a = e[9],
      l = e[2],
      h = e[6],
      c = e[10],
      u = n + o + c
    if (u > 0) {
      const t = 0.5 / Math.sqrt(u + 1)
      ;(this._w = 0.25 / t),
        (this._x = (h - a) * t),
        (this._y = (s - l) * t),
        (this._z = (r - i) * t)
    } else if (n > o && n > c) {
      const t = 2 * Math.sqrt(1 + n - o - c)
      ;(this._w = (h - a) / t),
        (this._x = 0.25 * t),
        (this._y = (i + r) / t),
        (this._z = (s + l) / t)
    } else if (o > c) {
      const t = 2 * Math.sqrt(1 + o - n - c)
      ;(this._w = (s - l) / t),
        (this._x = (i + r) / t),
        (this._y = 0.25 * t),
        (this._z = (a + h) / t)
    } else {
      const t = 2 * Math.sqrt(1 + c - n - o)
      ;(this._w = (r - i) / t),
        (this._x = (s + l) / t),
        (this._y = (a + h) / t),
        (this._z = 0.25 * t)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    )
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(p(this.dot(t), -1, 1)))
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t)
    if (0 === n) return this
    const i = Math.min(1, e / n)
    return this.slerp(t, i), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
  }
  normalize() {
    let t = this.length()
    return (
      0 === t
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
        ),
        this.multiplyQuaternions(t, e))
      : this.multiplyQuaternions(this, t)
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this)
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      i = t._y,
      s = t._z,
      r = t._w,
      o = e._x,
      a = e._y,
      l = e._z,
      h = e._w
    return (
      (this._x = n * h + r * o + i * l - s * a),
      (this._y = i * h + r * a + s * o - n * l),
      (this._z = s * h + r * l + n * a - i * o),
      (this._w = r * h - n * o - i * a - s * l),
      this._onChangeCallback(),
      this
    )
  }
  slerp(t, e) {
    if (0 === e) return this
    if (1 === e) return this.copy(t)
    const n = this._x,
      i = this._y,
      s = this._z,
      r = this._w
    let o = r * t._w + n * t._x + i * t._y + s * t._z
    if (
      (o < 0
        ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (o = -o))
        : this.copy(t),
      o >= 1)
    )
      return (this._w = r), (this._x = n), (this._y = i), (this._z = s), this
    const a = 1 - o * o
    if (a <= Number.EPSILON) {
      const t = 1 - e
      return (
        (this._w = t * r + e * this._w),
        (this._x = t * n + e * this._x),
        (this._y = t * i + e * this._y),
        (this._z = t * s + e * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      )
    }
    const l = Math.sqrt(a),
      h = Math.atan2(l, o),
      c = Math.sin((1 - e) * h) / l,
      u = Math.sin(e * h) / l
    return (
      (this._w = r * c + this._w * u),
      (this._x = n * c + this._x * u),
      (this._y = i * c + this._y * u),
      (this._z = s * c + this._z * u),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n)
  }
  random() {
    const t = Math.random(),
      e = Math.sqrt(1 - t),
      n = Math.sqrt(t),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random()
    return this.set(e * Math.cos(i), n * Math.sin(s), n * Math.cos(s), e * Math.sin(i))
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this
    )
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
}
V.prototype.isQuaternion = !0
class H {
  constructor(t = 0, e = 0, n = 0) {
    ;(this.x = t), (this.y = e), (this.z = n)
  }
  set(t, e, n) {
    return void 0 === n && (n = this.z), (this.x = t), (this.y = e), (this.z = n), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this)
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this)
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
        ),
        this.multiplyVectors(t, e))
      : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this)
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this
  }
  multiplyVectors(t, e) {
    return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
  }
  applyEuler(t) {
    return (
      (t && t.isEuler) ||
        console.error(
          'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
        ),
      this.applyQuaternion(W.setFromEuler(t))
    )
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(W.setFromAxisAngle(t, e))
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements
    return (
      (this.x = s[0] * e + s[3] * n + s[6] * i),
      (this.y = s[1] * e + s[4] * n + s[7] * i),
      (this.z = s[2] * e + s[5] * n + s[8] * i),
      this
    )
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize()
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements,
      r = 1 / (s[3] * e + s[7] * n + s[11] * i + s[15])
    return (
      (this.x = (s[0] * e + s[4] * n + s[8] * i + s[12]) * r),
      (this.y = (s[1] * e + s[5] * n + s[9] * i + s[13]) * r),
      (this.z = (s[2] * e + s[6] * n + s[10] * i + s[14]) * r),
      this
    )
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.x,
      r = t.y,
      o = t.z,
      a = t.w,
      l = a * e + r * i - o * n,
      h = a * n + o * e - s * i,
      c = a * i + s * n - r * e,
      u = -s * e - r * n - o * i
    return (
      (this.x = l * a + u * -s + h * -o - c * -r),
      (this.y = h * a + u * -r + c * -s - l * -o),
      (this.z = c * a + u * -o + l * -r - h * -s),
      this
    )
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      s = t.elements
    return (
      (this.x = s[0] * e + s[4] * n + s[8] * i),
      (this.y = s[1] * e + s[5] * n + s[9] * i),
      (this.z = s[2] * e + s[6] * n + s[10] * i),
      this.normalize()
    )
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    )
  }
  cross(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
        ),
        this.crossVectors(t, e))
      : this.crossVectors(this, t)
  }
  crossVectors(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = e.x,
      o = e.y,
      a = e.z
    return (this.x = i * a - s * o), (this.y = s * r - n * a), (this.z = n * o - i * r), this
  }
  projectOnVector(t) {
    const e = t.lengthSq()
    if (0 === e) return this.set(0, 0, 0)
    const n = t.dot(this) / e
    return this.copy(t).multiplyScalar(n)
  }
  projectOnPlane(t) {
    return k.copy(this).projectOnVector(t), this.sub(k)
  }
  reflect(t) {
    return this.sub(k.copy(t).multiplyScalar(2 * this.dot(t)))
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq())
    if (0 === e) return Math.PI / 2
    const n = this.dot(t) / e
    return Math.acos(p(n, -1, 1))
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z
    return e * e + n * n + i * i
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t
    return (this.x = i * Math.sin(n)), (this.y = Math.cos(e) * t), (this.z = i * Math.cos(n)), this
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
  }
  setFromCylindricalCoords(t, e, n) {
    return (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
  }
  setFromMatrixPosition(t) {
    const e = t.elements
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length()
    return (this.x = e), (this.y = n), (this.z = i), this
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, 4 * e)
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, 3 * e)
  }
  setFromEuler(t) {
    return (this.x = t._x), (this.y = t._y), (this.z = t._z), this
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().'),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      this
    )
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this
  }
  randomDirection() {
    const t = 2 * (Math.random() - 0.5),
      e = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - t ** 2)
    return (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
H.prototype.isVector3 = !0
const k = new H(),
  W = new V()
class Y {
  constructor(t = new H(1 / 0, 1 / 0, 1 / 0), e = new H(-1 / 0, -1 / 0, -1 / 0)) {
    ;(this.min = t), (this.max = e)
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this
  }
  setFromArray(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      s = -1 / 0,
      r = -1 / 0,
      o = -1 / 0
    for (let a = 0, l = t.length; a < l; a += 3) {
      const l = t[a],
        h = t[a + 1],
        c = t[a + 2]
      l < e && (e = l),
        h < n && (n = h),
        c < i && (i = c),
        l > s && (s = l),
        h > r && (r = h),
        c > o && (o = c)
    }
    return this.min.set(e, n, i), this.max.set(s, r, o), this
  }
  setFromBufferAttribute(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      s = -1 / 0,
      r = -1 / 0,
      o = -1 / 0
    for (let a = 0, l = t.count; a < l; a++) {
      const l = t.getX(a),
        h = t.getY(a),
        c = t.getZ(a)
      l < e && (e = l),
        h < n && (n = h),
        c < i && (i = c),
        l > s && (s = l),
        h > r && (r = h),
        c > o && (o = c)
    }
    return this.min.set(e, n, i), this.max.set(s, r, o), this
  }
  setFromPoints(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
    return this
  }
  setFromCenterAndSize(t, e) {
    const n = q.copy(e).multiplyScalar(0.5)
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1)
    const n = t.geometry
    if (void 0 !== n)
      if (e && null != n.attributes && void 0 !== n.attributes.position) {
        const e = n.attributes.position
        for (let n = 0, i = e.count; n < i; n++)
          q.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(q)
      } else
        null === n.boundingBox && n.computeBoundingBox(),
          Z.copy(n.boundingBox),
          Z.applyMatrix4(t.matrixWorld),
          this.union(Z)
    const i = t.children
    for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e)
    return this
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    )
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    )
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    )
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    )
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, q), q.distanceToSquared(t.center) <= t.radius * t.radius
  }
  intersectsPlane(t) {
    let e, n
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    )
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1
    this.getCenter(et),
      nt.subVectors(this.max, et),
      X.subVectors(t.a, et),
      K.subVectors(t.b, et),
      J.subVectors(t.c, et),
      Q.subVectors(K, X),
      $.subVectors(J, K),
      tt.subVectors(X, J)
    let e = [
      0,
      -Q.z,
      Q.y,
      0,
      -$.z,
      $.y,
      0,
      -tt.z,
      tt.y,
      Q.z,
      0,
      -Q.x,
      $.z,
      0,
      -$.x,
      tt.z,
      0,
      -tt.x,
      -Q.y,
      Q.x,
      0,
      -$.y,
      $.x,
      0,
      -tt.y,
      tt.x,
      0
    ]
    return (
      !!rt(e, X, K, J, nt) &&
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!rt(e, X, K, J, nt) && (it.crossVectors(Q, $), (e = [it.x, it.y, it.z]), rt(e, X, K, J, nt)))
    )
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max)
  }
  distanceToPoint(t) {
    return q.copy(t).clamp(this.min, this.max).sub(t).length()
  }
  getBoundingSphere(t) {
    return this.getCenter(t.center), (t.radius = 0.5 * this.getSize(q).length()), t
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this
  }
  applyMatrix4(t) {
    return (
      this.isEmpty() ||
        (j[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        j[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        j[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        j[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        j[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        j[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        j[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        j[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(j)),
      this
    )
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max)
  }
}
Y.prototype.isBox3 = !0
const j = [new H(), new H(), new H(), new H(), new H(), new H(), new H(), new H()],
  q = new H(),
  Z = new Y(),
  X = new H(),
  K = new H(),
  J = new H(),
  Q = new H(),
  $ = new H(),
  tt = new H(),
  et = new H(),
  nt = new H(),
  it = new H(),
  st = new H()
function rt(t, e, n, i, s) {
  for (let r = 0, o = t.length - 3; r <= o; r += 3) {
    st.fromArray(t, r)
    const o = s.x * Math.abs(st.x) + s.y * Math.abs(st.y) + s.z * Math.abs(st.z),
      a = e.dot(st),
      l = n.dot(st),
      h = i.dot(st)
    if (Math.max(-Math.max(a, l, h), Math.min(a, l, h)) > o) return !1
  }
  return !0
}
const ot = new Y(),
  at = new H(),
  lt = new H(),
  ht = new H()
class ct {
  constructor(t = new H(), e = -1) {
    ;(this.center = t), (this.radius = e)
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this
  }
  setFromPoints(t, e) {
    const n = this.center
    void 0 !== e ? n.copy(e) : ot.setFromPoints(t).getCenter(n)
    let i = 0
    for (let e = 0, s = t.length; e < s; e++) i = Math.max(i, n.distanceToSquared(t[e]))
    return (this.radius = Math.sqrt(i)), this
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius
    return t.center.distanceToSquared(this.center) <= e * e
  }
  intersectsBox(t) {
    return t.intersectsSphere(this)
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t)
    return (
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)),
      e
    )
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this
  }
  translate(t) {
    return this.center.add(t), this
  }
  expandByPoint(t) {
    ht.subVectors(t, this.center)
    const e = ht.lengthSq()
    if (e > this.radius * this.radius) {
      const t = Math.sqrt(e),
        n = 0.5 * (t - this.radius)
      this.center.add(ht.multiplyScalar(n / t)), (this.radius += n)
    }
    return this
  }
  union(t) {
    return (
      !0 === this.center.equals(t.center)
        ? lt.set(0, 0, 1).multiplyScalar(t.radius)
        : lt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
      this.expandByPoint(at.copy(t.center).add(lt)),
      this.expandByPoint(at.copy(t.center).sub(lt)),
      this
    )
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const ut = new H(),
  dt = new H(),
  pt = new H(),
  gt = new H(),
  ft = new H(),
  mt = new H(),
  yt = new H()
class xt {
  constructor(t = new H(), e = new H(0, 0, -1)) {
    ;(this.origin = t), (this.direction = e)
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
  }
  at(t, e) {
    return e.copy(this.direction).multiplyScalar(t).add(this.origin)
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this
  }
  recast(t) {
    return this.origin.copy(this.at(t, ut)), this
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin)
    const n = e.dot(this.direction)
    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t))
  }
  distanceSqToPoint(t) {
    const e = ut.subVectors(t, this.origin).dot(this.direction)
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (ut.copy(this.direction).multiplyScalar(e).add(this.origin), ut.distanceToSquared(t))
  }
  distanceSqToSegment(t, e, n, i) {
    dt.copy(t).add(e).multiplyScalar(0.5),
      pt.copy(e).sub(t).normalize(),
      gt.copy(this.origin).sub(dt)
    const s = 0.5 * t.distanceTo(e),
      r = -this.direction.dot(pt),
      o = gt.dot(this.direction),
      a = -gt.dot(pt),
      l = gt.lengthSq(),
      h = Math.abs(1 - r * r)
    let c, u, d, p
    if (h > 0)
      if (((c = r * a - o), (u = r * o - a), (p = s * h), c >= 0))
        if (u >= -p)
          if (u <= p) {
            const t = 1 / h
            ;(c *= t), (u *= t), (d = c * (c + r * u + 2 * o) + u * (r * c + u + 2 * a) + l)
          } else (u = s), (c = Math.max(0, -(r * u + o))), (d = -c * c + u * (u + 2 * a) + l)
        else (u = -s), (c = Math.max(0, -(r * u + o))), (d = -c * c + u * (u + 2 * a) + l)
      else
        u <= -p
          ? ((c = Math.max(0, -(-r * s + o))),
            (u = c > 0 ? -s : Math.min(Math.max(-s, -a), s)),
            (d = -c * c + u * (u + 2 * a) + l))
          : u <= p
            ? ((c = 0), (u = Math.min(Math.max(-s, -a), s)), (d = u * (u + 2 * a) + l))
            : ((c = Math.max(0, -(r * s + o))),
              (u = c > 0 ? s : Math.min(Math.max(-s, -a), s)),
              (d = -c * c + u * (u + 2 * a) + l))
    else (u = r > 0 ? -s : s), (c = Math.max(0, -(r * u + o))), (d = -c * c + u * (u + 2 * a) + l)
    return (
      n && n.copy(this.direction).multiplyScalar(c).add(this.origin),
      i && i.copy(pt).multiplyScalar(u).add(dt),
      d
    )
  }
  intersectSphere(t, e) {
    ut.subVectors(t.center, this.origin)
    const n = ut.dot(this.direction),
      i = ut.dot(ut) - n * n,
      s = t.radius * t.radius
    if (i > s) return null
    const r = Math.sqrt(s - i),
      o = n - r,
      a = n + r
    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction)
    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null
    const n = -(this.origin.dot(t.normal) + t.constant) / e
    return n >= 0 ? n : null
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t)
    return null === n ? null : this.at(n, e)
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin)
    if (0 === e) return !0
    return t.normal.dot(this.direction) * e < 0
  }
  intersectBox(t, e) {
    let n, i, s, r, o, a
    const l = 1 / this.direction.x,
      h = 1 / this.direction.y,
      c = 1 / this.direction.z,
      u = this.origin
    return (
      l >= 0
        ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
        : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
      h >= 0
        ? ((s = (t.min.y - u.y) * h), (r = (t.max.y - u.y) * h))
        : ((s = (t.max.y - u.y) * h), (r = (t.min.y - u.y) * h)),
      n > r || s > i
        ? null
        : ((s > n || n != n) && (n = s),
          (r < i || i != i) && (i = r),
          c >= 0
            ? ((o = (t.min.z - u.z) * c), (a = (t.max.z - u.z) * c))
            : ((o = (t.max.z - u.z) * c), (a = (t.min.z - u.z) * c)),
          n > a || o > i
            ? null
            : ((o > n || n != n) && (n = o),
              (a < i || i != i) && (i = a),
              i < 0 ? null : this.at(n >= 0 ? n : i, e)))
    )
  }
  intersectsBox(t) {
    return null !== this.intersectBox(t, ut)
  }
  intersectTriangle(t, e, n, i, s) {
    ft.subVectors(e, t), mt.subVectors(n, t), yt.crossVectors(ft, mt)
    let r,
      o = this.direction.dot(yt)
    if (o > 0) {
      if (i) return null
      r = 1
    } else {
      if (!(o < 0)) return null
      ;(r = -1), (o = -o)
    }
    gt.subVectors(this.origin, t)
    const a = r * this.direction.dot(mt.crossVectors(gt, mt))
    if (a < 0) return null
    const l = r * this.direction.dot(ft.cross(gt))
    if (l < 0) return null
    if (a + l > o) return null
    const h = -r * gt.dot(yt)
    return h < 0 ? null : this.at(h / o, s)
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class vt {
  constructor() {
    ;(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'
        )
  }
  set(t, e, n, i, s, r, o, a, l, h, c, u, d, p, g, f) {
    const m = this.elements
    return (
      (m[0] = t),
      (m[4] = e),
      (m[8] = n),
      (m[12] = i),
      (m[1] = s),
      (m[5] = r),
      (m[9] = o),
      (m[13] = a),
      (m[2] = l),
      (m[6] = h),
      (m[10] = c),
      (m[14] = u),
      (m[3] = d),
      (m[7] = p),
      (m[11] = g),
      (m[15] = f),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new vt().fromArray(this.elements)
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    )
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
  }
  setFromMatrix3(t) {
    const e = t.elements
    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(t, e, n) {
    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / _t.setFromMatrixColumn(t, 0).length(),
      s = 1 / _t.setFromMatrixColumn(t, 1).length(),
      r = 1 / _t.setFromMatrixColumn(t, 2).length()
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * s),
      (e[5] = n[5] * s),
      (e[6] = n[6] * s),
      (e[7] = 0),
      (e[8] = n[8] * r),
      (e[9] = n[9] * r),
      (e[10] = n[10] * r),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    )
  }
  makeRotationFromEuler(t) {
    ;(t && t.isEuler) ||
      console.error(
        'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
      )
    const e = this.elements,
      n = t.x,
      i = t.y,
      s = t.z,
      r = Math.cos(n),
      o = Math.sin(n),
      a = Math.cos(i),
      l = Math.sin(i),
      h = Math.cos(s),
      c = Math.sin(s)
    if ('XYZ' === t.order) {
      const t = r * h,
        n = r * c,
        i = o * h,
        s = o * c
      ;(e[0] = a * h),
        (e[4] = -a * c),
        (e[8] = l),
        (e[1] = n + i * l),
        (e[5] = t - s * l),
        (e[9] = -o * a),
        (e[2] = s - t * l),
        (e[6] = i + n * l),
        (e[10] = r * a)
    } else if ('YXZ' === t.order) {
      const t = a * h,
        n = a * c,
        i = l * h,
        s = l * c
      ;(e[0] = t + s * o),
        (e[4] = i * o - n),
        (e[8] = r * l),
        (e[1] = r * c),
        (e[5] = r * h),
        (e[9] = -o),
        (e[2] = n * o - i),
        (e[6] = s + t * o),
        (e[10] = r * a)
    } else if ('ZXY' === t.order) {
      const t = a * h,
        n = a * c,
        i = l * h,
        s = l * c
      ;(e[0] = t - s * o),
        (e[4] = -r * c),
        (e[8] = i + n * o),
        (e[1] = n + i * o),
        (e[5] = r * h),
        (e[9] = s - t * o),
        (e[2] = -r * l),
        (e[6] = o),
        (e[10] = r * a)
    } else if ('ZYX' === t.order) {
      const t = r * h,
        n = r * c,
        i = o * h,
        s = o * c
      ;(e[0] = a * h),
        (e[4] = i * l - n),
        (e[8] = t * l + s),
        (e[1] = a * c),
        (e[5] = s * l + t),
        (e[9] = n * l - i),
        (e[2] = -l),
        (e[6] = o * a),
        (e[10] = r * a)
    } else if ('YZX' === t.order) {
      const t = r * a,
        n = r * l,
        i = o * a,
        s = o * l
      ;(e[0] = a * h),
        (e[4] = s - t * c),
        (e[8] = i * c + n),
        (e[1] = c),
        (e[5] = r * h),
        (e[9] = -o * h),
        (e[2] = -l * h),
        (e[6] = n * c + i),
        (e[10] = t - s * c)
    } else if ('XZY' === t.order) {
      const t = r * a,
        n = r * l,
        i = o * a,
        s = o * l
      ;(e[0] = a * h),
        (e[4] = -c),
        (e[8] = l * h),
        (e[1] = t * c + s),
        (e[5] = r * h),
        (e[9] = n * c - i),
        (e[2] = i * c - n),
        (e[6] = o * h),
        (e[10] = s * c + t)
    }
    return (
      (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this
    )
  }
  makeRotationFromQuaternion(t) {
    return this.compose(Et, t, bt)
  }
  lookAt(t, e, n) {
    const i = this.elements
    return (
      At.subVectors(t, e),
      0 === At.lengthSq() && (At.z = 1),
      At.normalize(),
      Mt.crossVectors(n, At),
      0 === Mt.lengthSq() &&
        (1 === Math.abs(n.z) ? (At.x += 1e-4) : (At.z += 1e-4),
        At.normalize(),
        Mt.crossVectors(n, At)),
      Mt.normalize(),
      St.crossVectors(At, Mt),
      (i[0] = Mt.x),
      (i[4] = St.x),
      (i[8] = At.x),
      (i[1] = Mt.y),
      (i[5] = St.y),
      (i[9] = At.y),
      (i[2] = Mt.z),
      (i[6] = St.z),
      (i[10] = At.z),
      this
    )
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
        ),
        this.multiplyMatrices(t, e))
      : this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      s = this.elements,
      r = n[0],
      o = n[4],
      a = n[8],
      l = n[12],
      h = n[1],
      c = n[5],
      u = n[9],
      d = n[13],
      p = n[2],
      g = n[6],
      f = n[10],
      m = n[14],
      y = n[3],
      x = n[7],
      v = n[11],
      _ = n[15],
      w = i[0],
      E = i[4],
      b = i[8],
      M = i[12],
      S = i[1],
      A = i[5],
      T = i[9],
      I = i[13],
      R = i[2],
      L = i[6],
      C = i[10],
      N = i[14],
      P = i[3],
      D = i[7],
      O = i[11],
      F = i[15]
    return (
      (s[0] = r * w + o * S + a * R + l * P),
      (s[4] = r * E + o * A + a * L + l * D),
      (s[8] = r * b + o * T + a * C + l * O),
      (s[12] = r * M + o * I + a * N + l * F),
      (s[1] = h * w + c * S + u * R + d * P),
      (s[5] = h * E + c * A + u * L + d * D),
      (s[9] = h * b + c * T + u * C + d * O),
      (s[13] = h * M + c * I + u * N + d * F),
      (s[2] = p * w + g * S + f * R + m * P),
      (s[6] = p * E + g * A + f * L + m * D),
      (s[10] = p * b + g * T + f * C + m * O),
      (s[14] = p * M + g * I + f * N + m * F),
      (s[3] = y * w + x * S + v * R + _ * P),
      (s[7] = y * E + x * A + v * L + _ * D),
      (s[11] = y * b + x * T + v * C + _ * O),
      (s[15] = y * M + x * I + v * N + _ * F),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      s = t[12],
      r = t[1],
      o = t[5],
      a = t[9],
      l = t[13],
      h = t[2],
      c = t[6],
      u = t[10],
      d = t[14]
    return (
      t[3] * (+s * a * c - i * l * c - s * o * u + n * l * u + i * o * d - n * a * d) +
      t[7] * (+e * a * d - e * l * u + s * r * u - i * r * d + i * l * h - s * a * h) +
      t[11] * (+e * l * c - e * o * d - s * r * c + n * r * d + s * o * h - n * l * h) +
      t[15] * (-i * o * h - e * a * c + e * o * u + i * r * c - n * r * u + n * a * h)
    )
  }
  transpose() {
    const t = this.elements
    let e
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    )
  }
  setPosition(t, e, n) {
    const i = this.elements
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    )
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      s = t[3],
      r = t[4],
      o = t[5],
      a = t[6],
      l = t[7],
      h = t[8],
      c = t[9],
      u = t[10],
      d = t[11],
      p = t[12],
      g = t[13],
      f = t[14],
      m = t[15],
      y = c * f * l - g * u * l + g * a * d - o * f * d - c * a * m + o * u * m,
      x = p * u * l - h * f * l - p * a * d + r * f * d + h * a * m - r * u * m,
      v = h * g * l - p * c * l + p * o * d - r * g * d - h * o * m + r * c * m,
      _ = p * c * a - h * g * a - p * o * u + r * g * u + h * o * f - r * c * f,
      w = e * y + n * x + i * v + s * _
    if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const E = 1 / w
    return (
      (t[0] = y * E),
      (t[1] = (g * u * s - c * f * s - g * i * d + n * f * d + c * i * m - n * u * m) * E),
      (t[2] = (o * f * s - g * a * s + g * i * l - n * f * l - o * i * m + n * a * m) * E),
      (t[3] = (c * a * s - o * u * s - c * i * l + n * u * l + o * i * d - n * a * d) * E),
      (t[4] = x * E),
      (t[5] = (h * f * s - p * u * s + p * i * d - e * f * d - h * i * m + e * u * m) * E),
      (t[6] = (p * a * s - r * f * s - p * i * l + e * f * l + r * i * m - e * a * m) * E),
      (t[7] = (r * u * s - h * a * s + h * i * l - e * u * l - r * i * d + e * a * d) * E),
      (t[8] = v * E),
      (t[9] = (p * c * s - h * g * s - p * n * d + e * g * d + h * n * m - e * c * m) * E),
      (t[10] = (r * g * s - p * o * s + p * n * l - e * g * l - r * n * m + e * o * m) * E),
      (t[11] = (h * o * s - r * c * s - h * n * l + e * c * l + r * n * d - e * o * d) * E),
      (t[12] = _ * E),
      (t[13] = (h * g * i - p * c * i + p * n * u - e * g * u - h * n * f + e * c * f) * E),
      (t[14] = (p * o * i - r * g * i - p * n * a + e * g * a + r * n * f - e * o * f) * E),
      (t[15] = (r * c * i - h * o * i + h * n * a - e * c * a - r * n * u + e * o * u) * E),
      this
    )
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      s = t.z
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= s),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= s),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= s),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= s),
      this
    )
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
    return Math.sqrt(Math.max(e, n, i))
  }
  makeTranslation(t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      s = 1 - n,
      r = t.x,
      o = t.y,
      a = t.z,
      l = s * r,
      h = s * o
    return (
      this.set(
        l * r + n,
        l * o - i * a,
        l * a + i * o,
        0,
        l * o + i * a,
        h * o + n,
        h * a - i * r,
        0,
        l * a - i * o,
        h * a + i * r,
        s * a * a + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
  }
  makeShear(t, e, n, i, s, r) {
    return this.set(1, n, s, 0, t, 1, r, 0, e, i, 1, 0, 0, 0, 0, 1), this
  }
  compose(t, e, n) {
    const i = this.elements,
      s = e._x,
      r = e._y,
      o = e._z,
      a = e._w,
      l = s + s,
      h = r + r,
      c = o + o,
      u = s * l,
      d = s * h,
      p = s * c,
      g = r * h,
      f = r * c,
      m = o * c,
      y = a * l,
      x = a * h,
      v = a * c,
      _ = n.x,
      w = n.y,
      E = n.z
    return (
      (i[0] = (1 - (g + m)) * _),
      (i[1] = (d + v) * _),
      (i[2] = (p - x) * _),
      (i[3] = 0),
      (i[4] = (d - v) * w),
      (i[5] = (1 - (u + m)) * w),
      (i[6] = (f + y) * w),
      (i[7] = 0),
      (i[8] = (p + x) * E),
      (i[9] = (f - y) * E),
      (i[10] = (1 - (u + g)) * E),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    )
  }
  decompose(t, e, n) {
    const i = this.elements
    let s = _t.set(i[0], i[1], i[2]).length()
    const r = _t.set(i[4], i[5], i[6]).length(),
      o = _t.set(i[8], i[9], i[10]).length()
    this.determinant() < 0 && (s = -s), (t.x = i[12]), (t.y = i[13]), (t.z = i[14]), wt.copy(this)
    const a = 1 / s,
      l = 1 / r,
      h = 1 / o
    return (
      (wt.elements[0] *= a),
      (wt.elements[1] *= a),
      (wt.elements[2] *= a),
      (wt.elements[4] *= l),
      (wt.elements[5] *= l),
      (wt.elements[6] *= l),
      (wt.elements[8] *= h),
      (wt.elements[9] *= h),
      (wt.elements[10] *= h),
      e.setFromRotationMatrix(wt),
      (n.x = s),
      (n.y = r),
      (n.z = o),
      this
    )
  }
  makePerspective(t, e, n, i, s, r) {
    void 0 === r &&
      console.warn(
        'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
      )
    const o = this.elements,
      a = (2 * s) / (e - t),
      l = (2 * s) / (n - i),
      h = (e + t) / (e - t),
      c = (n + i) / (n - i),
      u = -(r + s) / (r - s),
      d = (-2 * r * s) / (r - s)
    return (
      (o[0] = a),
      (o[4] = 0),
      (o[8] = h),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = l),
      (o[9] = c),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = u),
      (o[14] = d),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    )
  }
  makeOrthographic(t, e, n, i, s, r) {
    const o = this.elements,
      a = 1 / (e - t),
      l = 1 / (n - i),
      h = 1 / (r - s),
      c = (e + t) * a,
      u = (n + i) * l,
      d = (r + s) * h
    return (
      (o[0] = 2 * a),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -c),
      (o[1] = 0),
      (o[5] = 2 * l),
      (o[9] = 0),
      (o[13] = -u),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = -2 * h),
      (o[14] = -d),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    )
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    )
  }
}
vt.prototype.isMatrix4 = !0
const _t = new H(),
  wt = new vt(),
  Et = new H(0, 0, 0),
  bt = new H(1, 1, 1),
  Mt = new H(),
  St = new H(),
  At = new H(),
  Tt = new vt(),
  It = new V()
class Rt {
  constructor(t = 0, e = 0, n = 0, i = Rt.DefaultOrder) {
    ;(this._x = t), (this._y = e), (this._z = n), (this._order = i)
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(t) {
    ;(this._order = t), this._onChangeCallback()
  }
  set(t, e, n, i = this._order) {
    return (
      (this._x = t), (this._y = e), (this._z = n), (this._order = i), this._onChangeCallback(), this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements,
      s = i[0],
      r = i[4],
      o = i[8],
      a = i[1],
      l = i[5],
      h = i[9],
      c = i[2],
      u = i[6],
      d = i[10]
    switch (e) {
      case 'XYZ':
        ;(this._y = Math.asin(p(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-r, s)))
            : ((this._x = Math.atan2(u, l)), (this._z = 0))
        break
      case 'YXZ':
        ;(this._x = Math.asin(-p(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
            : ((this._y = Math.atan2(-c, s)), (this._z = 0))
        break
      case 'ZXY':
        ;(this._x = Math.asin(p(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(-c, d)), (this._z = Math.atan2(-r, l)))
            : ((this._y = 0), (this._z = Math.atan2(a, s)))
        break
      case 'ZYX':
        ;(this._y = Math.asin(-p(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(a, s)))
            : ((this._x = 0), (this._z = Math.atan2(-r, l)))
        break
      case 'YZX':
        ;(this._z = Math.asin(p(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-c, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, d)))
        break
      case 'XZY':
        ;(this._z = Math.asin(-p(r, -1, 1))),
          Math.abs(r) < 0.9999999
            ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-h, d)), (this._y = 0))
        break
      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + e)
    }
    return (this._order = e), !0 === n && this._onChangeCallback(), this
  }
  setFromQuaternion(t, e, n) {
    return Tt.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Tt, e, n)
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e)
  }
  reorder(t) {
    return It.setFromEuler(this), this.setFromQuaternion(It, t)
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      void 0 !== t[3] && (this._order = t[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
}
;(Rt.prototype.isEuler = !0),
  (Rt.DefaultOrder = 'XYZ'),
  (Rt.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'])
class Lt {
  constructor() {
    this.mask = 1
  }
  set(t) {
    this.mask = ((1 << t) | 0) >>> 0
  }
  enable(t) {
    this.mask |= (1 << t) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(t) {
    return 0 != (this.mask & t.mask)
  }
  isEnabled(t) {
    return 0 != (this.mask & ((1 << t) | 0))
  }
}
let Ct = 0
const Nt = new H(),
  Pt = new V(),
  Dt = new vt(),
  Ot = new H(),
  Ft = new H(),
  Gt = new H(),
  zt = new V(),
  Bt = new H(1, 0, 0),
  Ut = new H(0, 1, 0),
  Vt = new H(0, 0, 1),
  Ht = { type: 'added' },
  kt = { type: 'removed' }
class Wt extends a {
  constructor() {
    super(),
      Object.defineProperty(this, 'id', { value: Ct++ }),
      (this.uuid = d()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = Wt.DefaultUp.clone())
    const t = new H(),
      e = new Rt(),
      n = new V(),
      i = new H(1, 1, 1)
    e._onChange(function () {
      n.setFromEuler(e, !1)
    }),
      n._onChange(function () {
        e.setFromQuaternion(n, void 0, !1)
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: e },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new vt() },
        normalMatrix: { value: new w() }
      }),
      (this.matrix = new vt()),
      (this.matrixWorld = new vt()),
      (this.matrixAutoUpdate = Wt.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Lt()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e)
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0)
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t)
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t)
  }
  rotateOnAxis(t, e) {
    return Pt.setFromAxisAngle(t, e), this.quaternion.multiply(Pt), this
  }
  rotateOnWorldAxis(t, e) {
    return Pt.setFromAxisAngle(t, e), this.quaternion.premultiply(Pt), this
  }
  rotateX(t) {
    return this.rotateOnAxis(Bt, t)
  }
  rotateY(t) {
    return this.rotateOnAxis(Ut, t)
  }
  rotateZ(t) {
    return this.rotateOnAxis(Vt, t)
  }
  translateOnAxis(t, e) {
    return (
      Nt.copy(t).applyQuaternion(this.quaternion), this.position.add(Nt.multiplyScalar(e)), this
    )
  }
  translateX(t) {
    return this.translateOnAxis(Bt, t)
  }
  translateY(t) {
    return this.translateOnAxis(Ut, t)
  }
  translateZ(t) {
    return this.translateOnAxis(Vt, t)
  }
  localToWorld(t) {
    return t.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(t) {
    return t.applyMatrix4(Dt.copy(this.matrixWorld).invert())
  }
  lookAt(t, e, n) {
    t.isVector3 ? Ot.copy(t) : Ot.set(t, e, n)
    const i = this.parent
    this.updateWorldMatrix(!0, !1),
      Ft.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight ? Dt.lookAt(Ft, Ot, this.up) : Dt.lookAt(Ot, Ft, this.up),
      this.quaternion.setFromRotationMatrix(Dt),
      i &&
        (Dt.extractRotation(i.matrixWorld),
        Pt.setFromRotationMatrix(Dt),
        this.quaternion.premultiply(Pt.invert()))
  }
  add(t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
      return this
    }
    return t === this
      ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this)
      : (t && t.isObject3D
          ? (null !== t.parent && t.parent.remove(t),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(Ht))
          : console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', t),
        this)
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.remove(arguments[t])
      return this
    }
    const e = this.children.indexOf(t)
    return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(kt)), this
  }
  removeFromParent() {
    const t = this.parent
    return null !== t && t.remove(this), this
  }
  clear() {
    for (let t = 0; t < this.children.length; t++) {
      const e = this.children[t]
      ;(e.parent = null), e.dispatchEvent(kt)
    }
    return (this.children.length = 0), this
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      Dt.copy(this.matrixWorld).invert(),
      null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Dt.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(Dt),
      this.add(t),
      t.updateWorldMatrix(!1, !0),
      this
    )
  }
  getObjectById(t) {
    return this.getObjectByProperty('id', t)
  }
  getObjectByName(t) {
    return this.getObjectByProperty('name', t)
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this
    for (let n = 0, i = this.children.length; n < i; n++) {
      const i = this.children[n].getObjectByProperty(t, e)
      if (void 0 !== i) return i
    }
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, t, Gt), t
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, zt, t), t
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1)
    const e = this.matrixWorld.elements
    return t.set(e[8], e[9], e[10]).normalize()
  }
  raycast() {}
  traverse(t) {
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
  }
  traverseVisible(t) {
    if (!1 === this.visible) return
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
  }
  traverseAncestors(t) {
    const e = this.parent
    null !== e && (t(e), e.traverseAncestors(t))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0))
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
  }
  updateWorldMatrix(t, e) {
    const n = this.parent
    if (
      (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      null === this.parent
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
      !0 === e)
    ) {
      const t = this.children
      for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
    }
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t,
      n = {}
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }),
      (n.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }))
    const i = {}
    function s(e, n) {
      return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
    }
    if (
      ((i.uuid = this.uuid),
      (i.type = this.type),
      '' !== this.name && (i.name = this.name),
      !0 === this.castShadow && (i.castShadow = !0),
      !0 === this.receiveShadow && (i.receiveShadow = !0),
      !1 === this.visible && (i.visible = !1),
      !1 === this.frustumCulled && (i.frustumCulled = !1),
      0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
      '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = 'InstancedMesh'),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
      this.isScene)
    )
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          (i.environment = this.environment.toJSON(t).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(t.geometries, this.geometry)
      const e = this.geometry.parameters
      if (void 0 !== e && void 0 !== e.shapes) {
        const n = e.shapes
        if (Array.isArray(n))
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e]
            s(t.shapes, i)
          }
        else s(t.shapes, n)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        void 0 !== this.skeleton &&
          (s(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      void 0 !== this.material)
    )
      if (Array.isArray(this.material)) {
        const e = []
        for (let n = 0, i = this.material.length; n < i; n++)
          e.push(s(t.materials, this.material[n]))
        i.material = e
      } else i.material = s(t.materials, this.material)
    if (this.children.length > 0) {
      i.children = []
      for (let e = 0; e < this.children.length; e++)
        i.children.push(this.children[e].toJSON(t).object)
    }
    if (this.animations.length > 0) {
      i.animations = []
      for (let e = 0; e < this.animations.length; e++) {
        const n = this.animations[e]
        i.animations.push(s(t.animations, n))
      }
    }
    if (e) {
      const e = r(t.geometries),
        i = r(t.materials),
        s = r(t.textures),
        o = r(t.images),
        a = r(t.shapes),
        l = r(t.skeletons),
        h = r(t.animations),
        c = r(t.nodes)
      e.length > 0 && (n.geometries = e),
        i.length > 0 && (n.materials = i),
        s.length > 0 && (n.textures = s),
        o.length > 0 && (n.images = o),
        a.length > 0 && (n.shapes = a),
        l.length > 0 && (n.skeletons = l),
        h.length > 0 && (n.animations = h),
        c.length > 0 && (n.nodes = c)
    }
    return (n.object = i), n
    function r(t) {
      const e = []
      for (const n in t) {
        const i = t[n]
        delete i.metadata, e.push(i)
      }
      return e
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t)
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      !0 === e)
    )
      for (let e = 0; e < t.children.length; e++) {
        const n = t.children[e]
        this.add(n.clone())
      }
    return this
  }
}
;(Wt.DefaultUp = new H(0, 1, 0)), (Wt.DefaultMatrixAutoUpdate = !0), (Wt.prototype.isObject3D = !0)
const Yt = new H(),
  jt = new H(),
  qt = new H(),
  Zt = new H(),
  Xt = new H(),
  Kt = new H(),
  Jt = new H(),
  Qt = new H(),
  $t = new H(),
  te = new H()
class ee {
  constructor(t = new H(), e = new H(), n = new H()) {
    ;(this.a = t), (this.b = e), (this.c = n)
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), Yt.subVectors(t, e), i.cross(Yt)
    const s = i.lengthSq()
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
  }
  static getBarycoord(t, e, n, i, s) {
    Yt.subVectors(i, e), jt.subVectors(n, e), qt.subVectors(t, e)
    const r = Yt.dot(Yt),
      o = Yt.dot(jt),
      a = Yt.dot(qt),
      l = jt.dot(jt),
      h = jt.dot(qt),
      c = r * l - o * o
    if (0 === c) return s.set(-2, -1, -1)
    const u = 1 / c,
      d = (l * a - o * h) * u,
      p = (r * h - o * a) * u
    return s.set(1 - d - p, p, d)
  }
  static containsPoint(t, e, n, i) {
    return this.getBarycoord(t, e, n, i, Zt), Zt.x >= 0 && Zt.y >= 0 && Zt.x + Zt.y <= 1
  }
  static getUV(t, e, n, i, s, r, o, a) {
    return (
      this.getBarycoord(t, e, n, i, Zt),
      a.set(0, 0),
      a.addScaledVector(s, Zt.x),
      a.addScaledVector(r, Zt.y),
      a.addScaledVector(o, Zt.z),
      a
    )
  }
  static isFrontFacing(t, e, n, i) {
    return Yt.subVectors(n, e), jt.subVectors(t, e), Yt.cross(jt).dot(i) < 0
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, n),
      this.c.fromBufferAttribute(t, i),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
  }
  getArea() {
    return Yt.subVectors(this.c, this.b), jt.subVectors(this.a, this.b), 0.5 * Yt.cross(jt).length()
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(t) {
    return ee.getNormal(this.a, this.b, this.c, t)
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(t, e) {
    return ee.getBarycoord(t, this.a, this.b, this.c, e)
  }
  getUV(t, e, n, i, s) {
    return ee.getUV(t, this.a, this.b, this.c, e, n, i, s)
  }
  containsPoint(t) {
    return ee.containsPoint(t, this.a, this.b, this.c)
  }
  isFrontFacing(t) {
    return ee.isFrontFacing(this.a, this.b, this.c, t)
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this)
  }
  closestPointToPoint(t, e) {
    const n = this.a,
      i = this.b,
      s = this.c
    let r, o
    Xt.subVectors(i, n), Kt.subVectors(s, n), Qt.subVectors(t, n)
    const a = Xt.dot(Qt),
      l = Kt.dot(Qt)
    if (a <= 0 && l <= 0) return e.copy(n)
    $t.subVectors(t, i)
    const h = Xt.dot($t),
      c = Kt.dot($t)
    if (h >= 0 && c <= h) return e.copy(i)
    const u = a * c - h * l
    if (u <= 0 && a >= 0 && h <= 0) return (r = a / (a - h)), e.copy(n).addScaledVector(Xt, r)
    te.subVectors(t, s)
    const d = Xt.dot(te),
      p = Kt.dot(te)
    if (p >= 0 && d <= p) return e.copy(s)
    const g = d * l - a * p
    if (g <= 0 && l >= 0 && p <= 0) return (o = l / (l - p)), e.copy(n).addScaledVector(Kt, o)
    const f = h * p - d * c
    if (f <= 0 && c - h >= 0 && d - p >= 0)
      return (
        Jt.subVectors(s, i), (o = (c - h) / (c - h + (d - p))), e.copy(i).addScaledVector(Jt, o)
      )
    const m = 1 / (f + g + u)
    return (r = g * m), (o = u * m), e.copy(n).addScaledVector(Xt, r).addScaledVector(Kt, o)
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
  }
}
let ne = 0
class ie extends a {
  constructor() {
    super(),
      Object.defineProperty(this, 'id', { value: ne++ }),
      (this.uuid = d()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.fog = !0),
      (this.blending = 1),
      (this.side = 0),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = 100),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = 7680),
      (this.stencilZFail = 7680),
      (this.stencilZPass = 7680),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t)
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(t) {
    if (void 0 !== t)
      for (const e in t) {
        const n = t[e]
        if (void 0 === n) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.")
          continue
        }
        if ('shading' === e) {
          console.warn(
            'THREE.' +
              this.type +
              ': .shading has been removed. Use the boolean .flatShading instead.'
          ),
            (this.flatShading = 1 === n)
          continue
        }
        const i = this[e]
        void 0 !== i
          ? i && i.isColor
            ? i.set(n)
            : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
          : console.warn('THREE.' + this.type + ": '" + e + "' is not a property of this material.")
      }
  }
  toJSON(t) {
    const e = void 0 === t || 'string' == typeof t
    e && (t = { textures: {}, images: {} })
    const n = { metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' } }
    function i(t) {
      const e = []
      for (const n in t) {
        const i = t[n]
        delete i.metadata, e.push(i)
      }
      return e
    }
    if (
      ((n.uuid = this.uuid),
      (n.type = this.type),
      '' !== this.name && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      void 0 !== this.roughness && (n.roughness = this.roughness),
      void 0 !== this.metalness && (n.metalness = this.metalness),
      void 0 !== this.sheen && (n.sheen = this.sheen),
      this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
      void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
      this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
      void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      void 0 !== this.shininess && (n.shininess = this.shininess),
      void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(t).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid), (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        void 0 !== this.combine && (n.combine = this.combine)),
      void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
      void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
      void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      void 0 !== this.transmission && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      void 0 !== this.thickness && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
      void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
      void 0 !== this.size && (n.size = this.size),
      null !== this.shadowSide && (n.shadowSide = this.shadowSide),
      void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (n.blending = this.blending),
      0 !== this.side && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      !0 === this.transparent && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
      !0 === this.polygonOffset && (n.polygonOffset = !0),
      0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
      void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
      void 0 !== this.dashSize && (n.dashSize = this.dashSize),
      void 0 !== this.gapSize && (n.gapSize = this.gapSize),
      void 0 !== this.scale && (n.scale = this.scale),
      !0 === this.dithering && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
      !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
      !0 === this.wireframe && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
      'round' !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
      'round' !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.flatShading && (n.flatShading = this.flatShading),
      !1 === this.visible && (n.visible = !1),
      !1 === this.toneMapped && (n.toneMapped = !1),
      '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
      e)
    ) {
      const e = i(t.textures),
        s = i(t.images)
      e.length > 0 && (n.textures = e), s.length > 0 && (n.images = s)
    }
    return n
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.name = t.name),
      (this.fog = t.fog),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite)
    const e = t.clippingPlanes
    let n = null
    if (null !== e) {
      const t = e.length
      n = new Array(t)
      for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  set needsUpdate(t) {
    !0 === t && this.version++
  }
}
;(ie.prototype.isMaterial = !0),
  (ie.fromType = function () {
    return null
  })
class se extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new L(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    )
  }
}
se.prototype.isMeshBasicMaterial = !0
const re = new H(),
  oe = new _()
class ae {
  constructor(t, e, n) {
    if (Array.isArray(t))
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')
    ;(this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = !0 === n),
      (this.usage = 35044),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.itemSize), (n *= e.itemSize)
    for (let i = 0, s = this.itemSize; i < s; i++) this.array[t + i] = e.array[n + i]
    return this
  }
  copyArray(t) {
    return this.array.set(t), this
  }
  copyColorsArray(t) {
    const e = this.array
    let n = 0
    for (let i = 0, s = t.length; i < s; i++) {
      let s = t[i]
      void 0 === s &&
        (console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i),
        (s = new L())),
        (e[n++] = s.r),
        (e[n++] = s.g),
        (e[n++] = s.b)
    }
    return this
  }
  copyVector2sArray(t) {
    const e = this.array
    let n = 0
    for (let i = 0, s = t.length; i < s; i++) {
      let s = t[i]
      void 0 === s &&
        (console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i),
        (s = new _())),
        (e[n++] = s.x),
        (e[n++] = s.y)
    }
    return this
  }
  copyVector3sArray(t) {
    const e = this.array
    let n = 0
    for (let i = 0, s = t.length; i < s; i++) {
      let s = t[i]
      void 0 === s &&
        (console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i),
        (s = new H())),
        (e[n++] = s.x),
        (e[n++] = s.y),
        (e[n++] = s.z)
    }
    return this
  }
  copyVector4sArray(t) {
    const e = this.array
    let n = 0
    for (let i = 0, s = t.length; i < s; i++) {
      let s = t[i]
      void 0 === s &&
        (console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i),
        (s = new G())),
        (e[n++] = s.x),
        (e[n++] = s.y),
        (e[n++] = s.z),
        (e[n++] = s.w)
    }
    return this
  }
  applyMatrix3(t) {
    if (2 === this.itemSize)
      for (let e = 0, n = this.count; e < n; e++)
        oe.fromBufferAttribute(this, e), oe.applyMatrix3(t), this.setXY(e, oe.x, oe.y)
    else if (3 === this.itemSize)
      for (let e = 0, n = this.count; e < n; e++)
        re.fromBufferAttribute(this, e), re.applyMatrix3(t), this.setXYZ(e, re.x, re.y, re.z)
    return this
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (re.x = this.getX(e)),
        (re.y = this.getY(e)),
        (re.z = this.getZ(e)),
        re.applyMatrix4(t),
        this.setXYZ(e, re.x, re.y, re.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (re.x = this.getX(e)),
        (re.y = this.getY(e)),
        (re.z = this.getZ(e)),
        re.applyNormalMatrix(t),
        this.setXYZ(e, re.x, re.y, re.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (re.x = this.getX(e)),
        (re.y = this.getY(e)),
        (re.z = this.getZ(e)),
        re.transformDirection(t),
        this.setXYZ(e, re.x, re.y, re.z)
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  getX(t) {
    return this.array[t * this.itemSize]
  }
  setX(t, e) {
    return (this.array[t * this.itemSize] = e), this
  }
  getY(t) {
    return this.array[t * this.itemSize + 1]
  }
  setY(t, e) {
    return (this.array[t * this.itemSize + 1] = e), this
  }
  getZ(t) {
    return this.array[t * this.itemSize + 2]
  }
  setZ(t, e) {
    return (this.array[t * this.itemSize + 2] = e), this
  }
  getW(t) {
    return this.array[t * this.itemSize + 3]
  }
  setW(t, e) {
    return (this.array[t * this.itemSize + 3] = e), this
  }
  setXY(t, e, n) {
    return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = n), this
  }
  setXYZ(t, e, n, i) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, s) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      (this.array[t + 3] = s),
      this
    )
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    }
    return (
      '' !== this.name && (t.name = this.name),
      35044 !== this.usage && (t.usage = this.usage),
      (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
        (t.updateRange = this.updateRange),
      t
    )
  }
}
ae.prototype.isBufferAttribute = !0
class le extends ae {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n)
  }
}
class he extends ae {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n)
  }
}
;(class extends ae {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n)
  }
}).prototype.isFloat16BufferAttribute = !0
class ce extends ae {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n)
  }
}
let ue = 0
const de = new vt(),
  pe = new Wt(),
  ge = new H(),
  fe = new Y(),
  me = new Y(),
  ye = new H()
class xe extends a {
  constructor() {
    super(),
      Object.defineProperty(this, 'id', { value: ue++ }),
      (this.uuid = d()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(t) {
    return Array.isArray(t) ? (this.index = new (E(t) ? he : le)(t, 1)) : (this.index = t), this
  }
  getAttribute(t) {
    return this.attributes[t]
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this
  }
  hasAttribute(t) {
    return void 0 !== this.attributes[t]
  }
  addGroup(t, e, n = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(t, e) {
    ;(this.drawRange.start = t), (this.drawRange.count = e)
  }
  applyMatrix4(t) {
    const e = this.attributes.position
    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
    const n = this.attributes.normal
    if (void 0 !== n) {
      const e = new w().getNormalMatrix(t)
      n.applyNormalMatrix(e), (n.needsUpdate = !0)
    }
    const i = this.attributes.tangent
    return (
      void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(t) {
    return de.makeRotationFromQuaternion(t), this.applyMatrix4(de), this
  }
  rotateX(t) {
    return de.makeRotationX(t), this.applyMatrix4(de), this
  }
  rotateY(t) {
    return de.makeRotationY(t), this.applyMatrix4(de), this
  }
  rotateZ(t) {
    return de.makeRotationZ(t), this.applyMatrix4(de), this
  }
  translate(t, e, n) {
    return de.makeTranslation(t, e, n), this.applyMatrix4(de), this
  }
  scale(t, e, n) {
    return de.makeScale(t, e, n), this.applyMatrix4(de), this
  }
  lookAt(t) {
    return pe.lookAt(t), pe.updateMatrix(), this.applyMatrix4(pe.matrix), this
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(ge).negate(),
      this.translate(ge.x, ge.y, ge.z),
      this
    )
  }
  setFromPoints(t) {
    const e = []
    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n]
      e.push(i.x, i.y, i.z || 0)
    }
    return this.setAttribute('position', new ce(e, 3)), this
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new Y())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingBox.set(new H(-1 / 0, -1 / 0, -1 / 0), new H(1 / 0, 1 / 0, 1 / 0))
      )
    if (void 0 !== t) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t]
          fe.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (ye.addVectors(this.boundingBox.min, fe.min),
                this.boundingBox.expandByPoint(ye),
                ye.addVectors(this.boundingBox.max, fe.max),
                this.boundingBox.expandByPoint(ye))
              : (this.boundingBox.expandByPoint(fe.min), this.boundingBox.expandByPoint(fe.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      )
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new ct())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingSphere.set(new H(), 1 / 0)
      )
    if (t) {
      const n = this.boundingSphere.center
      if ((fe.setFromBufferAttribute(t), e))
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t]
          me.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (ye.addVectors(fe.min, me.min),
                fe.expandByPoint(ye),
                ye.addVectors(fe.max, me.max),
                fe.expandByPoint(ye))
              : (fe.expandByPoint(me.min), fe.expandByPoint(me.max))
        }
      fe.getCenter(n)
      let i = 0
      for (let e = 0, s = t.count; e < s; e++)
        ye.fromBufferAttribute(t, e), (i = Math.max(i, n.distanceToSquared(ye)))
      if (e)
        for (let s = 0, r = e.length; s < r; s++) {
          const r = e[s],
            o = this.morphTargetsRelative
          for (let e = 0, s = r.count; e < s; e++)
            ye.fromBufferAttribute(r, e),
              o && (ge.fromBufferAttribute(t, e), ye.add(ge)),
              (i = Math.max(i, n.distanceToSquared(ye)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          )
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes
    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
      return void console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
      )
    const n = t.array,
      i = e.position.array,
      s = e.normal.array,
      r = e.uv.array,
      o = i.length / 3
    !1 === this.hasAttribute('tangent') &&
      this.setAttribute('tangent', new ae(new Float32Array(4 * o), 4))
    const a = this.getAttribute('tangent').array,
      l = [],
      h = []
    for (let t = 0; t < o; t++) (l[t] = new H()), (h[t] = new H())
    const c = new H(),
      u = new H(),
      d = new H(),
      p = new _(),
      g = new _(),
      f = new _(),
      m = new H(),
      y = new H()
    function x(t, e, n) {
      c.fromArray(i, 3 * t),
        u.fromArray(i, 3 * e),
        d.fromArray(i, 3 * n),
        p.fromArray(r, 2 * t),
        g.fromArray(r, 2 * e),
        f.fromArray(r, 2 * n),
        u.sub(c),
        d.sub(c),
        g.sub(p),
        f.sub(p)
      const s = 1 / (g.x * f.y - f.x * g.y)
      isFinite(s) &&
        (m.copy(u).multiplyScalar(f.y).addScaledVector(d, -g.y).multiplyScalar(s),
        y.copy(d).multiplyScalar(g.x).addScaledVector(u, -f.x).multiplyScalar(s),
        l[t].add(m),
        l[e].add(m),
        l[n].add(m),
        h[t].add(y),
        h[e].add(y),
        h[n].add(y))
    }
    let v = this.groups
    0 === v.length && (v = [{ start: 0, count: n.length }])
    for (let t = 0, e = v.length; t < e; ++t) {
      const e = v[t],
        i = e.start
      for (let t = i, s = i + e.count; t < s; t += 3) x(n[t + 0], n[t + 1], n[t + 2])
    }
    const w = new H(),
      E = new H(),
      b = new H(),
      M = new H()
    function S(t) {
      b.fromArray(s, 3 * t), M.copy(b)
      const e = l[t]
      w.copy(e), w.sub(b.multiplyScalar(b.dot(e))).normalize(), E.crossVectors(M, e)
      const n = E.dot(h[t]) < 0 ? -1 : 1
      ;(a[4 * t] = w.x), (a[4 * t + 1] = w.y), (a[4 * t + 2] = w.z), (a[4 * t + 3] = n)
    }
    for (let t = 0, e = v.length; t < e; ++t) {
      const e = v[t],
        i = e.start
      for (let t = i, s = i + e.count; t < s; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute('position')
    if (void 0 !== e) {
      let n = this.getAttribute('normal')
      if (void 0 === n)
        (n = new ae(new Float32Array(3 * e.count), 3)), this.setAttribute('normal', n)
      else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0)
      const i = new H(),
        s = new H(),
        r = new H(),
        o = new H(),
        a = new H(),
        l = new H(),
        h = new H(),
        c = new H()
      if (t)
        for (let u = 0, d = t.count; u < d; u += 3) {
          const d = t.getX(u + 0),
            p = t.getX(u + 1),
            g = t.getX(u + 2)
          i.fromBufferAttribute(e, d),
            s.fromBufferAttribute(e, p),
            r.fromBufferAttribute(e, g),
            h.subVectors(r, s),
            c.subVectors(i, s),
            h.cross(c),
            o.fromBufferAttribute(n, d),
            a.fromBufferAttribute(n, p),
            l.fromBufferAttribute(n, g),
            o.add(h),
            a.add(h),
            l.add(h),
            n.setXYZ(d, o.x, o.y, o.z),
            n.setXYZ(p, a.x, a.y, a.z),
            n.setXYZ(g, l.x, l.y, l.z)
        }
      else
        for (let t = 0, o = e.count; t < o; t += 3)
          i.fromBufferAttribute(e, t + 0),
            s.fromBufferAttribute(e, t + 1),
            r.fromBufferAttribute(e, t + 2),
            h.subVectors(r, s),
            c.subVectors(i, s),
            h.cross(c),
            n.setXYZ(t + 0, h.x, h.y, h.z),
            n.setXYZ(t + 1, h.x, h.y, h.z),
            n.setXYZ(t + 2, h.x, h.y, h.z)
      this.normalizeNormals(), (n.needsUpdate = !0)
    }
  }
  merge(t, e) {
    if (!t || !t.isBufferGeometry)
      return void console.error(
        'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
        t
      )
    void 0 === e &&
      ((e = 0),
      console.warn(
        'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
      ))
    const n = this.attributes
    for (const i in n) {
      if (void 0 === t.attributes[i]) continue
      const s = n[i].array,
        r = t.attributes[i],
        o = r.array,
        a = r.itemSize * e,
        l = Math.min(o.length, s.length - a)
      for (let t = 0, e = a; t < l; t++, e++) s[e] = o[t]
    }
    return this
  }
  normalizeNormals() {
    const t = this.attributes.normal
    for (let e = 0, n = t.count; e < n; e++)
      ye.fromBufferAttribute(t, e), ye.normalize(), t.setXYZ(e, ye.x, ye.y, ye.z)
  }
  toNonIndexed() {
    function t(t, e) {
      const n = t.array,
        i = t.itemSize,
        s = t.normalized,
        r = new n.constructor(e.length * i)
      let o = 0,
        a = 0
      for (let s = 0, l = e.length; s < l; s++) {
        o = t.isInterleavedBufferAttribute ? e[s] * t.data.stride + t.offset : e[s] * i
        for (let t = 0; t < i; t++) r[a++] = n[o++]
      }
      return new ae(r, i, s)
    }
    if (null === this.index)
      return (
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'),
        this
      )
    const e = new xe(),
      n = this.index.array,
      i = this.attributes
    for (const s in i) {
      const r = t(i[s], n)
      e.setAttribute(s, r)
    }
    const s = this.morphAttributes
    for (const i in s) {
      const r = [],
        o = s[i]
      for (let e = 0, i = o.length; e < i; e++) {
        const i = t(o[e], n)
        r.push(i)
      }
      e.morphAttributes[i] = r
    }
    e.morphTargetsRelative = this.morphTargetsRelative
    const r = this.groups
    for (let t = 0, n = r.length; t < n; t++) {
      const n = r[t]
      e.addGroup(n.start, n.count, n.materialIndex)
    }
    return e
  }
  toJSON() {
    const t = {
      metadata: { version: 4.5, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' }
    }
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      '' !== this.name && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const e = this.parameters
      for (const n in e) void 0 !== e[n] && (t[n] = e[n])
      return t
    }
    t.data = { attributes: {} }
    const e = this.index
    null !== e &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array)
      })
    const n = this.attributes
    for (const e in n) {
      const i = n[e]
      t.data.attributes[e] = i.toJSON(t.data)
    }
    const i = {}
    let s = !1
    for (const e in this.morphAttributes) {
      const n = this.morphAttributes[e],
        r = []
      for (let e = 0, i = n.length; e < i; e++) {
        const i = n[e]
        r.push(i.toJSON(t.data))
      }
      r.length > 0 && ((i[e] = r), (s = !0))
    }
    s && ((t.data.morphAttributes = i), (t.data.morphTargetsRelative = this.morphTargetsRelative))
    const r = this.groups
    r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)))
    const o = this.boundingSphere
    return (
      null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const e = {}
    this.name = t.name
    const n = t.index
    null !== n && this.setIndex(n.clone(e))
    const i = t.attributes
    for (const t in i) {
      const n = i[t]
      this.setAttribute(t, n.clone(e))
    }
    const s = t.morphAttributes
    for (const t in s) {
      const n = [],
        i = s[t]
      for (let t = 0, s = i.length; t < s; t++) n.push(i[t].clone(e))
      this.morphAttributes[t] = n
    }
    this.morphTargetsRelative = t.morphTargetsRelative
    const r = t.groups
    for (let t = 0, e = r.length; t < e; t++) {
      const e = r[t]
      this.addGroup(e.start, e.count, e.materialIndex)
    }
    const o = t.boundingBox
    null !== o && (this.boundingBox = o.clone())
    const a = t.boundingSphere
    return (
      null !== a && (this.boundingSphere = a.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
xe.prototype.isBufferGeometry = !0
const ve = new vt(),
  _e = new xt(),
  we = new ct(),
  Ee = new H(),
  be = new H(),
  Me = new H(),
  Se = new H(),
  Ae = new H(),
  Te = new H(),
  Ie = new H(),
  Re = new H(),
  Le = new H(),
  Ce = new _(),
  Ne = new _(),
  Pe = new _(),
  De = new H(),
  Oe = new H()
class Fe extends Wt {
  constructor(t = new xe(), e = new se()) {
    super(),
      (this.type = 'Mesh'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t) {
    return (
      super.copy(t),
      void 0 !== t.morphTargetInfluences &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      void 0 !== t.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  updateMorphTargets() {
    const t = this.geometry
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e)
      if (n.length > 0) {
        const t = e[n[0]]
        if (void 0 !== t) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e)
            this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
          }
        }
      }
    } else {
      const e = t.morphTargets
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
    }
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld
    if (void 0 === i) return
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      we.copy(n.boundingSphere),
      we.applyMatrix4(s),
      !1 === t.ray.intersectsSphere(we))
    )
      return
    if (
      (ve.copy(s).invert(),
      _e.copy(t.ray).applyMatrix4(ve),
      null !== n.boundingBox && !1 === _e.intersectsBox(n.boundingBox))
    )
      return
    let r
    if (n.isBufferGeometry) {
      const s = n.index,
        o = n.attributes.position,
        a = n.morphAttributes.position,
        l = n.morphTargetsRelative,
        h = n.attributes.uv,
        c = n.attributes.uv2,
        u = n.groups,
        d = n.drawRange
      if (null !== s)
        if (Array.isArray(i))
          for (let n = 0, p = u.length; n < p; n++) {
            const p = u[n],
              g = i[p.materialIndex]
            for (
              let n = Math.max(p.start, d.start),
                i = Math.min(s.count, Math.min(p.start + p.count, d.start + d.count));
              n < i;
              n += 3
            ) {
              const i = s.getX(n),
                u = s.getX(n + 1),
                d = s.getX(n + 2)
              ;(r = Ge(this, g, t, _e, o, a, l, h, c, i, u, d)),
                r &&
                  ((r.faceIndex = Math.floor(n / 3)),
                  (r.face.materialIndex = p.materialIndex),
                  e.push(r))
            }
          }
        else {
          for (
            let n = Math.max(0, d.start), u = Math.min(s.count, d.start + d.count);
            n < u;
            n += 3
          ) {
            const u = s.getX(n),
              d = s.getX(n + 1),
              p = s.getX(n + 2)
            ;(r = Ge(this, i, t, _e, o, a, l, h, c, u, d, p)),
              r && ((r.faceIndex = Math.floor(n / 3)), e.push(r))
          }
        }
      else if (void 0 !== o)
        if (Array.isArray(i))
          for (let n = 0, s = u.length; n < s; n++) {
            const s = u[n],
              p = i[s.materialIndex]
            for (
              let n = Math.max(s.start, d.start),
                i = Math.min(o.count, Math.min(s.start + s.count, d.start + d.count));
              n < i;
              n += 3
            ) {
              ;(r = Ge(this, p, t, _e, o, a, l, h, c, n, n + 1, n + 2)),
                r &&
                  ((r.faceIndex = Math.floor(n / 3)),
                  (r.face.materialIndex = s.materialIndex),
                  e.push(r))
            }
          }
        else {
          for (
            let n = Math.max(0, d.start), s = Math.min(o.count, d.start + d.count);
            n < s;
            n += 3
          ) {
            ;(r = Ge(this, i, t, _e, o, a, l, h, c, n, n + 1, n + 2)),
              r && ((r.faceIndex = Math.floor(n / 3)), e.push(r))
          }
        }
    } else
      n.isGeometry &&
        console.error(
          'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
  }
}
function Ge(t, e, n, i, s, r, o, a, l, h, c, u) {
  Ee.fromBufferAttribute(s, h), be.fromBufferAttribute(s, c), Me.fromBufferAttribute(s, u)
  const d = t.morphTargetInfluences
  if (r && d) {
    Ie.set(0, 0, 0), Re.set(0, 0, 0), Le.set(0, 0, 0)
    for (let t = 0, e = r.length; t < e; t++) {
      const e = d[t],
        n = r[t]
      0 !== e &&
        (Se.fromBufferAttribute(n, h),
        Ae.fromBufferAttribute(n, c),
        Te.fromBufferAttribute(n, u),
        o
          ? (Ie.addScaledVector(Se, e), Re.addScaledVector(Ae, e), Le.addScaledVector(Te, e))
          : (Ie.addScaledVector(Se.sub(Ee), e),
            Re.addScaledVector(Ae.sub(be), e),
            Le.addScaledVector(Te.sub(Me), e)))
    }
    Ee.add(Ie), be.add(Re), Me.add(Le)
  }
  t.isSkinnedMesh && (t.boneTransform(h, Ee), t.boneTransform(c, be), t.boneTransform(u, Me))
  const p = (function (t, e, n, i, s, r, o, a) {
    let l
    if (
      ((l =
        1 === e.side
          ? i.intersectTriangle(o, r, s, !0, a)
          : i.intersectTriangle(s, r, o, 2 !== e.side, a)),
      null === l)
    )
      return null
    Oe.copy(a), Oe.applyMatrix4(t.matrixWorld)
    const h = n.ray.origin.distanceTo(Oe)
    return h < n.near || h > n.far ? null : { distance: h, point: Oe.clone(), object: t }
  })(t, e, n, i, Ee, be, Me, De)
  if (p) {
    a &&
      (Ce.fromBufferAttribute(a, h),
      Ne.fromBufferAttribute(a, c),
      Pe.fromBufferAttribute(a, u),
      (p.uv = ee.getUV(De, Ee, be, Me, Ce, Ne, Pe, new _()))),
      l &&
        (Ce.fromBufferAttribute(l, h),
        Ne.fromBufferAttribute(l, c),
        Pe.fromBufferAttribute(l, u),
        (p.uv2 = ee.getUV(De, Ee, be, Me, Ce, Ne, Pe, new _())))
    const t = { a: h, b: c, c: u, normal: new H(), materialIndex: 0 }
    ee.getNormal(Ee, be, Me, t.normal), (p.face = t)
  }
  return p
}
Fe.prototype.isMesh = !0
class ze extends xe {
  constructor(t = 1, e = 1, n = 1, i = 1, s = 1, r = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: r
      })
    const o = this
    ;(i = Math.floor(i)), (s = Math.floor(s)), (r = Math.floor(r))
    const a = [],
      l = [],
      h = [],
      c = []
    let u = 0,
      d = 0
    function p(t, e, n, i, s, r, p, g, f, m, y) {
      const x = r / f,
        v = p / m,
        _ = r / 2,
        w = p / 2,
        E = g / 2,
        b = f + 1,
        M = m + 1
      let S = 0,
        A = 0
      const T = new H()
      for (let r = 0; r < M; r++) {
        const o = r * v - w
        for (let a = 0; a < b; a++) {
          const u = a * x - _
          ;(T[t] = u * i),
            (T[e] = o * s),
            (T[n] = E),
            l.push(T.x, T.y, T.z),
            (T[t] = 0),
            (T[e] = 0),
            (T[n] = g > 0 ? 1 : -1),
            h.push(T.x, T.y, T.z),
            c.push(a / f),
            c.push(1 - r / m),
            (S += 1)
        }
      }
      for (let t = 0; t < m; t++)
        for (let e = 0; e < f; e++) {
          const n = u + e + b * t,
            i = u + e + b * (t + 1),
            s = u + (e + 1) + b * (t + 1),
            r = u + (e + 1) + b * t
          a.push(n, i, r), a.push(i, s, r), (A += 6)
        }
      o.addGroup(d, A, y), (d += A), (u += S)
    }
    p('z', 'y', 'x', -1, -1, n, e, t, r, s, 0),
      p('z', 'y', 'x', 1, -1, n, e, -t, r, s, 1),
      p('x', 'z', 'y', 1, 1, t, n, e, i, r, 2),
      p('x', 'z', 'y', 1, -1, t, n, -e, i, r, 3),
      p('x', 'y', 'z', 1, -1, t, e, n, i, s, 4),
      p('x', 'y', 'z', -1, -1, t, e, -n, i, s, 5),
      this.setIndex(a),
      this.setAttribute('position', new ce(l, 3)),
      this.setAttribute('normal', new ce(h, 3)),
      this.setAttribute('uv', new ce(c, 2))
  }
  static fromJSON(t) {
    return new ze(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
  }
}
function Be(t) {
  const e = {}
  for (const n in t) {
    e[n] = {}
    for (const i in t[n]) {
      const s = t[n][i]
      s &&
      (s.isColor ||
        s.isMatrix3 ||
        s.isMatrix4 ||
        s.isVector2 ||
        s.isVector3 ||
        s.isVector4 ||
        s.isTexture ||
        s.isQuaternion)
        ? (e[n][i] = s.clone())
        : Array.isArray(s)
          ? (e[n][i] = s.slice())
          : (e[n][i] = s)
    }
  }
  return e
}
function Ue(t) {
  const e = {}
  for (let n = 0; n < t.length; n++) {
    const i = Be(t[n])
    for (const t in i) e[t] = i[t]
  }
  return e
}
const Ve = { clone: Be, merge: Ue }
class He extends ie {
  constructor(t) {
    super(),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
      (this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      void 0 !== t &&
        (void 0 !== t.attributes &&
          console.error(
            'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
          ),
        this.setValues(t))
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = Be(t.uniforms)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
    for (const n in this.uniforms) {
      const i = this.uniforms[n].value
      i && i.isTexture
        ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
        : i && i.isColor
          ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
          : i && i.isVector2
            ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
            : i && i.isVector3
              ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
              : i && i.isVector4
                ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
                : i && i.isMatrix3
                  ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
                  : i && i.isMatrix4
                    ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
                    : (e.uniforms[n] = { value: i })
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader)
    const n = {}
    for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0)
    return Object.keys(n).length > 0 && (e.extensions = n), e
  }
}
He.prototype.isShaderMaterial = !0
class ke extends Wt {
  constructor() {
    super(),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new vt()),
      (this.projectionMatrix = new vt()),
      (this.projectionMatrixInverse = new vt())
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      this
    )
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1)
    const e = this.matrixWorld.elements
    return t.set(-e[8], -e[9], -e[10]).normalize()
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
ke.prototype.isCamera = !0
class We extends ke {
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super(),
      (this.type = 'PerspectiveCamera'),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    )
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t
    ;(this.fov = 2 * u * Math.atan(e)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const t = Math.tan(0.5 * c * this.fov)
    return (0.5 * this.getFilmHeight()) / t
  }
  getEffectiveFOV() {
    return 2 * u * Math.atan(Math.tan(0.5 * c * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  setViewOffset(t, e, n, i, s, r) {
    ;(this.aspect = t / e),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = this.near
    let e = (t * Math.tan(0.5 * c * this.fov)) / this.zoom,
      n = 2 * e,
      i = this.aspect * n,
      s = -0.5 * i
    const r = this.view
    if (null !== this.view && this.view.enabled) {
      const t = r.fullWidth,
        o = r.fullHeight
      ;(s += (r.offsetX * i) / t),
        (e -= (r.offsetY * n) / o),
        (i *= r.width / t),
        (n *= r.height / o)
    }
    const o = this.filmOffset
    0 !== o && (s += (t * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + i, e, e - n, t, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    )
  }
}
We.prototype.isPerspectiveCamera = !0
class Ye extends Wt {
  constructor(t, e, n) {
    if ((super(), (this.type = 'CubeCamera'), !0 !== n.isWebGLCubeRenderTarget))
      return void console.error(
        'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.'
      )
    this.renderTarget = n
    const i = new We(90, 1, t, e)
    ;(i.layers = this.layers), i.up.set(0, -1, 0), i.lookAt(new H(1, 0, 0)), this.add(i)
    const s = new We(90, 1, t, e)
    ;(s.layers = this.layers), s.up.set(0, -1, 0), s.lookAt(new H(-1, 0, 0)), this.add(s)
    const r = new We(90, 1, t, e)
    ;(r.layers = this.layers), r.up.set(0, 0, 1), r.lookAt(new H(0, 1, 0)), this.add(r)
    const o = new We(90, 1, t, e)
    ;(o.layers = this.layers), o.up.set(0, 0, -1), o.lookAt(new H(0, -1, 0)), this.add(o)
    const a = new We(90, 1, t, e)
    ;(a.layers = this.layers), a.up.set(0, -1, 0), a.lookAt(new H(0, 0, 1)), this.add(a)
    const l = new We(90, 1, t, e)
    ;(l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new H(0, 0, -1)), this.add(l)
  }
  update(t, e) {
    null === this.parent && this.updateMatrixWorld()
    const n = this.renderTarget,
      [i, s, r, o, a, l] = this.children,
      h = t.getRenderTarget(),
      c = t.outputEncoding,
      u = t.toneMapping,
      d = t.xr.enabled
    ;(t.outputEncoding = 3e3), (t.toneMapping = 0), (t.xr.enabled = !1)
    const p = n.texture.generateMipmaps
    ;(n.texture.generateMipmaps = !1),
      t.setRenderTarget(n, 0),
      t.render(e, i),
      t.setRenderTarget(n, 1),
      t.render(e, s),
      t.setRenderTarget(n, 2),
      t.render(e, r),
      t.setRenderTarget(n, 3),
      t.render(e, o),
      t.setRenderTarget(n, 4),
      t.render(e, a),
      (n.texture.generateMipmaps = p),
      t.setRenderTarget(n, 5),
      t.render(e, l),
      t.setRenderTarget(h),
      (t.outputEncoding = c),
      (t.toneMapping = u),
      (t.xr.enabled = d),
      (n.texture.needsPMREMUpdate = !0)
  }
}
class je extends F {
  constructor(t, e, n, i, s, r, o, a, l, h) {
    super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : 301), n, i, s, r, o, a, l, h),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(t) {
    this.image = t
  }
}
je.prototype.isCubeTexture = !0
class qe extends z {
  constructor(t, e = {}) {
    super(t, t, e)
    const n = { width: t, height: t, depth: 1 },
      i = [n, n, n, n, n, n]
    ;(this.texture = new je(
      i,
      e.mapping,
      e.wrapS,
      e.wrapT,
      e.magFilter,
      e.minFilter,
      e.format,
      e.type,
      e.anisotropy,
      e.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps),
      (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006)
  }
  fromEquirectangularTexture(t, e) {
    ;(this.texture.type = e.type),
      (this.texture.format = 1023),
      (this.texture.encoding = e.encoding),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter)
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
        fragmentShader:
          '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t'
      },
      i = new ze(5, 5, 5),
      s = new He({
        name: 'CubemapFromEquirect',
        uniforms: Be(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: 1,
        blending: 0
      })
    s.uniforms.tEquirect.value = e
    const r = new Fe(i, s),
      o = e.minFilter
    1008 === e.minFilter && (e.minFilter = 1006)
    return (
      new Ye(1, 10, this).update(t, r),
      (e.minFilter = o),
      r.geometry.dispose(),
      r.material.dispose(),
      this
    )
  }
  clear(t, e, n, i) {
    const s = t.getRenderTarget()
    for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, i)
    t.setRenderTarget(s)
  }
}
qe.prototype.isWebGLCubeRenderTarget = !0
const Ze = new H(),
  Xe = new H(),
  Ke = new w()
class Je {
  constructor(t = new H(1, 0, 0), e = 0) {
    ;(this.normal = t), (this.constant = e)
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
  }
  setFromCoplanarPoints(t, e, n) {
    const i = Ze.subVectors(n, e).cross(Xe.subVectors(t, e)).normalize()
    return this.setFromNormalAndCoplanarPoint(i, t), this
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this
  }
  normalize() {
    const t = 1 / this.normal.length()
    return this.normal.multiplyScalar(t), (this.constant *= t), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius
  }
  projectPoint(t, e) {
    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
  }
  intersectLine(t, e) {
    const n = t.delta(Ze),
      i = this.normal.dot(n)
    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null
    const s = -(t.start.dot(this.normal) + this.constant) / i
    return s < 0 || s > 1 ? null : e.copy(n).multiplyScalar(s).add(t.start)
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end)
    return (e < 0 && n > 0) || (n < 0 && e > 0)
  }
  intersectsBox(t) {
    return t.intersectsPlane(this)
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this)
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(t, e) {
    const n = e || Ke.getNormalMatrix(t),
      i = this.coplanarPoint(Ze).applyMatrix4(t),
      s = this.normal.applyMatrix3(n).normalize()
    return (this.constant = -i.dot(s)), this
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
Je.prototype.isPlane = !0
const Qe = new ct(),
  $e = new H()
class tn {
  constructor(t = new Je(), e = new Je(), n = new Je(), i = new Je(), s = new Je(), r = new Je()) {
    this.planes = [t, e, n, i, s, r]
  }
  set(t, e, n, i, s, r) {
    const o = this.planes
    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(s), o[5].copy(r), this
  }
  copy(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n])
    return this
  }
  setFromProjectionMatrix(t) {
    const e = this.planes,
      n = t.elements,
      i = n[0],
      s = n[1],
      r = n[2],
      o = n[3],
      a = n[4],
      l = n[5],
      h = n[6],
      c = n[7],
      u = n[8],
      d = n[9],
      p = n[10],
      g = n[11],
      f = n[12],
      m = n[13],
      y = n[14],
      x = n[15]
    return (
      e[0].setComponents(o - i, c - a, g - u, x - f).normalize(),
      e[1].setComponents(o + i, c + a, g + u, x + f).normalize(),
      e[2].setComponents(o + s, c + l, g + d, x + m).normalize(),
      e[3].setComponents(o - s, c - l, g - d, x - m).normalize(),
      e[4].setComponents(o - r, c - h, g - p, x - y).normalize(),
      e[5].setComponents(o + r, c + h, g + p, x + y).normalize(),
      this
    )
  }
  intersectsObject(t) {
    const e = t.geometry
    return (
      null === e.boundingSphere && e.computeBoundingSphere(),
      Qe.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
      this.intersectsSphere(Qe)
    )
  }
  intersectsSprite(t) {
    return (
      Qe.center.set(0, 0, 0),
      (Qe.radius = 0.7071067811865476),
      Qe.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(Qe)
    )
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius
    for (let t = 0; t < 6; t++) {
      if (e[t].distanceToPoint(n) < i) return !1
    }
    return !0
  }
  intersectsBox(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) {
      const i = e[n]
      if (
        (($e.x = i.normal.x > 0 ? t.max.x : t.min.x),
        ($e.y = i.normal.y > 0 ? t.max.y : t.min.y),
        ($e.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint($e) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function en() {
  let t = null,
    e = !1,
    n = null,
    i = null
  function s(e, r) {
    n(e, r), (i = t.requestAnimationFrame(s))
  }
  return {
    start: function () {
      !0 !== e && null !== n && ((i = t.requestAnimationFrame(s)), (e = !0))
    },
    stop: function () {
      t.cancelAnimationFrame(i), (e = !1)
    },
    setAnimationLoop: function (t) {
      n = t
    },
    setContext: function (e) {
      t = e
    }
  }
}
function nn(t, e) {
  const n = e.isWebGL2,
    i = new WeakMap()
  return {
    get: function (t) {
      return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
    },
    remove: function (e) {
      e.isInterleavedBufferAttribute && (e = e.data)
      const n = i.get(e)
      n && (t.deleteBuffer(n.buffer), i.delete(e))
    },
    update: function (e, s) {
      if (e.isGLBufferAttribute) {
        const t = i.get(e)
        return void (
          (!t || t.version < e.version) &&
          i.set(e, {
            buffer: e.buffer,
            type: e.type,
            bytesPerElement: e.elementSize,
            version: e.version
          })
        )
      }
      e.isInterleavedBufferAttribute && (e = e.data)
      const r = i.get(e)
      void 0 === r
        ? i.set(
            e,
            (function (e, i) {
              const s = e.array,
                r = e.usage,
                o = t.createBuffer()
              let a
              if (
                (t.bindBuffer(i, o),
                t.bufferData(i, s, r),
                e.onUploadCallback(),
                s instanceof Float32Array)
              )
                a = 5126
              else if (s instanceof Uint16Array)
                if (e.isFloat16BufferAttribute) {
                  if (!n)
                    throw new Error(
                      'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
                    )
                  a = 5131
                } else a = 5123
              else if (s instanceof Int16Array) a = 5122
              else if (s instanceof Uint32Array) a = 5125
              else if (s instanceof Int32Array) a = 5124
              else if (s instanceof Int8Array) a = 5120
              else if (s instanceof Uint8Array) a = 5121
              else {
                if (!(s instanceof Uint8ClampedArray))
                  throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + s)
                a = 5121
              }
              return {
                buffer: o,
                type: a,
                bytesPerElement: s.BYTES_PER_ELEMENT,
                version: e.version
              }
            })(e, s)
          )
        : r.version < e.version &&
          (!(function (e, i, s) {
            const r = i.array,
              o = i.updateRange
            t.bindBuffer(s, e),
              -1 === o.count
                ? t.bufferSubData(s, 0, r)
                : (n
                    ? t.bufferSubData(s, o.offset * r.BYTES_PER_ELEMENT, r, o.offset, o.count)
                    : t.bufferSubData(
                        s,
                        o.offset * r.BYTES_PER_ELEMENT,
                        r.subarray(o.offset, o.offset + o.count)
                      ),
                  (o.count = -1))
          })(r.buffer, e, s),
          (r.version = e.version))
    }
  }
}
class sn extends xe {
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i })
    const s = t / 2,
      r = e / 2,
      o = Math.floor(n),
      a = Math.floor(i),
      l = o + 1,
      h = a + 1,
      c = t / o,
      u = e / a,
      d = [],
      p = [],
      g = [],
      f = []
    for (let t = 0; t < h; t++) {
      const e = t * u - r
      for (let n = 0; n < l; n++) {
        const i = n * c - s
        p.push(i, -e, 0), g.push(0, 0, 1), f.push(n / o), f.push(1 - t / a)
      }
    }
    for (let t = 0; t < a; t++)
      for (let e = 0; e < o; e++) {
        const n = e + l * t,
          i = e + l * (t + 1),
          s = e + 1 + l * (t + 1),
          r = e + 1 + l * t
        d.push(n, i, r), d.push(i, s, r)
      }
    this.setIndex(d),
      this.setAttribute('position', new ce(p, 3)),
      this.setAttribute('normal', new ce(g, 3)),
      this.setAttribute('uv', new ce(f, 2))
  }
  static fromJSON(t) {
    return new sn(t.width, t.height, t.widthSegments, t.heightSegments)
  }
}
const rn = {
    alphamap_fragment:
      '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
    alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
    alphatest_fragment:
      '#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif',
    alphatest_pars_fragment: '#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif',
    aomap_fragment:
      '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif',
    aomap_pars_fragment:
      '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
    begin_vertex: 'vec3 transformed = vec3( position );',
    beginnormal_vertex:
      'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
    bsdfs:
      'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif',
    bumpmap_pars_fragment:
      '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
    clipping_planes_fragment:
      '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
    clipping_planes_pars_fragment:
      '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
    clipping_planes_pars_vertex:
      '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
    clipping_planes_vertex:
      '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
    color_fragment:
      '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
    color_pars_fragment:
      '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
    color_pars_vertex:
      '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
    color_vertex:
      '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
    common:
      '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
    cube_uv_reflection_fragment:
      '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
    defaultnormal_vertex:
      'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
    displacementmap_pars_vertex:
      '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
    displacementmap_vertex:
      '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
    emissivemap_fragment:
      '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
    emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
    encodings_fragment: 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
    encodings_pars_fragment:
      'vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}',
    envmap_fragment:
      '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
    envmap_common_pars_fragment:
      '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
    envmap_pars_fragment:
      '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
    envmap_pars_vertex:
      '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
    envmap_physical_pars_fragment:
      '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif',
    envmap_vertex:
      '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
    fog_vertex: '#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif',
    fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif',
    fog_fragment:
      '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
    fog_pars_fragment:
      '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
    gradientmap_pars_fragment:
      '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
    lightmap_fragment:
      '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif',
    lightmap_pars_fragment:
      '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
    lights_lambert_vertex:
      'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
    lights_pars_begin:
      'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif',
    lights_toon_fragment: 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
    lights_toon_pars_fragment:
      'varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
    lights_phong_fragment:
      'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
    lights_phong_pars_fragment:
      'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
    lights_physical_fragment:
      'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif',
    lights_physical_pars_fragment:
      'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
    lights_fragment_begin:
      '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
    lights_fragment_maps:
      '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif',
    lights_fragment_end:
      '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
    logdepthbuf_fragment:
      '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
    logdepthbuf_pars_fragment:
      '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
    logdepthbuf_pars_vertex:
      '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
    logdepthbuf_vertex:
      '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
    map_fragment:
      '#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif',
    map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
    map_particle_fragment:
      '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
    map_particle_pars_fragment:
      '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
    metalnessmap_fragment:
      'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
    metalnessmap_pars_fragment:
      '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
    morphcolor_vertex:
      '#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]\n\t\t#endif\n\t}\n#endif',
    morphnormal_vertex:
      '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif',
    morphtarget_pars_vertex:
      '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tfloat texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif',
    morphtarget_vertex:
      '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif',
    normal_fragment_begin:
      'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
    normal_fragment_maps:
      '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
    normal_pars_fragment:
      '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
    normal_pars_vertex:
      '#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif',
    normal_vertex:
      '#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif',
    normalmap_pars_fragment:
      '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
    clearcoat_normal_fragment_begin:
      '#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
    clearcoat_normal_fragment_maps:
      '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
    clearcoat_pars_fragment:
      '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
    output_fragment:
      '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
    packing:
      'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
    premultiplied_alpha_fragment:
      '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
    project_vertex:
      'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
    dithering_fragment:
      '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
    dithering_pars_fragment:
      '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
    roughnessmap_fragment:
      'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
    roughnessmap_pars_fragment:
      '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
    shadowmap_pars_fragment:
      '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
    shadowmap_pars_vertex:
      '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
    shadowmap_vertex:
      '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
    shadowmask_pars_fragment:
      'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
    skinbase_vertex:
      '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
    skinning_pars_vertex:
      '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
    skinning_vertex:
      '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
    skinnormal_vertex:
      '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
    specularmap_fragment:
      'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
    specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
    tonemapping_fragment:
      '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
    tonemapping_pars_fragment:
      '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
    transmission_fragment:
      '#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif',
    transmission_pars_fragment:
      '#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif',
    uv_pars_fragment:
      '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
    uv_pars_vertex:
      '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
    uv_vertex: '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
    uv2_pars_fragment:
      '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
    uv2_pars_vertex:
      '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
    uv2_vertex:
      '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
    worldpos_vertex:
      '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
    background_vert:
      'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
    background_frag:
      'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
    cube_vert:
      'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
    cube_frag:
      '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
    depth_vert:
      '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
    depth_frag:
      '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
    distanceRGBA_vert:
      '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
    distanceRGBA_frag:
      '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
    equirect_vert:
      'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
    equirect_frag:
      'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
    linedashed_vert:
      'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
    linedashed_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
    meshbasic_vert:
      '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
    meshbasic_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshlambert_vert:
      '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshlambert_frag:
      'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshmatcap_vert:
      '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
    meshmatcap_frag:
      '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshnormal_vert:
      '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
    meshnormal_frag:
      '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}',
    meshphong_vert:
      '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshphong_frag:
      '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshphysical_vert:
      '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}',
    meshphysical_frag:
      '#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    meshtoon_vert:
      '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    meshtoon_frag:
      '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
    points_vert:
      'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
    points_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
    shadow_vert:
      '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
    shadow_frag:
      'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
    sprite_vert:
      'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
    sprite_frag:
      'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}'
  },
  on = {
    common: {
      diffuse: { value: new L(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new w() },
      uv2Transform: { value: new w() },
      alphaMap: { value: null },
      alphaTest: { value: 0 }
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 }
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: { normalMap: { value: null }, normalScale: { value: new _(1, 1) } },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new L(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: { direction: {}, color: {} } },
      directionalLightShadows: {
        value: [],
        properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} }
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
      rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new L(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new w() }
    },
    sprite: {
      diffuse: { value: new L(16777215) },
      opacity: { value: 1 },
      center: { value: new _(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new w() }
    }
  },
  an = {
    basic: {
      uniforms: Ue([on.common, on.specularmap, on.envmap, on.aomap, on.lightmap, on.fog]),
      vertexShader: rn.meshbasic_vert,
      fragmentShader: rn.meshbasic_frag
    },
    lambert: {
      uniforms: Ue([
        on.common,
        on.specularmap,
        on.envmap,
        on.aomap,
        on.lightmap,
        on.emissivemap,
        on.fog,
        on.lights,
        { emissive: { value: new L(0) } }
      ]),
      vertexShader: rn.meshlambert_vert,
      fragmentShader: rn.meshlambert_frag
    },
    phong: {
      uniforms: Ue([
        on.common,
        on.specularmap,
        on.envmap,
        on.aomap,
        on.lightmap,
        on.emissivemap,
        on.bumpmap,
        on.normalmap,
        on.displacementmap,
        on.fog,
        on.lights,
        {
          emissive: { value: new L(0) },
          specular: { value: new L(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: rn.meshphong_vert,
      fragmentShader: rn.meshphong_frag
    },
    standard: {
      uniforms: Ue([
        on.common,
        on.envmap,
        on.aomap,
        on.lightmap,
        on.emissivemap,
        on.bumpmap,
        on.normalmap,
        on.displacementmap,
        on.roughnessmap,
        on.metalnessmap,
        on.fog,
        on.lights,
        {
          emissive: { value: new L(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: rn.meshphysical_vert,
      fragmentShader: rn.meshphysical_frag
    },
    toon: {
      uniforms: Ue([
        on.common,
        on.aomap,
        on.lightmap,
        on.emissivemap,
        on.bumpmap,
        on.normalmap,
        on.displacementmap,
        on.gradientmap,
        on.fog,
        on.lights,
        { emissive: { value: new L(0) } }
      ]),
      vertexShader: rn.meshtoon_vert,
      fragmentShader: rn.meshtoon_frag
    },
    matcap: {
      uniforms: Ue([
        on.common,
        on.bumpmap,
        on.normalmap,
        on.displacementmap,
        on.fog,
        { matcap: { value: null } }
      ]),
      vertexShader: rn.meshmatcap_vert,
      fragmentShader: rn.meshmatcap_frag
    },
    points: {
      uniforms: Ue([on.points, on.fog]),
      vertexShader: rn.points_vert,
      fragmentShader: rn.points_frag
    },
    dashed: {
      uniforms: Ue([
        on.common,
        on.fog,
        { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
      ]),
      vertexShader: rn.linedashed_vert,
      fragmentShader: rn.linedashed_frag
    },
    depth: {
      uniforms: Ue([on.common, on.displacementmap]),
      vertexShader: rn.depth_vert,
      fragmentShader: rn.depth_frag
    },
    normal: {
      uniforms: Ue([
        on.common,
        on.bumpmap,
        on.normalmap,
        on.displacementmap,
        { opacity: { value: 1 } }
      ]),
      vertexShader: rn.meshnormal_vert,
      fragmentShader: rn.meshnormal_frag
    },
    sprite: {
      uniforms: Ue([on.sprite, on.fog]),
      vertexShader: rn.sprite_vert,
      fragmentShader: rn.sprite_frag
    },
    background: {
      uniforms: { uvTransform: { value: new w() }, t2D: { value: null } },
      vertexShader: rn.background_vert,
      fragmentShader: rn.background_frag
    },
    cube: {
      uniforms: Ue([on.envmap, { opacity: { value: 1 } }]),
      vertexShader: rn.cube_vert,
      fragmentShader: rn.cube_frag
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: rn.equirect_vert,
      fragmentShader: rn.equirect_frag
    },
    distanceRGBA: {
      uniforms: Ue([
        on.common,
        on.displacementmap,
        {
          referencePosition: { value: new H() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: rn.distanceRGBA_vert,
      fragmentShader: rn.distanceRGBA_frag
    },
    shadow: {
      uniforms: Ue([on.lights, on.fog, { color: { value: new L(0) }, opacity: { value: 1 } }]),
      vertexShader: rn.shadow_vert,
      fragmentShader: rn.shadow_frag
    }
  }
function ln(t, e, n, i, s, r) {
  const o = new L(0)
  let a,
    l,
    h = !0 === s ? 0 : 1,
    c = null,
    u = 0,
    d = null
  function p(t, e) {
    n.buffers.color.setClear(t.r, t.g, t.b, e, r)
  }
  return {
    getClearColor: function () {
      return o
    },
    setClearColor: function (t, e = 1) {
      o.set(t), (h = e), p(o, h)
    },
    getClearAlpha: function () {
      return h
    },
    setClearAlpha: function (t) {
      ;(h = t), p(o, h)
    },
    render: function (n, s) {
      let r = !1,
        g = !0 === s.isScene ? s.background : null
      g && g.isTexture && (g = e.get(g))
      const f = t.xr,
        m = f.getSession && f.getSession()
      m && 'additive' === m.environmentBlendMode && (g = null),
        null === g ? p(o, h) : g && g.isColor && (p(g, 1), (r = !0)),
        (t.autoClear || r) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        g && (g.isCubeTexture || 306 === g.mapping)
          ? (void 0 === l &&
              ((l = new Fe(
                new ze(1, 1, 1),
                new He({
                  name: 'BackgroundCubeMaterial',
                  uniforms: Be(an.cube.uniforms),
                  vertexShader: an.cube.vertexShader,
                  fragmentShader: an.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
                })
              )),
              l.geometry.deleteAttribute('normal'),
              l.geometry.deleteAttribute('uv'),
              (l.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld)
              }),
              Object.defineProperty(l.material, 'envMap', {
                get: function () {
                  return this.uniforms.envMap.value
                }
              }),
              i.update(l)),
            (l.material.uniforms.envMap.value = g),
            (l.material.uniforms.flipEnvMap.value =
              g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1),
            (c === g && u === g.version && d === t.toneMapping) ||
              ((l.material.needsUpdate = !0), (c = g), (u = g.version), (d = t.toneMapping)),
            n.unshift(l, l.geometry, l.material, 0, 0, null))
          : g &&
            g.isTexture &&
            (void 0 === a &&
              ((a = new Fe(
                new sn(2, 2),
                new He({
                  name: 'BackgroundMaterial',
                  uniforms: Be(an.background.uniforms),
                  vertexShader: an.background.vertexShader,
                  fragmentShader: an.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1
                })
              )),
              a.geometry.deleteAttribute('normal'),
              Object.defineProperty(a.material, 'map', {
                get: function () {
                  return this.uniforms.t2D.value
                }
              }),
              i.update(a)),
            (a.material.uniforms.t2D.value = g),
            !0 === g.matrixAutoUpdate && g.updateMatrix(),
            a.material.uniforms.uvTransform.value.copy(g.matrix),
            (c === g && u === g.version && d === t.toneMapping) ||
              ((a.material.needsUpdate = !0), (c = g), (u = g.version), (d = t.toneMapping)),
            n.unshift(a, a.geometry, a.material, 0, 0, null))
    }
  }
}
function hn(t, e, n, i) {
  const s = t.getParameter(34921),
    r = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
    o = i.isWebGL2 || null !== r,
    a = {},
    l = d(null)
  let h = l
  function c(e) {
    return i.isWebGL2 ? t.bindVertexArray(e) : r.bindVertexArrayOES(e)
  }
  function u(e) {
    return i.isWebGL2 ? t.deleteVertexArray(e) : r.deleteVertexArrayOES(e)
  }
  function d(t) {
    const e = [],
      n = [],
      i = []
    for (let t = 0; t < s; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: i,
      object: t,
      attributes: {},
      index: null
    }
  }
  function p() {
    const t = h.newAttributes
    for (let e = 0, n = t.length; e < n; e++) t[e] = 0
  }
  function g(t) {
    f(t, 0)
  }
  function f(n, s) {
    const r = h.newAttributes,
      o = h.enabledAttributes,
      a = h.attributeDivisors
    if (((r[n] = 1), 0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)), a[n] !== s)) {
      ;(i.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
        i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
      ](n, s),
        (a[n] = s)
    }
  }
  function m() {
    const e = h.newAttributes,
      n = h.enabledAttributes
    for (let i = 0, s = n.length; i < s; i++)
      n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0))
  }
  function y(e, n, s, r, o, a) {
    !0 !== i.isWebGL2 || (5124 !== s && 5125 !== s)
      ? t.vertexAttribPointer(e, n, s, r, o, a)
      : t.vertexAttribIPointer(e, n, s, o, a)
  }
  function x() {
    v(), h !== l && ((h = l), c(h.object))
  }
  function v() {
    ;(l.geometry = null), (l.program = null), (l.wireframe = !1)
  }
  return {
    setup: function (s, l, u, x, v) {
      let _ = !1
      if (o) {
        const e = (function (e, n, s) {
          const o = !0 === s.wireframe
          let l = a[e.id]
          void 0 === l && ((l = {}), (a[e.id] = l))
          let h = l[n.id]
          void 0 === h && ((h = {}), (l[n.id] = h))
          let c = h[o]
          void 0 === c &&
            ((c = d(i.isWebGL2 ? t.createVertexArray() : r.createVertexArrayOES())), (h[o] = c))
          return c
        })(x, u, l)
        h !== e && ((h = e), c(h.object)),
          (_ = (function (t, e) {
            const n = h.attributes,
              i = t.attributes
            let s = 0
            for (const t in i) {
              const e = n[t],
                r = i[t]
              if (void 0 === e) return !0
              if (e.attribute !== r) return !0
              if (e.data !== r.data) return !0
              s++
            }
            return h.attributesNum !== s || h.index !== e
          })(x, v)),
          _ &&
            (function (t, e) {
              const n = {},
                i = t.attributes
              let s = 0
              for (const t in i) {
                const e = i[t],
                  r = {}
                ;(r.attribute = e), e.data && (r.data = e.data), (n[t] = r), s++
              }
              ;(h.attributes = n), (h.attributesNum = s), (h.index = e)
            })(x, v)
      } else {
        const t = !0 === l.wireframe
        ;(h.geometry === x.id && h.program === u.id && h.wireframe === t) ||
          ((h.geometry = x.id), (h.program = u.id), (h.wireframe = t), (_ = !0))
      }
      !0 === s.isInstancedMesh && (_ = !0),
        null !== v && n.update(v, 34963),
        _ &&
          (!(function (s, r, o, a) {
            if (
              !1 === i.isWebGL2 &&
              (s.isInstancedMesh || a.isInstancedBufferGeometry) &&
              null === e.get('ANGLE_instanced_arrays')
            )
              return
            p()
            const l = a.attributes,
              h = o.getAttributes(),
              c = r.defaultAttributeValues
            for (const e in h) {
              const i = h[e]
              if (i.location >= 0) {
                let r = l[e]
                if (
                  (void 0 === r &&
                    ('instanceMatrix' === e && s.instanceMatrix && (r = s.instanceMatrix),
                    'instanceColor' === e && s.instanceColor && (r = s.instanceColor)),
                  void 0 !== r)
                ) {
                  const e = r.normalized,
                    o = r.itemSize,
                    l = n.get(r)
                  if (void 0 === l) continue
                  const h = l.buffer,
                    c = l.type,
                    u = l.bytesPerElement
                  if (r.isInterleavedBufferAttribute) {
                    const n = r.data,
                      l = n.stride,
                      d = r.offset
                    if (n.isInstancedInterleavedBuffer) {
                      for (let t = 0; t < i.locationSize; t++) f(i.location + t, n.meshPerAttribute)
                      !0 !== s.isInstancedMesh &&
                        void 0 === a._maxInstanceCount &&
                        (a._maxInstanceCount = n.meshPerAttribute * n.count)
                    } else for (let t = 0; t < i.locationSize; t++) g(i.location + t)
                    t.bindBuffer(34962, h)
                    for (let t = 0; t < i.locationSize; t++)
                      y(
                        i.location + t,
                        o / i.locationSize,
                        c,
                        e,
                        l * u,
                        (d + (o / i.locationSize) * t) * u
                      )
                  } else {
                    if (r.isInstancedBufferAttribute) {
                      for (let t = 0; t < i.locationSize; t++) f(i.location + t, r.meshPerAttribute)
                      !0 !== s.isInstancedMesh &&
                        void 0 === a._maxInstanceCount &&
                        (a._maxInstanceCount = r.meshPerAttribute * r.count)
                    } else for (let t = 0; t < i.locationSize; t++) g(i.location + t)
                    t.bindBuffer(34962, h)
                    for (let t = 0; t < i.locationSize; t++)
                      y(
                        i.location + t,
                        o / i.locationSize,
                        c,
                        e,
                        o * u,
                        (o / i.locationSize) * t * u
                      )
                  }
                } else if (void 0 !== c) {
                  const n = c[e]
                  if (void 0 !== n)
                    switch (n.length) {
                      case 2:
                        t.vertexAttrib2fv(i.location, n)
                        break
                      case 3:
                        t.vertexAttrib3fv(i.location, n)
                        break
                      case 4:
                        t.vertexAttrib4fv(i.location, n)
                        break
                      default:
                        t.vertexAttrib1fv(i.location, n)
                    }
                }
              }
            }
            m()
          })(s, l, u, x),
          null !== v && t.bindBuffer(34963, n.get(v).buffer))
    },
    reset: x,
    resetDefaultState: v,
    dispose: function () {
      x()
      for (const t in a) {
        const e = a[t]
        for (const t in e) {
          const n = e[t]
          for (const t in n) u(n[t].object), delete n[t]
          delete e[t]
        }
        delete a[t]
      }
    },
    releaseStatesOfGeometry: function (t) {
      if (void 0 === a[t.id]) return
      const e = a[t.id]
      for (const t in e) {
        const n = e[t]
        for (const t in n) u(n[t].object), delete n[t]
        delete e[t]
      }
      delete a[t.id]
    },
    releaseStatesOfProgram: function (t) {
      for (const e in a) {
        const n = a[e]
        if (void 0 === n[t.id]) continue
        const i = n[t.id]
        for (const t in i) u(i[t].object), delete i[t]
        delete n[t.id]
      }
    },
    initAttributes: p,
    enableAttribute: g,
    disableUnusedAttributes: m
  }
}
function cn(t, e, n, i) {
  const s = i.isWebGL2
  let r
  ;(this.setMode = function (t) {
    r = t
  }),
    (this.render = function (e, i) {
      t.drawArrays(r, e, i), n.update(i, r, 1)
    }),
    (this.renderInstances = function (i, o, a) {
      if (0 === a) return
      let l, h
      if (s) (l = t), (h = 'drawArraysInstanced')
      else if (
        ((l = e.get('ANGLE_instanced_arrays')), (h = 'drawArraysInstancedANGLE'), null === l)
      )
        return void console.error(
          'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
        )
      l[h](r, i, o, a), n.update(o, r, a)
    })
}
function un(t, e, n) {
  let i
  function s(e) {
    if ('highp' === e) {
      if (
        t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        t.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return 'highp'
      e = 'mediump'
    }
    return 'mediump' === e &&
      t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      t.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? 'mediump'
      : 'lowp'
  }
  const r =
    ('undefined' != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) ||
    ('undefined' != typeof WebGL2ComputeRenderingContext &&
      t instanceof WebGL2ComputeRenderingContext)
  let o = void 0 !== n.precision ? n.precision : 'highp'
  const a = s(o)
  a !== o &&
    (console.warn('THREE.WebGLRenderer:', o, 'not supported, using', a, 'instead.'), (o = a))
  const l = r || e.has('WEBGL_draw_buffers'),
    h = !0 === n.logarithmicDepthBuffer,
    c = t.getParameter(34930),
    u = t.getParameter(35660),
    d = t.getParameter(3379),
    p = t.getParameter(34076),
    g = t.getParameter(34921),
    f = t.getParameter(36347),
    m = t.getParameter(36348),
    y = t.getParameter(36349),
    x = u > 0,
    v = r || e.has('OES_texture_float')
  return {
    isWebGL2: r,
    drawBuffers: l,
    getMaxAnisotropy: function () {
      if (void 0 !== i) return i
      if (!0 === e.has('EXT_texture_filter_anisotropic')) {
        const n = e.get('EXT_texture_filter_anisotropic')
        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      } else i = 0
      return i
    },
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: h,
    maxTextures: c,
    maxVertexTextures: u,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: g,
    maxVertexUniforms: f,
    maxVaryings: m,
    maxFragmentUniforms: y,
    vertexTextures: x,
    floatFragmentTextures: v,
    floatVertexTextures: x && v,
    maxSamples: r ? t.getParameter(36183) : 0
  }
}
function dn(t) {
  const e = this
  let n = null,
    i = 0,
    s = !1,
    r = !1
  const o = new Je(),
    a = new w(),
    l = { value: null, needsUpdate: !1 }
  function h() {
    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0)
  }
  function c(t, n, i, s) {
    const r = null !== t ? t.length : 0
    let h = null
    if (0 !== r) {
      if (((h = l.value), !0 !== s || null === h)) {
        const e = i + 4 * r,
          s = n.matrixWorldInverse
        a.getNormalMatrix(s), (null === h || h.length < e) && (h = new Float32Array(e))
        for (let e = 0, n = i; e !== r; ++e, n += 4)
          o.copy(t[e]).applyMatrix4(s, a), o.normal.toArray(h, n), (h[n + 3] = o.constant)
      }
      ;(l.value = h), (l.needsUpdate = !0)
    }
    return (e.numPlanes = r), (e.numIntersection = 0), h
  }
  ;(this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (t, e, r) {
      const o = 0 !== t.length || e || 0 !== i || s
      return (s = e), (n = c(t, r, 0)), (i = t.length), o
    }),
    (this.beginShadows = function () {
      ;(r = !0), c(null)
    }),
    (this.endShadows = function () {
      ;(r = !1), h()
    }),
    (this.setState = function (e, o, a) {
      const u = e.clippingPlanes,
        d = e.clipIntersection,
        p = e.clipShadows,
        g = t.get(e)
      if (!s || null === u || 0 === u.length || (r && !p)) r ? c(null) : h()
      else {
        const t = r ? 0 : i,
          e = 4 * t
        let s = g.clippingState || null
        ;(l.value = s), (s = c(u, o, e, a))
        for (let t = 0; t !== e; ++t) s[t] = n[t]
        ;(g.clippingState = s),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += t)
      }
    })
}
function pn(t) {
  let e = new WeakMap()
  function n(t, e) {
    return 303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t
  }
  function i(t) {
    const n = t.target
    n.removeEventListener('dispose', i)
    const s = e.get(n)
    void 0 !== s && (e.delete(n), s.dispose())
  }
  return {
    get: function (s) {
      if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
        const r = s.mapping
        if (303 === r || 304 === r) {
          if (e.has(s)) {
            return n(e.get(s).texture, s.mapping)
          }
          {
            const r = s.image
            if (r && r.height > 0) {
              const o = new qe(r.height / 2)
              return (
                o.fromEquirectangularTexture(t, s),
                e.set(s, o),
                s.addEventListener('dispose', i),
                n(o.texture, s.mapping)
              )
            }
            return null
          }
        }
      }
      return s
    },
    dispose: function () {
      e = new WeakMap()
    }
  }
}
an.physical = {
  uniforms: Ue([
    an.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new _(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new L(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new _() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new L(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new L(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: rn.meshphysical_vert,
  fragmentShader: rn.meshphysical_frag
}
class gn extends ke {
  constructor(t = -1, e = 1, n = 1, i = -1, s = 0.1, r = 2e3) {
    super(),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = r),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = null === t.view ? null : Object.assign({}, t.view)),
      this
    )
  }
  setViewOffset(t, e, n, i, s, r) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2
    let s = n - t,
      r = n + t,
      o = i + e,
      a = i - e
    if (null !== this.view && this.view.enabled) {
      const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
        e = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(s += t * this.view.offsetX),
        (r = s + t * this.view.width),
        (o -= e * this.view.offsetY),
        (a = o - e * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(s, r, o, a, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      null !== this.view && (e.object.view = Object.assign({}, this.view)),
      e
    )
  }
}
gn.prototype.isOrthographicCamera = !0
const fn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  mn = new gn(),
  yn = new L()
let xn = null
const vn = (1 + Math.sqrt(5)) / 2,
  _n = 1 / vn,
  wn = [
    new H(1, 1, 1),
    new H(-1, 1, 1),
    new H(1, 1, -1),
    new H(-1, 1, -1),
    new H(0, vn, _n),
    new H(0, vn, -_n),
    new H(_n, 0, vn),
    new H(-_n, 0, vn),
    new H(vn, _n, 0),
    new H(-vn, _n, 0)
  ]
class En {
  constructor(t) {
    ;(this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ;(xn = this._renderer.getRenderTarget()), this._setSize(256)
    const s = this._allocateTargets()
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(t, n, i, s),
      e > 0 && this._blur(s, 0, 0, e),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    )
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e)
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e)
  }
  compileCubemapShader() {
    null === this._cubemapMaterial &&
      ((this._cubemapMaterial = An()), this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial &&
      ((this._equirectMaterial = Sn()), this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    this._dispose(),
      null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
      null !== this._equirectMaterial && this._equirectMaterial.dispose()
  }
  _setSize(t) {
    ;(this._lodMax = Math.floor(Math.log2(t))), (this._cubeSize = Math.pow(2, this._lodMax))
  }
  _dispose() {
    this._blurMaterial.dispose(),
      null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose()
    for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(xn), (t.scissorTest = !1), Mn(t, 0, 0, t.width, t.height)
  }
  _fromTexture(t, e) {
    301 === t.mapping || 302 === t.mapping
      ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width)
      : this._setSize(t.image.width / 4),
      (xn = this._renderer.getRenderTarget())
    const n = e || this._allocateTargets()
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112),
      e = 4 * this._cubeSize - 32,
      n = {
        magFilter: 1006,
        minFilter: 1006,
        generateMipmaps: !1,
        type: 1016,
        format: 1023,
        encoding: 3e3,
        depthBuffer: !1
      },
      i = bn(t, e, n)
    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t) {
      null !== this._pingPongRenderTarget && this._dispose(),
        (this._pingPongRenderTarget = bn(t, e, n))
      const { _lodMax: i } = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas
      } = (function (t) {
        const e = [],
          n = [],
          i = []
        let s = t
        const r = t - 4 + 1 + fn.length
        for (let o = 0; o < r; o++) {
          const r = Math.pow(2, s)
          n.push(r)
          let a = 1 / r
          o > t - 4 ? (a = fn[o - t + 4 - 1]) : 0 === o && (a = 0), i.push(a)
          const l = 1 / (r - 1),
            h = -l / 2,
            c = 1 + l / 2,
            u = [h, h, c, h, c, c, h, h, c, c, h, c],
            d = 6,
            p = 6,
            g = 3,
            f = 2,
            m = 1,
            y = new Float32Array(g * p * d),
            x = new Float32Array(f * p * d),
            v = new Float32Array(m * p * d)
          for (let t = 0; t < d; t++) {
            const e = ((t % 3) * 2) / 3 - 1,
              n = t > 2 ? 0 : -1,
              i = [
                e,
                n,
                0,
                e + 2 / 3,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n,
                0,
                e + 2 / 3,
                n + 1,
                0,
                e,
                n + 1,
                0
              ]
            y.set(i, g * p * t), x.set(u, f * p * t)
            const s = [t, t, t, t, t, t]
            v.set(s, m * p * t)
          }
          const _ = new xe()
          _.setAttribute('position', new ae(y, g)),
            _.setAttribute('uv', new ae(x, f)),
            _.setAttribute('faceIndex', new ae(v, m)),
            e.push(_),
            s > 4 && s--
        }
        return { lodPlanes: e, sizeLods: n, sigmas: i }
      })(i)),
        (this._blurMaterial = (function (t, e, n) {
          const i = new Float32Array(20),
            s = new H(0, 1, 0)
          return new He({
            name: 'SphericalGaussianBlur',
            defines: {
              n: 20,
              CUBEUV_TEXEL_WIDTH: 1 / e,
              CUBEUV_TEXEL_HEIGHT: 1 / n,
              CUBEUV_MAX_MIP: `${t}.0`
            },
            uniforms: {
              envMap: { value: null },
              samples: { value: 1 },
              weights: { value: i },
              latitudinal: { value: !1 },
              dTheta: { value: 0 },
              mipInt: { value: 0 },
              poleAxis: { value: s }
            },
            vertexShader: Tn(),
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
          })
        })(i, t, e))
    }
    return i
  }
  _compileMaterial(t) {
    const e = new Fe(this._lodPlanes[0], t)
    this._renderer.compile(e, mn)
  }
  _sceneToCubeUV(t, e, n, i) {
    const s = new We(90, 1, e, n),
      r = [1, -1, 1, 1, 1, 1],
      o = [1, 1, 1, -1, -1, -1],
      a = this._renderer,
      l = a.autoClear,
      h = a.toneMapping
    a.getClearColor(yn), (a.toneMapping = 0), (a.autoClear = !1)
    const c = new se({ name: 'PMREM.Background', side: 1, depthWrite: !1, depthTest: !1 }),
      u = new Fe(new ze(), c)
    let d = !1
    const p = t.background
    p
      ? p.isColor && (c.color.copy(p), (t.background = null), (d = !0))
      : (c.color.copy(yn), (d = !0))
    for (let e = 0; e < 6; e++) {
      const n = e % 3
      0 === n
        ? (s.up.set(0, r[e], 0), s.lookAt(o[e], 0, 0))
        : 1 === n
          ? (s.up.set(0, 0, r[e]), s.lookAt(0, o[e], 0))
          : (s.up.set(0, r[e], 0), s.lookAt(0, 0, o[e]))
      const l = this._cubeSize
      Mn(i, n * l, e > 2 ? l : 0, l, l), a.setRenderTarget(i), d && a.render(u, s), a.render(t, s)
    }
    u.geometry.dispose(),
      u.material.dispose(),
      (a.toneMapping = h),
      (a.autoClear = l),
      (t.background = p)
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer,
      i = 301 === t.mapping || 302 === t.mapping
    i
      ? (null === this._cubemapMaterial && (this._cubemapMaterial = An()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1))
      : null === this._equirectMaterial && (this._equirectMaterial = Sn())
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      r = new Fe(this._lodPlanes[0], s)
    s.uniforms.envMap.value = t
    const o = this._cubeSize
    Mn(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(r, mn)
  }
  _applyPMREM(t) {
    const e = this._renderer,
      n = e.autoClear
    e.autoClear = !1
    for (let e = 1; e < this._lodPlanes.length; e++) {
      const n = Math.sqrt(
          this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]
        ),
        i = wn[(e - 1) % wn.length]
      this._blur(t, e - 1, e, n, i)
    }
    e.autoClear = n
  }
  _blur(t, e, n, i, s) {
    const r = this._pingPongRenderTarget
    this._halfBlur(t, r, e, n, i, 'latitudinal', s),
      this._halfBlur(r, t, n, n, i, 'longitudinal', s)
  }
  _halfBlur(t, e, n, i, s, r, o) {
    const a = this._renderer,
      l = this._blurMaterial
    'latitudinal' !== r &&
      'longitudinal' !== r &&
      console.error('blur direction must be either latitudinal or longitudinal!')
    const h = new Fe(this._lodPlanes[i], l),
      c = l.uniforms,
      u = this._sizeLods[n] - 1,
      d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
      p = s / d,
      g = isFinite(s) ? 1 + Math.floor(3 * p) : 20
    g > 20 &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to 20`
      )
    const f = []
    let m = 0
    for (let t = 0; t < 20; ++t) {
      const e = t / p,
        n = Math.exp((-e * e) / 2)
      f.push(n), 0 === t ? (m += n) : t < g && (m += 2 * n)
    }
    for (let t = 0; t < f.length; t++) f[t] = f[t] / m
    ;(c.envMap.value = t.texture),
      (c.samples.value = g),
      (c.weights.value = f),
      (c.latitudinal.value = 'latitudinal' === r),
      o && (c.poleAxis.value = o)
    const { _lodMax: y } = this
    ;(c.dTheta.value = d), (c.mipInt.value = y - n)
    const x = this._sizeLods[i]
    Mn(e, 3 * x * (i > y - 4 ? i - y + 4 : 0), 4 * (this._cubeSize - x), 3 * x, 2 * x),
      a.setRenderTarget(e),
      a.render(h, mn)
  }
}
function bn(t, e, n) {
  const i = new z(t, e, n)
  return (i.texture.mapping = 306), (i.texture.name = 'PMREM.cubeUv'), (i.scissorTest = !0), i
}
function Mn(t, e, n, i, s) {
  t.viewport.set(e, n, i, s), t.scissor.set(e, n, i, s)
}
function Sn() {
  return new He({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: Tn(),
    fragmentShader:
      '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t',
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  })
}
function An() {
  return new He({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Tn(),
    fragmentShader:
      '\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t',
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  })
}
function Tn() {
  return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t'
}
function In(t) {
  let e = new WeakMap(),
    n = null
  function i(t) {
    const n = t.target
    n.removeEventListener('dispose', i)
    const s = e.get(n)
    void 0 !== s && (e.delete(n), s.dispose())
  }
  return {
    get: function (s) {
      if (s && s.isTexture) {
        const r = s.mapping,
          o = 303 === r || 304 === r,
          a = 301 === r || 302 === r
        if (o || a) {
          if (s.isRenderTargetTexture && !0 === s.needsPMREMUpdate) {
            s.needsPMREMUpdate = !1
            let i = e.get(s)
            return (
              null === n && (n = new En(t)),
              (i = o ? n.fromEquirectangular(s, i) : n.fromCubemap(s, i)),
              e.set(s, i),
              i.texture
            )
          }
          if (e.has(s)) return e.get(s).texture
          {
            const r = s.image
            if (
              (o && r && r.height > 0) ||
              (a &&
                r &&
                (function (t) {
                  let e = 0
                  const n = 6
                  for (let i = 0; i < n; i++) void 0 !== t[i] && e++
                  return e === n
                })(r))
            ) {
              null === n && (n = new En(t))
              const r = o ? n.fromEquirectangular(s) : n.fromCubemap(s)
              return e.set(s, r), s.addEventListener('dispose', i), r.texture
            }
            return null
          }
        }
      }
      return s
    },
    dispose: function () {
      ;(e = new WeakMap()), null !== n && (n.dispose(), (n = null))
    }
  }
}
function Rn(t) {
  const e = {}
  function n(n) {
    if (void 0 !== e[n]) return e[n]
    let i
    switch (n) {
      case 'WEBGL_depth_texture':
        i =
          t.getExtension('WEBGL_depth_texture') ||
          t.getExtension('MOZ_WEBGL_depth_texture') ||
          t.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        i =
          t.getExtension('EXT_texture_filter_anisotropic') ||
          t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        i =
          t.getExtension('WEBGL_compressed_texture_s3tc') ||
          t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        i =
          t.getExtension('WEBGL_compressed_texture_pvrtc') ||
          t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        i = t.getExtension(n)
    }
    return (e[n] = i), i
  }
  return {
    has: function (t) {
      return null !== n(t)
    },
    init: function (t) {
      t.isWebGL2
        ? n('EXT_color_buffer_float')
        : (n('WEBGL_depth_texture'),
          n('OES_texture_float'),
          n('OES_texture_half_float'),
          n('OES_texture_half_float_linear'),
          n('OES_standard_derivatives'),
          n('OES_element_index_uint'),
          n('OES_vertex_array_object'),
          n('ANGLE_instanced_arrays')),
        n('OES_texture_float_linear'),
        n('EXT_color_buffer_half_float'),
        n('WEBGL_multisampled_render_to_texture')
    },
    get: function (t) {
      const e = n(t)
      return (
        null === e && console.warn('THREE.WebGLRenderer: ' + t + ' extension not supported.'), e
      )
    }
  }
}
function Ln(t, e, n, i) {
  const s = {},
    r = new WeakMap()
  function o(t) {
    const a = t.target
    null !== a.index && e.remove(a.index)
    for (const t in a.attributes) e.remove(a.attributes[t])
    a.removeEventListener('dispose', o), delete s[a.id]
    const l = r.get(a)
    l && (e.remove(l), r.delete(a)),
      i.releaseStatesOfGeometry(a),
      !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
      n.memory.geometries--
  }
  function a(t) {
    const n = [],
      i = t.index,
      s = t.attributes.position
    let o = 0
    if (null !== i) {
      const t = i.array
      o = i.version
      for (let e = 0, i = t.length; e < i; e += 3) {
        const i = t[e + 0],
          s = t[e + 1],
          r = t[e + 2]
        n.push(i, s, s, r, r, i)
      }
    } else {
      const t = s.array
      o = s.version
      for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
        const t = e + 0,
          i = e + 1,
          s = e + 2
        n.push(t, i, i, s, s, t)
      }
    }
    const a = new (E(n) ? he : le)(n, 1)
    a.version = o
    const l = r.get(t)
    l && e.remove(l), r.set(t, a)
  }
  return {
    get: function (t, e) {
      return (
        !0 === s[e.id] || (e.addEventListener('dispose', o), (s[e.id] = !0), n.memory.geometries++),
        e
      )
    },
    update: function (t) {
      const n = t.attributes
      for (const t in n) e.update(n[t], 34962)
      const i = t.morphAttributes
      for (const t in i) {
        const n = i[t]
        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
      }
    },
    getWireframeAttribute: function (t) {
      const e = r.get(t)
      if (e) {
        const n = t.index
        null !== n && e.version < n.version && a(t)
      } else a(t)
      return r.get(t)
    }
  }
}
function Cn(t, e, n, i) {
  const s = i.isWebGL2
  let r, o, a
  ;(this.setMode = function (t) {
    r = t
  }),
    (this.setIndex = function (t) {
      ;(o = t.type), (a = t.bytesPerElement)
    }),
    (this.render = function (e, i) {
      t.drawElements(r, i, o, e * a), n.update(i, r, 1)
    }),
    (this.renderInstances = function (i, l, h) {
      if (0 === h) return
      let c, u
      if (s) (c = t), (u = 'drawElementsInstanced')
      else if (
        ((c = e.get('ANGLE_instanced_arrays')), (u = 'drawElementsInstancedANGLE'), null === c)
      )
        return void console.error(
          'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
        )
      c[u](r, l, o, i * a, h), n.update(l, r, h)
    })
}
function Nn(t) {
  const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  return {
    memory: { geometries: 0, textures: 0 },
    render: e,
    programs: null,
    autoReset: !0,
    reset: function () {
      e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0)
    },
    update: function (t, n, i) {
      switch ((e.calls++, n)) {
        case 4:
          e.triangles += i * (t / 3)
          break
        case 1:
          e.lines += i * (t / 2)
          break
        case 3:
          e.lines += i * (t - 1)
          break
        case 2:
          e.lines += i * t
          break
        case 0:
          e.points += i * t
          break
        default:
          console.error('THREE.WebGLInfo: Unknown draw mode:', n)
      }
    }
  }
}
function Pn(t, e) {
  return t[0] - e[0]
}
function Dn(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1])
}
function On(t, e) {
  let n = 1
  const i = e.isInterleavedBufferAttribute ? e.data.array : e.array
  i instanceof Int8Array
    ? (n = 127)
    : i instanceof Int16Array
      ? (n = 32767)
      : i instanceof Int32Array
        ? (n = 2147483647)
        : console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', i),
    t.divideScalar(n)
}
function Fn(t, e, n) {
  const i = {},
    s = new Float32Array(8),
    r = new WeakMap(),
    o = new G(),
    a = []
  for (let t = 0; t < 8; t++) a[t] = [t, 0]
  return {
    update: function (l, h, c, u) {
      const d = l.morphTargetInfluences
      if (!0 === e.isWebGL2) {
        const i = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
          s = void 0 !== i ? i.length : 0
        let a = r.get(h)
        if (void 0 === a || a.count !== s) {
          void 0 !== a && a.texture.dispose()
          const t = void 0 !== h.morphAttributes.position,
            n = void 0 !== h.morphAttributes.normal,
            i = void 0 !== h.morphAttributes.color,
            l = h.morphAttributes.position || [],
            c = h.morphAttributes.normal || [],
            u = h.morphAttributes.color || []
          let d = 0
          !0 === t && (d = 1), !0 === n && (d = 2), !0 === i && (d = 3)
          let p = h.attributes.position.count * d,
            g = 1
          p > e.maxTextureSize && ((g = Math.ceil(p / e.maxTextureSize)), (p = e.maxTextureSize))
          const f = new Float32Array(p * g * 4 * s),
            m = new B(f, p, g, s)
          ;(m.format = 1023), (m.type = 1015), (m.needsUpdate = !0)
          const y = 4 * d
          for (let e = 0; e < s; e++) {
            const s = l[e],
              r = c[e],
              a = u[e],
              h = p * g * 4 * e
            for (let e = 0; e < s.count; e++) {
              const l = e * y
              !0 === t &&
                (o.fromBufferAttribute(s, e),
                !0 === s.normalized && On(o, s),
                (f[h + l + 0] = o.x),
                (f[h + l + 1] = o.y),
                (f[h + l + 2] = o.z),
                (f[h + l + 3] = 0)),
                !0 === n &&
                  (o.fromBufferAttribute(r, e),
                  !0 === r.normalized && On(o, r),
                  (f[h + l + 4] = o.x),
                  (f[h + l + 5] = o.y),
                  (f[h + l + 6] = o.z),
                  (f[h + l + 7] = 0)),
                !0 === i &&
                  (o.fromBufferAttribute(a, e),
                  !0 === a.normalized && On(o, r),
                  (f[h + l + 8] = o.x),
                  (f[h + l + 9] = o.y),
                  (f[h + l + 10] = o.z),
                  (f[h + l + 11] = 4 === a.itemSize ? o.w : 1))
            }
          }
          ;(a = { count: s, texture: m, size: new _(p, g) }),
            r.set(h, a),
            h.addEventListener('dispose', function t() {
              m.dispose(), r.delete(h), h.removeEventListener('dispose', t)
            })
        }
        let l = 0
        for (let t = 0; t < d.length; t++) l += d[t]
        const c = h.morphTargetsRelative ? 1 : 1 - l
        u.getUniforms().setValue(t, 'morphTargetBaseInfluence', c),
          u.getUniforms().setValue(t, 'morphTargetInfluences', d),
          u.getUniforms().setValue(t, 'morphTargetsTexture', a.texture, n),
          u.getUniforms().setValue(t, 'morphTargetsTextureSize', a.size)
      } else {
        const e = void 0 === d ? 0 : d.length
        let n = i[h.id]
        if (void 0 === n || n.length !== e) {
          n = []
          for (let t = 0; t < e; t++) n[t] = [t, 0]
          i[h.id] = n
        }
        for (let t = 0; t < e; t++) {
          const e = n[t]
          ;(e[0] = t), (e[1] = d[t])
        }
        n.sort(Dn)
        for (let t = 0; t < 8; t++)
          t < e && n[t][1]
            ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
            : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0))
        a.sort(Pn)
        const r = h.morphAttributes.position,
          o = h.morphAttributes.normal
        let l = 0
        for (let t = 0; t < 8; t++) {
          const e = a[t],
            n = e[0],
            i = e[1]
          n !== Number.MAX_SAFE_INTEGER && i
            ? (r &&
                h.getAttribute('morphTarget' + t) !== r[n] &&
                h.setAttribute('morphTarget' + t, r[n]),
              o &&
                h.getAttribute('morphNormal' + t) !== o[n] &&
                h.setAttribute('morphNormal' + t, o[n]),
              (s[t] = i),
              (l += i))
            : (r &&
                !0 === h.hasAttribute('morphTarget' + t) &&
                h.deleteAttribute('morphTarget' + t),
              o && !0 === h.hasAttribute('morphNormal' + t) && h.deleteAttribute('morphNormal' + t),
              (s[t] = 0))
        }
        const c = h.morphTargetsRelative ? 1 : 1 - l
        u.getUniforms().setValue(t, 'morphTargetBaseInfluence', c),
          u.getUniforms().setValue(t, 'morphTargetInfluences', s)
      }
    }
  }
}
function Gn(t, e, n, i) {
  let s = new WeakMap()
  function r(t) {
    const e = t.target
    e.removeEventListener('dispose', r),
      n.remove(e.instanceMatrix),
      null !== e.instanceColor && n.remove(e.instanceColor)
  }
  return {
    update: function (t) {
      const o = i.render.frame,
        a = t.geometry,
        l = e.get(t, a)
      return (
        s.get(l) !== o && (e.update(l), s.set(l, o)),
        t.isInstancedMesh &&
          (!1 === t.hasEventListener('dispose', r) && t.addEventListener('dispose', r),
          n.update(t.instanceMatrix, 34962),
          null !== t.instanceColor && n.update(t.instanceColor, 34962)),
        l
      )
    },
    dispose: function () {
      s = new WeakMap()
    }
  }
}
const zn = new F(),
  Bn = new B(),
  Un = new U(),
  Vn = new je(),
  Hn = [],
  kn = [],
  Wn = new Float32Array(16),
  Yn = new Float32Array(9),
  jn = new Float32Array(4)
function qn(t, e, n) {
  const i = t[0]
  if (i <= 0 || i > 0) return t
  const s = e * n
  let r = Hn[s]
  if ((void 0 === r && ((r = new Float32Array(s)), (Hn[s] = r)), 0 !== e)) {
    i.toArray(r, 0)
    for (let i = 1, s = 0; i !== e; ++i) (s += n), t[i].toArray(r, s)
  }
  return r
}
function Zn(t, e) {
  if (t.length !== e.length) return !1
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1
  return !0
}
function Xn(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
}
function Kn(t, e) {
  let n = kn[e]
  void 0 === n && ((n = new Int32Array(e)), (kn[e] = n))
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit()
  return n
}
function Jn(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e))
}
function Qn(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y))
  else {
    if (Zn(n, e)) return
    t.uniform2fv(this.addr, e), Xn(n, e)
  }
}
function $n(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
      (t.uniform3f(this.addr, e.x, e.y, e.z), (n[0] = e.x), (n[1] = e.y), (n[2] = e.z))
  else if (void 0 !== e.r)
    (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
      (t.uniform3f(this.addr, e.r, e.g, e.b), (n[0] = e.r), (n[1] = e.g), (n[2] = e.b))
  else {
    if (Zn(n, e)) return
    t.uniform3fv(this.addr, e), Xn(n, e)
  }
}
function ti(t, e) {
  const n = this.cache
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w))
  else {
    if (Zn(n, e)) return
    t.uniform4fv(this.addr, e), Xn(n, e)
  }
}
function ei(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (Zn(n, e)) return
    t.uniformMatrix2fv(this.addr, !1, e), Xn(n, e)
  } else {
    if (Zn(n, i)) return
    jn.set(i), t.uniformMatrix2fv(this.addr, !1, jn), Xn(n, i)
  }
}
function ni(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (Zn(n, e)) return
    t.uniformMatrix3fv(this.addr, !1, e), Xn(n, e)
  } else {
    if (Zn(n, i)) return
    Yn.set(i), t.uniformMatrix3fv(this.addr, !1, Yn), Xn(n, i)
  }
}
function ii(t, e) {
  const n = this.cache,
    i = e.elements
  if (void 0 === i) {
    if (Zn(n, e)) return
    t.uniformMatrix4fv(this.addr, !1, e), Xn(n, e)
  } else {
    if (Zn(n, i)) return
    Wn.set(i), t.uniformMatrix4fv(this.addr, !1, Wn), Xn(n, i)
  }
}
function si(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e))
}
function ri(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform2iv(this.addr, e), Xn(n, e))
}
function oi(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform3iv(this.addr, e), Xn(n, e))
}
function ai(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform4iv(this.addr, e), Xn(n, e))
}
function li(t, e) {
  const n = this.cache
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e))
}
function hi(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform2uiv(this.addr, e), Xn(n, e))
}
function ci(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform3uiv(this.addr, e), Xn(n, e))
}
function ui(t, e) {
  const n = this.cache
  Zn(n, e) || (t.uniform4uiv(this.addr, e), Xn(n, e))
}
function di(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)), n.setTexture2D(e || zn, s)
}
function pi(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)), n.setTexture3D(e || Un, s)
}
function gi(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)), n.setTextureCube(e || Vn, s)
}
function fi(t, e, n) {
  const i = this.cache,
    s = n.allocateTextureUnit()
  i[0] !== s && (t.uniform1i(this.addr, s), (i[0] = s)), n.setTexture2DArray(e || Bn, s)
}
function mi(t, e) {
  t.uniform1fv(this.addr, e)
}
function yi(t, e) {
  const n = qn(e, this.size, 2)
  t.uniform2fv(this.addr, n)
}
function xi(t, e) {
  const n = qn(e, this.size, 3)
  t.uniform3fv(this.addr, n)
}
function vi(t, e) {
  const n = qn(e, this.size, 4)
  t.uniform4fv(this.addr, n)
}
function _i(t, e) {
  const n = qn(e, this.size, 4)
  t.uniformMatrix2fv(this.addr, !1, n)
}
function wi(t, e) {
  const n = qn(e, this.size, 9)
  t.uniformMatrix3fv(this.addr, !1, n)
}
function Ei(t, e) {
  const n = qn(e, this.size, 16)
  t.uniformMatrix4fv(this.addr, !1, n)
}
function bi(t, e) {
  t.uniform1iv(this.addr, e)
}
function Mi(t, e) {
  t.uniform2iv(this.addr, e)
}
function Si(t, e) {
  t.uniform3iv(this.addr, e)
}
function Ai(t, e) {
  t.uniform4iv(this.addr, e)
}
function Ti(t, e) {
  t.uniform1uiv(this.addr, e)
}
function Ii(t, e) {
  t.uniform2uiv(this.addr, e)
}
function Ri(t, e) {
  t.uniform3uiv(this.addr, e)
}
function Li(t, e) {
  t.uniform4uiv(this.addr, e)
}
function Ci(t, e, n) {
  const i = e.length,
    s = Kn(n, i)
  t.uniform1iv(this.addr, s)
  for (let t = 0; t !== i; ++t) n.setTexture2D(e[t] || zn, s[t])
}
function Ni(t, e, n) {
  const i = e.length,
    s = Kn(n, i)
  t.uniform1iv(this.addr, s)
  for (let t = 0; t !== i; ++t) n.setTexture3D(e[t] || Un, s[t])
}
function Pi(t, e, n) {
  const i = e.length,
    s = Kn(n, i)
  t.uniform1iv(this.addr, s)
  for (let t = 0; t !== i; ++t) n.setTextureCube(e[t] || Vn, s[t])
}
function Di(t, e, n) {
  const i = e.length,
    s = Kn(n, i)
  t.uniform1iv(this.addr, s)
  for (let t = 0; t !== i; ++t) n.setTexture2DArray(e[t] || Bn, s[t])
}
function Oi(t, e, n) {
  ;(this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.setValue = (function (t) {
      switch (t) {
        case 5126:
          return Jn
        case 35664:
          return Qn
        case 35665:
          return $n
        case 35666:
          return ti
        case 35674:
          return ei
        case 35675:
          return ni
        case 35676:
          return ii
        case 5124:
        case 35670:
          return si
        case 35667:
        case 35671:
          return ri
        case 35668:
        case 35672:
          return oi
        case 35669:
        case 35673:
          return ai
        case 5125:
          return li
        case 36294:
          return hi
        case 36295:
          return ci
        case 36296:
          return ui
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return di
        case 35679:
        case 36299:
        case 36307:
          return pi
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return gi
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return fi
      }
    })(e.type))
}
function Fi(t, e, n) {
  ;(this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.size = e.size),
    (this.setValue = (function (t) {
      switch (t) {
        case 5126:
          return mi
        case 35664:
          return yi
        case 35665:
          return xi
        case 35666:
          return vi
        case 35674:
          return _i
        case 35675:
          return wi
        case 35676:
          return Ei
        case 5124:
        case 35670:
          return bi
        case 35667:
        case 35671:
          return Mi
        case 35668:
        case 35672:
          return Si
        case 35669:
        case 35673:
          return Ai
        case 5125:
          return Ti
        case 36294:
          return Ii
        case 36295:
          return Ri
        case 36296:
          return Li
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Ci
        case 35679:
        case 36299:
        case 36307:
          return Ni
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Pi
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Di
      }
    })(e.type))
}
function Gi(t) {
  ;(this.id = t), (this.seq = []), (this.map = {})
}
;(Fi.prototype.updateCache = function (t) {
  const e = this.cache
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
    Xn(e, t)
}),
  (Gi.prototype.setValue = function (t, e, n) {
    const i = this.seq
    for (let s = 0, r = i.length; s !== r; ++s) {
      const r = i[s]
      r.setValue(t, e[r.id], n)
    }
  })
const zi = /(\w+)(\])?(\[|\.)?/g
function Bi(t, e) {
  t.seq.push(e), (t.map[e.id] = e)
}
function Ui(t, e, n) {
  const i = t.name,
    s = i.length
  for (zi.lastIndex = 0; ; ) {
    const r = zi.exec(i),
      o = zi.lastIndex
    let a = r[1]
    const l = ']' === r[2],
      h = r[3]
    if ((l && (a |= 0), void 0 === h || ('[' === h && o + 2 === s))) {
      Bi(n, void 0 === h ? new Oi(a, t, e) : new Fi(a, t, e))
      break
    }
    {
      let t = n.map[a]
      void 0 === t && ((t = new Gi(a)), Bi(n, t)), (n = t)
    }
  }
}
function Vi(t, e) {
  ;(this.seq = []), (this.map = {})
  const n = t.getProgramParameter(e, 35718)
  for (let i = 0; i < n; ++i) {
    const n = t.getActiveUniform(e, i)
    Ui(n, t.getUniformLocation(e, n.name), this)
  }
}
function Hi(t, e, n) {
  const i = t.createShader(e)
  return t.shaderSource(i, n), t.compileShader(i), i
}
;(Vi.prototype.setValue = function (t, e, n, i) {
  const s = this.map[e]
  void 0 !== s && s.setValue(t, n, i)
}),
  (Vi.prototype.setOptional = function (t, e, n) {
    const i = e[n]
    void 0 !== i && this.setValue(t, n, i)
  }),
  (Vi.upload = function (t, e, n, i) {
    for (let s = 0, r = e.length; s !== r; ++s) {
      const r = e[s],
        o = n[r.id]
      !1 !== o.needsUpdate && r.setValue(t, o.value, i)
    }
  }),
  (Vi.seqWithValue = function (t, e) {
    const n = []
    for (let i = 0, s = t.length; i !== s; ++i) {
      const s = t[i]
      s.id in e && n.push(s)
    }
    return n
  })
let ki = 0
function Wi(t, e, n) {
  const i = t.getShaderParameter(e, 35713),
    s = t.getShaderInfoLog(e).trim()
  return i && '' === s
    ? ''
    : n.toUpperCase() +
        '\n\n' +
        s +
        '\n\n' +
        (function (t) {
          const e = t.split('\n')
          for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t]
          return e.join('\n')
        })(t.getShaderSource(e))
}
function Yi(t, e) {
  const n = (function (t) {
    switch (t) {
      case 3e3:
        return ['Linear', '( value )']
      case 3001:
        return ['sRGB', '( value )']
      default:
        return console.warn('THREE.WebGLProgram: Unsupported encoding:', t), ['Linear', '( value )']
    }
  })(e)
  return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }'
}
function ji(t, e) {
  let n
  switch (e) {
    case 1:
      n = 'Linear'
      break
    case 2:
      n = 'Reinhard'
      break
    case 3:
      n = 'OptimizedCineon'
      break
    case 4:
      n = 'ACESFilmic'
      break
    case 5:
      n = 'Custom'
      break
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (n = 'Linear')
  }
  return 'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
}
function qi(t) {
  return '' !== t
}
function Zi(t, e) {
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Xi(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Ki = /^[ \t]*#include +<([\w\d./]+)>/gm
function Ji(t) {
  return t.replace(Ki, Qi)
}
function Qi(t, e) {
  const n = rn[e]
  if (void 0 === n) throw new Error('Can not resolve #include <' + e + '>')
  return Ji(n)
}
const $i =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  ts =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function es(t) {
  return t.replace(ts, is).replace($i, ns)
}
function ns(t, e, n, i) {
  return (
    console.warn(
      'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.'
    ),
    is(t, e, n, i)
  )
}
function is(t, e, n, i) {
  let s = ''
  for (let t = parseInt(e); t < parseInt(n); t++)
    s += i.replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]').replace(/UNROLLED_LOOP_INDEX/g, t)
  return s
}
function ss(t) {
  let e = 'precision ' + t.precision + ' float;\nprecision ' + t.precision + ' int;'
  return (
    'highp' === t.precision
      ? (e += '\n#define HIGH_PRECISION')
      : 'mediump' === t.precision
        ? (e += '\n#define MEDIUM_PRECISION')
        : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
    e
  )
}
function rs(t, e, n, i) {
  const s = t.getContext(),
    r = n.defines
  let o = n.vertexShader,
    a = n.fragmentShader
  const l = (function (t) {
      let e = 'SHADOWMAP_TYPE_BASIC'
      return (
        1 === t.shadowMapType
          ? (e = 'SHADOWMAP_TYPE_PCF')
          : 2 === t.shadowMapType
            ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
            : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
        e
      )
    })(n),
    h = (function (t) {
      let e = 'ENVMAP_TYPE_CUBE'
      if (t.envMap)
        switch (t.envMapMode) {
          case 301:
          case 302:
            e = 'ENVMAP_TYPE_CUBE'
            break
          case 306:
          case 307:
            e = 'ENVMAP_TYPE_CUBE_UV'
        }
      return e
    })(n),
    c = (function (t) {
      let e = 'ENVMAP_MODE_REFLECTION'
      if (t.envMap)
        switch (t.envMapMode) {
          case 302:
          case 307:
            e = 'ENVMAP_MODE_REFRACTION'
        }
      return e
    })(n),
    u = (function (t) {
      let e = 'ENVMAP_BLENDING_NONE'
      if (t.envMap)
        switch (t.combine) {
          case 0:
            e = 'ENVMAP_BLENDING_MULTIPLY'
            break
          case 1:
            e = 'ENVMAP_BLENDING_MIX'
            break
          case 2:
            e = 'ENVMAP_BLENDING_ADD'
        }
      return e
    })(n),
    d = (function (t) {
      const e = t.envMapCubeUVHeight
      if (null === e) return null
      const n = Math.log2(e / 32 + 1) + 3,
        i = 1 / e
      return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: i, maxMip: n }
    })(n),
    p = n.isWebGL2
      ? ''
      : (function (t) {
          return [
            t.extensionDerivatives ||
            t.envMapCubeUVHeight ||
            t.bumpMap ||
            t.tangentSpaceNormalMap ||
            t.clearcoatNormalMap ||
            t.flatShading ||
            'physical' === t.shaderID
              ? '#extension GL_OES_standard_derivatives : enable'
              : '',
            (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth
              ? '#extension GL_EXT_frag_depth : enable'
              : '',
            t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
              ? '#extension GL_EXT_draw_buffers : require'
              : '',
            (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
            t.rendererExtensionShaderTextureLod
              ? '#extension GL_EXT_shader_texture_lod : enable'
              : ''
          ]
            .filter(qi)
            .join('\n')
        })(n),
    g = (function (t) {
      const e = []
      for (const n in t) {
        const i = t[n]
        !1 !== i && e.push('#define ' + n + ' ' + i)
      }
      return e.join('\n')
    })(r),
    f = s.createProgram()
  let m,
    y,
    x = n.glslVersion ? '#version ' + n.glslVersion + '\n' : ''
  n.isRawShaderMaterial
    ? ((m = [g].filter(qi).join('\n')),
      m.length > 0 && (m += '\n'),
      (y = [p, g].filter(qi).join('\n')),
      y.length > 0 && (y += '\n'))
    : ((m = [
        ss(n),
        '#define SHADER_NAME ' + n.shaderName,
        g,
        n.instancing ? '#define USE_INSTANCING' : '',
        n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
        '#define MAX_BONES ' + n.maxBones,
        n.useFog && n.fog ? '#define USE_FOG' : '',
        n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
        n.map ? '#define USE_MAP' : '',
        n.envMap ? '#define USE_ENVMAP' : '',
        n.envMap ? '#define ' + c : '',
        n.lightMap ? '#define USE_LIGHTMAP' : '',
        n.aoMap ? '#define USE_AOMAP' : '',
        n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        n.bumpMap ? '#define USE_BUMPMAP' : '',
        n.normalMap ? '#define USE_NORMALMAP' : '',
        n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
        n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
        n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        n.displacementMap && n.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
        n.specularMap ? '#define USE_SPECULARMAP' : '',
        n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
        n.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
        n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        n.metalnessMap ? '#define USE_METALNESSMAP' : '',
        n.alphaMap ? '#define USE_ALPHAMAP' : '',
        n.transmission ? '#define USE_TRANSMISSION' : '',
        n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        n.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
        n.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
        n.vertexTangents ? '#define USE_TANGENT' : '',
        n.vertexColors ? '#define USE_COLOR' : '',
        n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        n.vertexUvs ? '#define USE_UV' : '',
        n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
        n.flatShading ? '#define FLAT_SHADED' : '',
        n.skinning ? '#define USE_SKINNING' : '',
        n.useVertexTexture ? '#define BONE_TEXTURE' : '',
        n.morphTargets ? '#define USE_MORPHTARGETS' : '',
        n.morphNormals && !1 === n.flatShading ? '#define USE_MORPHNORMALS' : '',
        n.morphColors && n.isWebGL2 ? '#define USE_MORPHCOLORS' : '',
        n.morphTargetsCount > 0 && n.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '',
        n.morphTargetsCount > 0 && n.isWebGL2
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + n.morphTextureStride
          : '',
        n.morphTargetsCount > 0 && n.isWebGL2
          ? '#define MORPHTARGETS_COUNT ' + n.morphTargetsCount
          : '',
        n.doubleSided ? '#define DOUBLE_SIDED' : '',
        n.flipSided ? '#define FLIP_SIDED' : '',
        n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        n.shadowMapEnabled ? '#define ' + l : '',
        n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? '#define USE_LOGDEPTHBUF_EXT'
          : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '\tattribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '\tattribute vec3 instanceColor;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_TANGENT',
        '\tattribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '\tattribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '\tattribute vec3 color;',
        '#endif',
        '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
        '\tattribute vec3 morphTarget0;',
        '\tattribute vec3 morphTarget1;',
        '\tattribute vec3 morphTarget2;',
        '\tattribute vec3 morphTarget3;',
        '\t#ifdef USE_MORPHNORMALS',
        '\t\tattribute vec3 morphNormal0;',
        '\t\tattribute vec3 morphNormal1;',
        '\t\tattribute vec3 morphNormal2;',
        '\t\tattribute vec3 morphNormal3;',
        '\t#else',
        '\t\tattribute vec3 morphTarget4;',
        '\t\tattribute vec3 morphTarget5;',
        '\t\tattribute vec3 morphTarget6;',
        '\t\tattribute vec3 morphTarget7;',
        '\t#endif',
        '#endif',
        '#ifdef USE_SKINNING',
        '\tattribute vec4 skinIndex;',
        '\tattribute vec4 skinWeight;',
        '#endif',
        '\n'
      ]
        .filter(qi)
        .join('\n')),
      (y = [
        p,
        ss(n),
        '#define SHADER_NAME ' + n.shaderName,
        g,
        n.useFog && n.fog ? '#define USE_FOG' : '',
        n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
        n.map ? '#define USE_MAP' : '',
        n.matcap ? '#define USE_MATCAP' : '',
        n.envMap ? '#define USE_ENVMAP' : '',
        n.envMap ? '#define ' + h : '',
        n.envMap ? '#define ' + c : '',
        n.envMap ? '#define ' + u : '',
        d ? '#define CUBEUV_TEXEL_WIDTH ' + d.texelWidth : '',
        d ? '#define CUBEUV_TEXEL_HEIGHT ' + d.texelHeight : '',
        d ? '#define CUBEUV_MAX_MIP ' + d.maxMip + '.0' : '',
        n.lightMap ? '#define USE_LIGHTMAP' : '',
        n.aoMap ? '#define USE_AOMAP' : '',
        n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        n.bumpMap ? '#define USE_BUMPMAP' : '',
        n.normalMap ? '#define USE_NORMALMAP' : '',
        n.normalMap && n.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
        n.normalMap && n.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
        n.clearcoat ? '#define USE_CLEARCOAT' : '',
        n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        n.specularMap ? '#define USE_SPECULARMAP' : '',
        n.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
        n.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
        n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        n.metalnessMap ? '#define USE_METALNESSMAP' : '',
        n.alphaMap ? '#define USE_ALPHAMAP' : '',
        n.alphaTest ? '#define USE_ALPHATEST' : '',
        n.sheen ? '#define USE_SHEEN' : '',
        n.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
        n.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
        n.transmission ? '#define USE_TRANSMISSION' : '',
        n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        n.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        n.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        n.vertexTangents ? '#define USE_TANGENT' : '',
        n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
        n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        n.vertexUvs ? '#define USE_UV' : '',
        n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
        n.gradientMap ? '#define USE_GRADIENTMAP' : '',
        n.flatShading ? '#define FLAT_SHADED' : '',
        n.doubleSided ? '#define DOUBLE_SIDED' : '',
        n.flipSided ? '#define FLIP_SIDED' : '',
        n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        n.shadowMapEnabled ? '#define ' + l : '',
        n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        n.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
        n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? '#define USE_LOGDEPTHBUF_EXT'
          : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
        0 !== n.toneMapping ? rn.tonemapping_pars_fragment : '',
        0 !== n.toneMapping ? ji('toneMapping', n.toneMapping) : '',
        n.dithering ? '#define DITHERING' : '',
        n.opaque ? '#define OPAQUE' : '',
        rn.encodings_pars_fragment,
        Yi('linearToOutputTexel', n.outputEncoding),
        n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
        '\n'
      ]
        .filter(qi)
        .join('\n'))),
    (o = Ji(o)),
    (o = Zi(o, n)),
    (o = Xi(o, n)),
    (a = Ji(a)),
    (a = Zi(a, n)),
    (a = Xi(a, n)),
    (o = es(o)),
    (a = es(a)),
    n.isWebGL2 &&
      !0 !== n.isRawShaderMaterial &&
      ((x = '#version 300 es\n'),
      (m =
        [
          'precision mediump sampler2DArray;',
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture'
        ].join('\n') +
        '\n' +
        m),
      (y =
        [
          '#define varying in',
          '300 es' === n.glslVersion ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
          '300 es' === n.glslVersion ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad'
        ].join('\n') +
        '\n' +
        y))
  const v = x + y + a,
    _ = Hi(s, 35633, x + m + o),
    w = Hi(s, 35632, v)
  if (
    (s.attachShader(f, _),
    s.attachShader(f, w),
    void 0 !== n.index0AttributeName
      ? s.bindAttribLocation(f, 0, n.index0AttributeName)
      : !0 === n.morphTargets && s.bindAttribLocation(f, 0, 'position'),
    s.linkProgram(f),
    t.debug.checkShaderErrors)
  ) {
    const t = s.getProgramInfoLog(f).trim(),
      e = s.getShaderInfoLog(_).trim(),
      n = s.getShaderInfoLog(w).trim()
    let i = !0,
      r = !0
    if (!1 === s.getProgramParameter(f, 35714)) {
      i = !1
      const e = Wi(s, _, 'vertex'),
        n = Wi(s, w, 'fragment')
      console.error(
        'THREE.WebGLProgram: Shader Error ' +
          s.getError() +
          ' - VALIDATE_STATUS ' +
          s.getProgramParameter(f, 35715) +
          '\n\nProgram Info Log: ' +
          t +
          '\n' +
          e +
          '\n' +
          n
      )
    } else
      '' !== t
        ? console.warn('THREE.WebGLProgram: Program Info Log:', t)
        : ('' !== e && '' !== n) || (r = !1)
    r &&
      (this.diagnostics = {
        runnable: i,
        programLog: t,
        vertexShader: { log: e, prefix: m },
        fragmentShader: { log: n, prefix: y }
      })
  }
  let E, b
  return (
    s.deleteShader(_),
    s.deleteShader(w),
    (this.getUniforms = function () {
      return void 0 === E && (E = new Vi(s, f)), E
    }),
    (this.getAttributes = function () {
      return (
        void 0 === b &&
          (b = (function (t, e) {
            const n = {},
              i = t.getProgramParameter(e, 35721)
            for (let s = 0; s < i; s++) {
              const i = t.getActiveAttrib(e, s),
                r = i.name
              let o = 1
              35674 === i.type && (o = 2),
                35675 === i.type && (o = 3),
                35676 === i.type && (o = 4),
                (n[r] = { type: i.type, location: t.getAttribLocation(e, r), locationSize: o })
            }
            return n
          })(s, f)),
        b
      )
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this), s.deleteProgram(f), (this.program = void 0)
    }),
    (this.name = n.shaderName),
    (this.id = ki++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = f),
    (this.vertexShader = _),
    (this.fragmentShader = w),
    this
  )
}
let os = 0
class as {
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(t) {
    const e = t.vertexShader,
      n = t.fragmentShader,
      i = this._getShaderStage(e),
      s = this._getShaderStage(n),
      r = this._getShaderCacheForMaterial(t)
    return (
      !1 === r.has(i) && (r.add(i), i.usedTimes++),
      !1 === r.has(s) && (r.add(s), s.usedTimes++),
      this
    )
  }
  remove(t) {
    const e = this.materialCache.get(t)
    for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code)
    return this.materialCache.delete(t), this
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache
    return !1 === e.has(t) && e.set(t, new Set()), e.get(t)
  }
  _getShaderStage(t) {
    const e = this.shaderCache
    if (!1 === e.has(t)) {
      const n = new ls(t)
      e.set(t, n)
    }
    return e.get(t)
  }
}
class ls {
  constructor(t) {
    ;(this.id = os++), (this.code = t), (this.usedTimes = 0)
  }
}
function hs(t, e, n, i, s, r, o) {
  const a = new Lt(),
    l = new as(),
    h = [],
    c = s.isWebGL2,
    u = s.logarithmicDepthBuffer,
    d = s.floatVertexTextures,
    p = s.maxVertexUniforms,
    g = s.vertexTextures
  let f = s.precision
  const m = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  }
  return {
    getParameters: function (r, a, h, y, x) {
      const v = y.fog,
        _ = x.geometry,
        w = r.isMeshStandardMaterial ? y.environment : null,
        E = (r.isMeshStandardMaterial ? n : e).get(r.envMap || w),
        b = !E || (306 !== E.mapping && 307 !== E.mapping) ? null : E.image.height,
        M = m[r.type],
        S = x.isSkinnedMesh
          ? (function (t) {
              const e = t.skeleton.bones
              if (d) return 1024
              {
                const t = p,
                  n = Math.floor((t - 20) / 4),
                  i = Math.min(n, e.length)
                return i < e.length
                  ? (console.warn(
                      'THREE.WebGLRenderer: Skeleton has ' +
                        e.length +
                        ' bones. This GPU supports ' +
                        i +
                        '.'
                    ),
                    0)
                  : i
              }
            })(x)
          : 0
      null !== r.precision &&
        ((f = s.getMaxPrecision(r.precision)),
        f !== r.precision &&
          console.warn(
            'THREE.WebGLProgram.getParameters:',
            r.precision,
            'not supported, using',
            f,
            'instead.'
          ))
      const A = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color,
        T = void 0 !== A ? A.length : 0
      let I,
        R,
        L,
        C,
        N = 0
      if (
        (void 0 !== _.morphAttributes.position && (N = 1),
        void 0 !== _.morphAttributes.normal && (N = 2),
        void 0 !== _.morphAttributes.color && (N = 3),
        M)
      ) {
        const t = an[M]
        ;(I = t.vertexShader), (R = t.fragmentShader)
      } else
        (I = r.vertexShader),
          (R = r.fragmentShader),
          l.update(r),
          (L = l.getVertexShaderID(r)),
          (C = l.getFragmentShaderID(r))
      const P = t.getRenderTarget(),
        D = r.alphaTest > 0,
        O = r.clearcoat > 0
      return {
        isWebGL2: c,
        shaderID: M,
        shaderName: r.type,
        vertexShader: I,
        fragmentShader: R,
        defines: r.defines,
        customVertexShaderID: L,
        customFragmentShaderID: C,
        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
        glslVersion: r.glslVersion,
        precision: f,
        instancing: !0 === x.isInstancedMesh,
        instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
        supportsVertexTextures: g,
        outputEncoding:
          null === P ? t.outputEncoding : !0 === P.isXRRenderTarget ? P.texture.encoding : 3e3,
        map: !!r.map,
        matcap: !!r.matcap,
        envMap: !!E,
        envMapMode: E && E.mapping,
        envMapCubeUVHeight: b,
        lightMap: !!r.lightMap,
        aoMap: !!r.aoMap,
        emissiveMap: !!r.emissiveMap,
        bumpMap: !!r.bumpMap,
        normalMap: !!r.normalMap,
        objectSpaceNormalMap: 1 === r.normalMapType,
        tangentSpaceNormalMap: 0 === r.normalMapType,
        decodeVideoTexture: !!r.map && !0 === r.map.isVideoTexture && 3001 === r.map.encoding,
        clearcoat: O,
        clearcoatMap: O && !!r.clearcoatMap,
        clearcoatRoughnessMap: O && !!r.clearcoatRoughnessMap,
        clearcoatNormalMap: O && !!r.clearcoatNormalMap,
        displacementMap: !!r.displacementMap,
        roughnessMap: !!r.roughnessMap,
        metalnessMap: !!r.metalnessMap,
        specularMap: !!r.specularMap,
        specularIntensityMap: !!r.specularIntensityMap,
        specularColorMap: !!r.specularColorMap,
        opaque: !1 === r.transparent && 1 === r.blending,
        alphaMap: !!r.alphaMap,
        alphaTest: D,
        gradientMap: !!r.gradientMap,
        sheen: r.sheen > 0,
        sheenColorMap: !!r.sheenColorMap,
        sheenRoughnessMap: !!r.sheenRoughnessMap,
        transmission: r.transmission > 0,
        transmissionMap: !!r.transmissionMap,
        thicknessMap: !!r.thicknessMap,
        combine: r.combine,
        vertexTangents: !!r.normalMap && !!_.attributes.tangent,
        vertexColors: r.vertexColors,
        vertexAlphas:
          !0 === r.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize,
        vertexUvs: !!(
          r.map ||
          r.bumpMap ||
          r.normalMap ||
          r.specularMap ||
          r.alphaMap ||
          r.emissiveMap ||
          r.roughnessMap ||
          r.metalnessMap ||
          r.clearcoatMap ||
          r.clearcoatRoughnessMap ||
          r.clearcoatNormalMap ||
          r.displacementMap ||
          r.transmissionMap ||
          r.thicknessMap ||
          r.specularIntensityMap ||
          r.specularColorMap ||
          r.sheenColorMap ||
          r.sheenRoughnessMap
        ),
        uvsVertexOnly: !(
          r.map ||
          r.bumpMap ||
          r.normalMap ||
          r.specularMap ||
          r.alphaMap ||
          r.emissiveMap ||
          r.roughnessMap ||
          r.metalnessMap ||
          r.clearcoatNormalMap ||
          r.transmission > 0 ||
          r.transmissionMap ||
          r.thicknessMap ||
          r.specularIntensityMap ||
          r.specularColorMap ||
          r.sheen > 0 ||
          r.sheenColorMap ||
          r.sheenRoughnessMap ||
          !r.displacementMap
        ),
        fog: !!v,
        useFog: r.fog,
        fogExp2: v && v.isFogExp2,
        flatShading: !!r.flatShading,
        sizeAttenuation: r.sizeAttenuation,
        logarithmicDepthBuffer: u,
        skinning: !0 === x.isSkinnedMesh && S > 0,
        maxBones: S,
        useVertexTexture: d,
        morphTargets: void 0 !== _.morphAttributes.position,
        morphNormals: void 0 !== _.morphAttributes.normal,
        morphColors: void 0 !== _.morphAttributes.color,
        morphTargetsCount: T,
        morphTextureStride: N,
        numDirLights: a.directional.length,
        numPointLights: a.point.length,
        numSpotLights: a.spot.length,
        numRectAreaLights: a.rectArea.length,
        numHemiLights: a.hemi.length,
        numDirLightShadows: a.directionalShadowMap.length,
        numPointLightShadows: a.pointShadowMap.length,
        numSpotLightShadows: a.spotShadowMap.length,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: r.dithering,
        shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: r.toneMapped ? t.toneMapping : 0,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: r.premultipliedAlpha,
        doubleSided: 2 === r.side,
        flipSided: 1 === r.side,
        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
        index0AttributeName: r.index0AttributeName,
        extensionDerivatives: r.extensions && r.extensions.derivatives,
        extensionFragDepth: r.extensions && r.extensions.fragDepth,
        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
        extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: c || i.has('EXT_frag_depth'),
        rendererExtensionDrawBuffers: c || i.has('WEBGL_draw_buffers'),
        rendererExtensionShaderTextureLod: c || i.has('EXT_shader_texture_lod'),
        customProgramCacheKey: r.customProgramCacheKey()
      }
    },
    getProgramCacheKey: function (e) {
      const n = []
      if (
        (e.shaderID
          ? n.push(e.shaderID)
          : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)),
        void 0 !== e.defines)
      )
        for (const t in e.defines) n.push(t), n.push(e.defines[t])
      return (
        !1 === e.isRawShaderMaterial &&
          (!(function (t, e) {
            t.push(e.precision),
              t.push(e.outputEncoding),
              t.push(e.envMapMode),
              t.push(e.envMapCubeUVHeight),
              t.push(e.combine),
              t.push(e.vertexUvs),
              t.push(e.fogExp2),
              t.push(e.sizeAttenuation),
              t.push(e.maxBones),
              t.push(e.morphTargetsCount),
              t.push(e.morphAttributeCount),
              t.push(e.numDirLights),
              t.push(e.numPointLights),
              t.push(e.numSpotLights),
              t.push(e.numHemiLights),
              t.push(e.numRectAreaLights),
              t.push(e.numDirLightShadows),
              t.push(e.numPointLightShadows),
              t.push(e.numSpotLightShadows),
              t.push(e.shadowMapType),
              t.push(e.toneMapping),
              t.push(e.numClippingPlanes),
              t.push(e.numClipIntersection)
          })(n, e),
          (function (t, e) {
            a.disableAll(), e.isWebGL2 && a.enable(0)
            e.supportsVertexTextures && a.enable(1)
            e.instancing && a.enable(2)
            e.instancingColor && a.enable(3)
            e.map && a.enable(4)
            e.matcap && a.enable(5)
            e.envMap && a.enable(6)
            e.lightMap && a.enable(7)
            e.aoMap && a.enable(8)
            e.emissiveMap && a.enable(9)
            e.bumpMap && a.enable(10)
            e.normalMap && a.enable(11)
            e.objectSpaceNormalMap && a.enable(12)
            e.tangentSpaceNormalMap && a.enable(13)
            e.clearcoat && a.enable(14)
            e.clearcoatMap && a.enable(15)
            e.clearcoatRoughnessMap && a.enable(16)
            e.clearcoatNormalMap && a.enable(17)
            e.displacementMap && a.enable(18)
            e.specularMap && a.enable(19)
            e.roughnessMap && a.enable(20)
            e.metalnessMap && a.enable(21)
            e.gradientMap && a.enable(22)
            e.alphaMap && a.enable(23)
            e.alphaTest && a.enable(24)
            e.vertexColors && a.enable(25)
            e.vertexAlphas && a.enable(26)
            e.vertexUvs && a.enable(27)
            e.vertexTangents && a.enable(28)
            e.uvsVertexOnly && a.enable(29)
            e.fog && a.enable(30)
            t.push(a.mask), a.disableAll(), e.useFog && a.enable(0)
            e.flatShading && a.enable(1)
            e.logarithmicDepthBuffer && a.enable(2)
            e.skinning && a.enable(3)
            e.useVertexTexture && a.enable(4)
            e.morphTargets && a.enable(5)
            e.morphNormals && a.enable(6)
            e.morphColors && a.enable(7)
            e.premultipliedAlpha && a.enable(8)
            e.shadowMapEnabled && a.enable(9)
            e.physicallyCorrectLights && a.enable(10)
            e.doubleSided && a.enable(11)
            e.flipSided && a.enable(12)
            e.depthPacking && a.enable(13)
            e.dithering && a.enable(14)
            e.specularIntensityMap && a.enable(15)
            e.specularColorMap && a.enable(16)
            e.transmission && a.enable(17)
            e.transmissionMap && a.enable(18)
            e.thicknessMap && a.enable(19)
            e.sheen && a.enable(20)
            e.sheenColorMap && a.enable(21)
            e.sheenRoughnessMap && a.enable(22)
            e.decodeVideoTexture && a.enable(23)
            e.opaque && a.enable(24)
            t.push(a.mask)
          })(n, e),
          n.push(t.outputEncoding)),
        n.push(e.customProgramCacheKey),
        n.join()
      )
    },
    getUniforms: function (t) {
      const e = m[t.type]
      let n
      if (e) {
        const t = an[e]
        n = Ve.clone(t.uniforms)
      } else n = t.uniforms
      return n
    },
    acquireProgram: function (e, n) {
      let i
      for (let t = 0, e = h.length; t < e; t++) {
        const e = h[t]
        if (e.cacheKey === n) {
          ;(i = e), ++i.usedTimes
          break
        }
      }
      return void 0 === i && ((i = new rs(t, n, e, r)), h.push(i)), i
    },
    releaseProgram: function (t) {
      if (0 == --t.usedTimes) {
        const e = h.indexOf(t)
        ;(h[e] = h[h.length - 1]), h.pop(), t.destroy()
      }
    },
    releaseShaderCache: function (t) {
      l.remove(t)
    },
    programs: h,
    dispose: function () {
      l.dispose()
    }
  }
}
function cs() {
  let t = new WeakMap()
  return {
    get: function (e) {
      let n = t.get(e)
      return void 0 === n && ((n = {}), t.set(e, n)), n
    },
    remove: function (e) {
      t.delete(e)
    },
    update: function (e, n, i) {
      t.get(e)[n] = i
    },
    dispose: function () {
      t = new WeakMap()
    }
  }
}
function us(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id
}
function ds(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id
}
function ps() {
  const t = []
  let e = 0
  const n = [],
    i = [],
    s = []
  function r(n, i, s, r, o, a) {
    let l = t[e]
    return (
      void 0 === l
        ? ((l = {
            id: n.id,
            object: n,
            geometry: i,
            material: s,
            groupOrder: r,
            renderOrder: n.renderOrder,
            z: o,
            group: a
          }),
          (t[e] = l))
        : ((l.id = n.id),
          (l.object = n),
          (l.geometry = i),
          (l.material = s),
          (l.groupOrder = r),
          (l.renderOrder = n.renderOrder),
          (l.z = o),
          (l.group = a)),
      e++,
      l
    )
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: s,
    init: function () {
      ;(e = 0), (n.length = 0), (i.length = 0), (s.length = 0)
    },
    push: function (t, e, o, a, l, h) {
      const c = r(t, e, o, a, l, h)
      o.transmission > 0 ? i.push(c) : !0 === o.transparent ? s.push(c) : n.push(c)
    },
    unshift: function (t, e, o, a, l, h) {
      const c = r(t, e, o, a, l, h)
      o.transmission > 0 ? i.unshift(c) : !0 === o.transparent ? s.unshift(c) : n.unshift(c)
    },
    finish: function () {
      for (let n = e, i = t.length; n < i; n++) {
        const e = t[n]
        if (null === e.id) break
        ;(e.id = null),
          (e.object = null),
          (e.geometry = null),
          (e.material = null),
          (e.group = null)
      }
    },
    sort: function (t, e) {
      n.length > 1 && n.sort(t || us),
        i.length > 1 && i.sort(e || ds),
        s.length > 1 && s.sort(e || ds)
    }
  }
}
function gs() {
  let t = new WeakMap()
  return {
    get: function (e, n) {
      let i
      return (
        !1 === t.has(e)
          ? ((i = new ps()), t.set(e, [i]))
          : n >= t.get(e).length
            ? ((i = new ps()), t.get(e).push(i))
            : (i = t.get(e)[n]),
        i
      )
    },
    dispose: function () {
      t = new WeakMap()
    }
  }
}
function fs() {
  const t = {}
  return {
    get: function (e) {
      if (void 0 !== t[e.id]) return t[e.id]
      let n
      switch (e.type) {
        case 'DirectionalLight':
          n = { direction: new H(), color: new L() }
          break
        case 'SpotLight':
          n = {
            position: new H(),
            direction: new H(),
            color: new L(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          }
          break
        case 'PointLight':
          n = { position: new H(), color: new L(), distance: 0, decay: 0 }
          break
        case 'HemisphereLight':
          n = { direction: new H(), skyColor: new L(), groundColor: new L() }
          break
        case 'RectAreaLight':
          n = { color: new L(), position: new H(), halfWidth: new H(), halfHeight: new H() }
      }
      return (t[e.id] = n), n
    }
  }
}
let ms = 0
function ys(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
}
function xs(t, e) {
  const n = new fs(),
    i = (function () {
      const t = {}
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id]
          let n
          switch (e.type) {
            case 'DirectionalLight':
            case 'SpotLight':
              n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _() }
              break
            case 'PointLight':
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new _(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              }
          }
          return (t[e.id] = n), n
        }
      }
    })(),
    s = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }
  for (let t = 0; t < 9; t++) s.probe.push(new H())
  const r = new H(),
    o = new vt(),
    a = new vt()
  return {
    setup: function (r, o) {
      let a = 0,
        l = 0,
        h = 0
      for (let t = 0; t < 9; t++) s.probe[t].set(0, 0, 0)
      let c = 0,
        u = 0,
        d = 0,
        p = 0,
        g = 0,
        f = 0,
        m = 0,
        y = 0
      r.sort(ys)
      const x = !0 !== o ? Math.PI : 1
      for (let t = 0, e = r.length; t < e; t++) {
        const e = r[t],
          o = e.color,
          v = e.intensity,
          _ = e.distance,
          w = e.shadow && e.shadow.map ? e.shadow.map.texture : null
        if (e.isAmbientLight) (a += o.r * v * x), (l += o.g * v * x), (h += o.b * v * x)
        else if (e.isLightProbe)
          for (let t = 0; t < 9; t++) s.probe[t].addScaledVector(e.sh.coefficients[t], v)
        else if (e.isDirectionalLight) {
          const t = n.get(e)
          if ((t.color.copy(e.color).multiplyScalar(e.intensity * x), e.castShadow)) {
            const t = e.shadow,
              n = i.get(e)
            ;(n.shadowBias = t.bias),
              (n.shadowNormalBias = t.normalBias),
              (n.shadowRadius = t.radius),
              (n.shadowMapSize = t.mapSize),
              (s.directionalShadow[c] = n),
              (s.directionalShadowMap[c] = w),
              (s.directionalShadowMatrix[c] = e.shadow.matrix),
              f++
          }
          ;(s.directional[c] = t), c++
        } else if (e.isSpotLight) {
          const t = n.get(e)
          if (
            (t.position.setFromMatrixPosition(e.matrixWorld),
            t.color.copy(o).multiplyScalar(v * x),
            (t.distance = _),
            (t.coneCos = Math.cos(e.angle)),
            (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
            (t.decay = e.decay),
            e.castShadow)
          ) {
            const t = e.shadow,
              n = i.get(e)
            ;(n.shadowBias = t.bias),
              (n.shadowNormalBias = t.normalBias),
              (n.shadowRadius = t.radius),
              (n.shadowMapSize = t.mapSize),
              (s.spotShadow[d] = n),
              (s.spotShadowMap[d] = w),
              (s.spotShadowMatrix[d] = e.shadow.matrix),
              y++
          }
          ;(s.spot[d] = t), d++
        } else if (e.isRectAreaLight) {
          const t = n.get(e)
          t.color.copy(o).multiplyScalar(v),
            t.halfWidth.set(0.5 * e.width, 0, 0),
            t.halfHeight.set(0, 0.5 * e.height, 0),
            (s.rectArea[p] = t),
            p++
        } else if (e.isPointLight) {
          const t = n.get(e)
          if (
            (t.color.copy(e.color).multiplyScalar(e.intensity * x),
            (t.distance = e.distance),
            (t.decay = e.decay),
            e.castShadow)
          ) {
            const t = e.shadow,
              n = i.get(e)
            ;(n.shadowBias = t.bias),
              (n.shadowNormalBias = t.normalBias),
              (n.shadowRadius = t.radius),
              (n.shadowMapSize = t.mapSize),
              (n.shadowCameraNear = t.camera.near),
              (n.shadowCameraFar = t.camera.far),
              (s.pointShadow[u] = n),
              (s.pointShadowMap[u] = w),
              (s.pointShadowMatrix[u] = e.shadow.matrix),
              m++
          }
          ;(s.point[u] = t), u++
        } else if (e.isHemisphereLight) {
          const t = n.get(e)
          t.skyColor.copy(e.color).multiplyScalar(v * x),
            t.groundColor.copy(e.groundColor).multiplyScalar(v * x),
            (s.hemi[g] = t),
            g++
        }
      }
      p > 0 &&
        (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
          ? ((s.rectAreaLTC1 = on.LTC_FLOAT_1), (s.rectAreaLTC2 = on.LTC_FLOAT_2))
          : !0 === t.has('OES_texture_half_float_linear')
            ? ((s.rectAreaLTC1 = on.LTC_HALF_1), (s.rectAreaLTC2 = on.LTC_HALF_2))
            : console.error(
                'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
              )),
        (s.ambient[0] = a),
        (s.ambient[1] = l),
        (s.ambient[2] = h)
      const v = s.hash
      ;(v.directionalLength === c &&
        v.pointLength === u &&
        v.spotLength === d &&
        v.rectAreaLength === p &&
        v.hemiLength === g &&
        v.numDirectionalShadows === f &&
        v.numPointShadows === m &&
        v.numSpotShadows === y) ||
        ((s.directional.length = c),
        (s.spot.length = d),
        (s.rectArea.length = p),
        (s.point.length = u),
        (s.hemi.length = g),
        (s.directionalShadow.length = f),
        (s.directionalShadowMap.length = f),
        (s.pointShadow.length = m),
        (s.pointShadowMap.length = m),
        (s.spotShadow.length = y),
        (s.spotShadowMap.length = y),
        (s.directionalShadowMatrix.length = f),
        (s.pointShadowMatrix.length = m),
        (s.spotShadowMatrix.length = y),
        (v.directionalLength = c),
        (v.pointLength = u),
        (v.spotLength = d),
        (v.rectAreaLength = p),
        (v.hemiLength = g),
        (v.numDirectionalShadows = f),
        (v.numPointShadows = m),
        (v.numSpotShadows = y),
        (s.version = ms++))
    },
    setupView: function (t, e) {
      let n = 0,
        i = 0,
        l = 0,
        h = 0,
        c = 0
      const u = e.matrixWorldInverse
      for (let e = 0, d = t.length; e < d; e++) {
        const d = t[e]
        if (d.isDirectionalLight) {
          const t = s.directional[n]
          t.direction.setFromMatrixPosition(d.matrixWorld),
            r.setFromMatrixPosition(d.target.matrixWorld),
            t.direction.sub(r),
            t.direction.transformDirection(u),
            n++
        } else if (d.isSpotLight) {
          const t = s.spot[l]
          t.position.setFromMatrixPosition(d.matrixWorld),
            t.position.applyMatrix4(u),
            t.direction.setFromMatrixPosition(d.matrixWorld),
            r.setFromMatrixPosition(d.target.matrixWorld),
            t.direction.sub(r),
            t.direction.transformDirection(u),
            l++
        } else if (d.isRectAreaLight) {
          const t = s.rectArea[h]
          t.position.setFromMatrixPosition(d.matrixWorld),
            t.position.applyMatrix4(u),
            a.identity(),
            o.copy(d.matrixWorld),
            o.premultiply(u),
            a.extractRotation(o),
            t.halfWidth.set(0.5 * d.width, 0, 0),
            t.halfHeight.set(0, 0.5 * d.height, 0),
            t.halfWidth.applyMatrix4(a),
            t.halfHeight.applyMatrix4(a),
            h++
        } else if (d.isPointLight) {
          const t = s.point[i]
          t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
        } else if (d.isHemisphereLight) {
          const t = s.hemi[c]
          t.direction.setFromMatrixPosition(d.matrixWorld),
            t.direction.transformDirection(u),
            t.direction.normalize(),
            c++
        }
      }
    },
    state: s
  }
}
function vs(t, e) {
  const n = new xs(t, e),
    i = [],
    s = []
  return {
    init: function () {
      ;(i.length = 0), (s.length = 0)
    },
    state: { lightsArray: i, shadowsArray: s, lights: n },
    setupLights: function (t) {
      n.setup(i, t)
    },
    setupLightsView: function (t) {
      n.setupView(i, t)
    },
    pushLight: function (t) {
      i.push(t)
    },
    pushShadow: function (t) {
      s.push(t)
    }
  }
}
function _s(t, e) {
  let n = new WeakMap()
  return {
    get: function (i, s = 0) {
      let r
      return (
        !1 === n.has(i)
          ? ((r = new vs(t, e)), n.set(i, [r]))
          : s >= n.get(i).length
            ? ((r = new vs(t, e)), n.get(i).push(r))
            : (r = n.get(i)[s]),
        r
      )
    },
    dispose: function () {
      n = new WeakMap()
    }
  }
}
class ws extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = 3200),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    )
  }
}
ws.prototype.isMeshDepthMaterial = !0
class Es extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshDistanceMaterial'),
      (this.referencePosition = new H()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.referencePosition.copy(t.referencePosition),
      (this.nearDistance = t.nearDistance),
      (this.farDistance = t.farDistance),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    )
  }
}
Es.prototype.isMeshDistanceMaterial = !0
function bs(t, e, n) {
  let i = new tn()
  const s = new _(),
    r = new _(),
    o = new G(),
    a = new ws({ depthPacking: 3201 }),
    l = new Es(),
    h = {},
    c = n.maxTextureSize,
    u = { 0: 1, 1: 0, 2: 2 },
    d = new He({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new _() },
        radius: { value: 4 }
      },
      vertexShader: 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
      fragmentShader:
        'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
    }),
    p = d.clone()
  p.defines.HORIZONTAL_PASS = 1
  const g = new xe()
  g.setAttribute('position', new ae(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3))
  const f = new Fe(g, d),
    m = this
  function y(n, i) {
    const s = e.update(f)
    d.defines.VSM_SAMPLES !== n.blurSamples &&
      ((d.defines.VSM_SAMPLES = n.blurSamples),
      (p.defines.VSM_SAMPLES = n.blurSamples),
      (d.needsUpdate = !0),
      (p.needsUpdate = !0)),
      (d.uniforms.shadow_pass.value = n.map.texture),
      (d.uniforms.resolution.value = n.mapSize),
      (d.uniforms.radius.value = n.radius),
      t.setRenderTarget(n.mapPass),
      t.clear(),
      t.renderBufferDirect(i, null, s, d, f, null),
      (p.uniforms.shadow_pass.value = n.mapPass.texture),
      (p.uniforms.resolution.value = n.mapSize),
      (p.uniforms.radius.value = n.radius),
      t.setRenderTarget(n.map),
      t.clear(),
      t.renderBufferDirect(i, null, s, p, f, null)
  }
  function x(e, n, i, s, r, o) {
    let c = null
    const d = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial
    if (
      ((c = void 0 !== d ? d : !0 === i.isPointLight ? l : a),
      (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) ||
        (n.displacementMap && 0 !== n.displacementScale) ||
        (n.alphaMap && n.alphaTest > 0))
    ) {
      const t = c.uuid,
        e = n.uuid
      let i = h[t]
      void 0 === i && ((i = {}), (h[t] = i))
      let s = i[e]
      void 0 === s && ((s = c.clone()), (i[e] = s)), (c = s)
    }
    return (
      (c.visible = n.visible),
      (c.wireframe = n.wireframe),
      (c.side =
        3 === o
          ? null !== n.shadowSide
            ? n.shadowSide
            : n.side
          : null !== n.shadowSide
            ? n.shadowSide
            : u[n.side]),
      (c.alphaMap = n.alphaMap),
      (c.alphaTest = n.alphaTest),
      (c.clipShadows = n.clipShadows),
      (c.clippingPlanes = n.clippingPlanes),
      (c.clipIntersection = n.clipIntersection),
      (c.displacementMap = n.displacementMap),
      (c.displacementScale = n.displacementScale),
      (c.displacementBias = n.displacementBias),
      (c.wireframeLinewidth = n.wireframeLinewidth),
      (c.linewidth = n.linewidth),
      !0 === i.isPointLight &&
        !0 === c.isMeshDistanceMaterial &&
        (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
        (c.nearDistance = s),
        (c.farDistance = r)),
      c
    )
  }
  function v(n, s, r, o, a) {
    if (!1 === n.visible) return
    if (
      n.layers.test(s.layers) &&
      (n.isMesh || n.isLine || n.isPoints) &&
      (n.castShadow || (n.receiveShadow && 3 === a)) &&
      (!n.frustumCulled || i.intersectsObject(n))
    ) {
      n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld)
      const i = e.update(n),
        s = n.material
      if (Array.isArray(s)) {
        const e = i.groups
        for (let l = 0, h = e.length; l < h; l++) {
          const h = e[l],
            c = s[h.materialIndex]
          if (c && c.visible) {
            const e = x(n, c, o, r.near, r.far, a)
            t.renderBufferDirect(r, null, i, e, n, h)
          }
        }
      } else if (s.visible) {
        const e = x(n, s, o, r.near, r.far, a)
        t.renderBufferDirect(r, null, i, e, n, null)
      }
    }
    const l = n.children
    for (let t = 0, e = l.length; t < e; t++) v(l[t], s, r, o, a)
  }
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = 1),
    (this.render = function (e, n, a) {
      if (!1 === m.enabled) return
      if (!1 === m.autoUpdate && !1 === m.needsUpdate) return
      if (0 === e.length) return
      const l = t.getRenderTarget(),
        h = t.getActiveCubeFace(),
        u = t.getActiveMipmapLevel(),
        d = t.state
      d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1)
      for (let l = 0, h = e.length; l < h; l++) {
        const h = e[l],
          u = h.shadow
        if (void 0 === u) {
          console.warn('THREE.WebGLShadowMap:', h, 'has no shadow.')
          continue
        }
        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue
        s.copy(u.mapSize)
        const p = u.getFrameExtents()
        if (
          (s.multiply(p),
          r.copy(u.mapSize),
          (s.x > c || s.y > c) &&
            (s.x > c && ((r.x = Math.floor(c / p.x)), (s.x = r.x * p.x), (u.mapSize.x = r.x)),
            s.y > c && ((r.y = Math.floor(c / p.y)), (s.y = r.y * p.y), (u.mapSize.y = r.y))),
          null === u.map && !u.isPointLightShadow && 3 === this.type)
        ) {
          const t = { minFilter: 1006, magFilter: 1006, format: 1023 }
          ;(u.map = new z(s.x, s.y, t)),
            (u.map.texture.name = h.name + '.shadowMap'),
            (u.mapPass = new z(s.x, s.y, t)),
            u.camera.updateProjectionMatrix()
        }
        if (null === u.map) {
          const t = { minFilter: 1003, magFilter: 1003, format: 1023 }
          ;(u.map = new z(s.x, s.y, t)),
            (u.map.texture.name = h.name + '.shadowMap'),
            u.camera.updateProjectionMatrix()
        }
        t.setRenderTarget(u.map), t.clear()
        const g = u.getViewportCount()
        for (let t = 0; t < g; t++) {
          const e = u.getViewport(t)
          o.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w),
            d.viewport(o),
            u.updateMatrices(h, t),
            (i = u.getFrustum()),
            v(n, a, u.camera, h, this.type)
        }
        u.isPointLightShadow || 3 !== this.type || y(u, a), (u.needsUpdate = !1)
      }
      ;(m.needsUpdate = !1), t.setRenderTarget(l, h, u)
    })
}
function Ms(t, e, n) {
  const i = n.isWebGL2
  const s = new (function () {
      let e = !1
      const n = new G()
      let i = null
      const s = new G(0, 0, 0, 0)
      return {
        setMask: function (n) {
          i === n || e || (t.colorMask(n, n, n, n), (i = n))
        },
        setLocked: function (t) {
          e = t
        },
        setClear: function (e, i, r, o, a) {
          !0 === a && ((e *= o), (i *= o), (r *= o)),
            n.set(e, i, r, o),
            !1 === s.equals(n) && (t.clearColor(e, i, r, o), s.copy(n))
        },
        reset: function () {
          ;(e = !1), (i = null), s.set(-1, 0, 0, 0)
        }
      }
    })(),
    r = new (function () {
      let e = !1,
        n = null,
        i = null,
        s = null
      return {
        setTest: function (t) {
          t ? B(2929) : U(2929)
        },
        setMask: function (i) {
          n === i || e || (t.depthMask(i), (n = i))
        },
        setFunc: function (e) {
          if (i !== e) {
            if (e)
              switch (e) {
                case 0:
                  t.depthFunc(512)
                  break
                case 1:
                  t.depthFunc(519)
                  break
                case 2:
                  t.depthFunc(513)
                  break
                case 3:
                default:
                  t.depthFunc(515)
                  break
                case 4:
                  t.depthFunc(514)
                  break
                case 5:
                  t.depthFunc(518)
                  break
                case 6:
                  t.depthFunc(516)
                  break
                case 7:
                  t.depthFunc(517)
              }
            else t.depthFunc(515)
            i = e
          }
        },
        setLocked: function (t) {
          e = t
        },
        setClear: function (e) {
          s !== e && (t.clearDepth(e), (s = e))
        },
        reset: function () {
          ;(e = !1), (n = null), (i = null), (s = null)
        }
      }
    })(),
    o = new (function () {
      let e = !1,
        n = null,
        i = null,
        s = null,
        r = null,
        o = null,
        a = null,
        l = null,
        h = null
      return {
        setTest: function (t) {
          e || (t ? B(2960) : U(2960))
        },
        setMask: function (i) {
          n === i || e || (t.stencilMask(i), (n = i))
        },
        setFunc: function (e, n, o) {
          ;(i === e && s === n && r === o) || (t.stencilFunc(e, n, o), (i = e), (s = n), (r = o))
        },
        setOp: function (e, n, i) {
          ;(o === e && a === n && l === i) || (t.stencilOp(e, n, i), (o = e), (a = n), (l = i))
        },
        setLocked: function (t) {
          e = t
        },
        setClear: function (e) {
          h !== e && (t.clearStencil(e), (h = e))
        },
        reset: function () {
          ;(e = !1),
            (n = null),
            (i = null),
            (s = null),
            (r = null),
            (o = null),
            (a = null),
            (l = null),
            (h = null)
        }
      }
    })()
  let a = {},
    l = {},
    h = new WeakMap(),
    c = [],
    u = null,
    d = !1,
    p = null,
    g = null,
    f = null,
    m = null,
    y = null,
    x = null,
    v = null,
    _ = !1,
    w = null,
    E = null,
    b = null,
    M = null,
    S = null
  const A = t.getParameter(35661)
  let T = !1,
    I = 0
  const R = t.getParameter(7938)
  ;-1 !== R.indexOf('WebGL')
    ? ((I = parseFloat(/^WebGL (\d)/.exec(R)[1])), (T = I >= 1))
    : -1 !== R.indexOf('OpenGL ES') &&
      ((I = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (T = I >= 2))
  let L = null,
    C = {}
  const N = t.getParameter(3088),
    P = t.getParameter(2978),
    D = new G().fromArray(N),
    O = new G().fromArray(P)
  function F(e, n, i) {
    const s = new Uint8Array(4),
      r = t.createTexture()
    t.bindTexture(e, r), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728)
    for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, s)
    return r
  }
  const z = {}
  function B(e) {
    !0 !== a[e] && (t.enable(e), (a[e] = !0))
  }
  function U(e) {
    !1 !== a[e] && (t.disable(e), (a[e] = !1))
  }
  ;(z[3553] = F(3553, 3553, 1)),
    (z[34067] = F(34067, 34069, 6)),
    s.setClear(0, 0, 0, 1),
    r.setClear(1),
    o.setClear(0),
    B(2929),
    r.setFunc(3),
    W(!1),
    Y(1),
    B(2884),
    k(0)
  const V = { 100: 32774, 101: 32778, 102: 32779 }
  if (i) (V[103] = 32775), (V[104] = 32776)
  else {
    const t = e.get('EXT_blend_minmax')
    null !== t && ((V[103] = t.MIN_EXT), (V[104] = t.MAX_EXT))
  }
  const H = {
    200: 0,
    201: 1,
    202: 768,
    204: 770,
    210: 776,
    208: 774,
    206: 772,
    203: 769,
    205: 771,
    209: 775,
    207: 773
  }
  function k(e, n, i, s, r, o, a, l) {
    if (0 !== e) {
      if ((!1 === d && (B(3042), (d = !0)), 5 === e))
        (r = r || n),
          (o = o || i),
          (a = a || s),
          (n === g && r === y) || (t.blendEquationSeparate(V[n], V[r]), (g = n), (y = r)),
          (i === f && s === m && o === x && a === v) ||
            (t.blendFuncSeparate(H[i], H[s], H[o], H[a]), (f = i), (m = s), (x = o), (v = a)),
          (p = e),
          (_ = null)
      else if (e !== p || l !== _) {
        if (((100 === g && 100 === y) || (t.blendEquation(32774), (g = 100), (y = 100)), l))
          switch (e) {
            case 1:
              t.blendFuncSeparate(1, 771, 1, 771)
              break
            case 2:
              t.blendFunc(1, 1)
              break
            case 3:
              t.blendFuncSeparate(0, 769, 0, 1)
              break
            case 4:
              t.blendFuncSeparate(0, 768, 0, 770)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', e)
          }
        else
          switch (e) {
            case 1:
              t.blendFuncSeparate(770, 771, 1, 771)
              break
            case 2:
              t.blendFunc(770, 1)
              break
            case 3:
              t.blendFuncSeparate(0, 769, 0, 1)
              break
            case 4:
              t.blendFunc(0, 768)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', e)
          }
        ;(f = null), (m = null), (x = null), (v = null), (p = e), (_ = l)
      }
    } else !0 === d && (U(3042), (d = !1))
  }
  function W(e) {
    w !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (w = e))
  }
  function Y(e) {
    0 !== e
      ? (B(2884),
        e !== E && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032)))
      : U(2884),
      (E = e)
  }
  function j(e, n, i) {
    e ? (B(32823), (M === n && S === i) || (t.polygonOffset(n, i), (M = n), (S = i))) : U(32823)
  }
  function q(e) {
    void 0 === e && (e = 33984 + A - 1), L !== e && (t.activeTexture(e), (L = e))
  }
  return {
    buffers: { color: s, depth: r, stencil: o },
    enable: B,
    disable: U,
    bindFramebuffer: function (e, n) {
      return (
        l[e] !== n &&
        (t.bindFramebuffer(e, n),
        (l[e] = n),
        i && (36009 === e && (l[36160] = n), 36160 === e && (l[36009] = n)),
        !0)
      )
    },
    drawBuffers: function (i, s) {
      let r = c,
        o = !1
      if (i)
        if (
          ((r = h.get(s)), void 0 === r && ((r = []), h.set(s, r)), i.isWebGLMultipleRenderTargets)
        ) {
          const t = i.texture
          if (r.length !== t.length || 36064 !== r[0]) {
            for (let e = 0, n = t.length; e < n; e++) r[e] = 36064 + e
            ;(r.length = t.length), (o = !0)
          }
        } else 36064 !== r[0] && ((r[0] = 36064), (o = !0))
      else 1029 !== r[0] && ((r[0] = 1029), (o = !0))
      o && (n.isWebGL2 ? t.drawBuffers(r) : e.get('WEBGL_draw_buffers').drawBuffersWEBGL(r))
    },
    useProgram: function (e) {
      return u !== e && (t.useProgram(e), (u = e), !0)
    },
    setBlending: k,
    setMaterial: function (t, e) {
      2 === t.side ? U(2884) : B(2884)
      let n = 1 === t.side
      e && (n = !n),
        W(n),
        1 === t.blending && !1 === t.transparent
          ? k(0)
          : k(
              t.blending,
              t.blendEquation,
              t.blendSrc,
              t.blendDst,
              t.blendEquationAlpha,
              t.blendSrcAlpha,
              t.blendDstAlpha,
              t.premultipliedAlpha
            ),
        r.setFunc(t.depthFunc),
        r.setTest(t.depthTest),
        r.setMask(t.depthWrite),
        s.setMask(t.colorWrite)
      const i = t.stencilWrite
      o.setTest(i),
        i &&
          (o.setMask(t.stencilWriteMask),
          o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
          o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
        j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
        !0 === t.alphaToCoverage ? B(32926) : U(32926)
    },
    setFlipSided: W,
    setCullFace: Y,
    setLineWidth: function (e) {
      e !== b && (T && t.lineWidth(e), (b = e))
    },
    setPolygonOffset: j,
    setScissorTest: function (t) {
      t ? B(3089) : U(3089)
    },
    activeTexture: q,
    bindTexture: function (e, n) {
      null === L && q()
      let i = C[L]
      void 0 === i && ((i = { type: void 0, texture: void 0 }), (C[L] = i)),
        (i.type === e && i.texture === n) ||
          (t.bindTexture(e, n || z[e]), (i.type = e), (i.texture = n))
    },
    unbindTexture: function () {
      const e = C[L]
      void 0 !== e &&
        void 0 !== e.type &&
        (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0))
    },
    compressedTexImage2D: function () {
      try {
        t.compressedTexImage2D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texImage2D: function () {
      try {
        t.texImage2D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texImage3D: function () {
      try {
        t.texImage3D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texStorage2D: function () {
      try {
        t.texStorage2D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texStorage3D: function () {
      try {
        t.texStorage3D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texSubImage2D: function () {
      try {
        t.texSubImage2D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    texSubImage3D: function () {
      try {
        t.texSubImage3D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    compressedTexSubImage2D: function () {
      try {
        t.compressedTexSubImage2D.apply(t, arguments)
      } catch (t) {
        console.error('THREE.WebGLState:', t)
      }
    },
    scissor: function (e) {
      !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e))
    },
    viewport: function (e) {
      !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), O.copy(e))
    },
    reset: function () {
      t.disable(3042),
        t.disable(2884),
        t.disable(2929),
        t.disable(32823),
        t.disable(3089),
        t.disable(2960),
        t.disable(32926),
        t.blendEquation(32774),
        t.blendFunc(1, 0),
        t.blendFuncSeparate(1, 0, 1, 0),
        t.colorMask(!0, !0, !0, !0),
        t.clearColor(0, 0, 0, 0),
        t.depthMask(!0),
        t.depthFunc(513),
        t.clearDepth(1),
        t.stencilMask(4294967295),
        t.stencilFunc(519, 0, 4294967295),
        t.stencilOp(7680, 7680, 7680),
        t.clearStencil(0),
        t.cullFace(1029),
        t.frontFace(2305),
        t.polygonOffset(0, 0),
        t.activeTexture(33984),
        t.bindFramebuffer(36160, null),
        !0 === i && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)),
        t.useProgram(null),
        t.lineWidth(1),
        t.scissor(0, 0, t.canvas.width, t.canvas.height),
        t.viewport(0, 0, t.canvas.width, t.canvas.height),
        (a = {}),
        (L = null),
        (C = {}),
        (l = {}),
        (h = new WeakMap()),
        (c = []),
        (u = null),
        (d = !1),
        (p = null),
        (g = null),
        (f = null),
        (m = null),
        (y = null),
        (x = null),
        (v = null),
        (_ = !1),
        (w = null),
        (E = null),
        (b = null),
        (M = null),
        (S = null),
        D.set(0, 0, t.canvas.width, t.canvas.height),
        O.set(0, 0, t.canvas.width, t.canvas.height),
        s.reset(),
        r.reset(),
        o.reset()
    }
  }
}
function Ss(t, e, n, i, s, r, o) {
  const a = s.isWebGL2,
    l = s.maxTextures,
    h = s.maxCubemapSize,
    c = s.maxTextureSize,
    u = s.maxSamples,
    d = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    p = new WeakMap()
  let g
  const f = new WeakMap()
  let y = !1
  try {
    y = 'undefined' != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext('2d')
  } catch (t) {}
  function v(t, e) {
    return y ? new OffscreenCanvas(t, e) : b('canvas')
  }
  function _(t, e, n, i) {
    let s = 1
    if (
      ((t.width > i || t.height > i) && (s = i / Math.max(t.width, t.height)), s < 1 || !0 === e)
    ) {
      if (
        ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) ||
        ('undefined' != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) ||
        ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const i = e ? x : Math.floor,
          r = i(s * t.width),
          o = i(s * t.height)
        void 0 === g && (g = v(r, o))
        const a = n ? v(r, o) : g
        ;(a.width = r), (a.height = o)
        return (
          a.getContext('2d').drawImage(t, 0, 0, r, o),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              t.width +
              'x' +
              t.height +
              ') to (' +
              r +
              'x' +
              o +
              ').'
          ),
          a
        )
      }
      return (
        'data' in t &&
          console.warn(
            'THREE.WebGLRenderer: Image in DataTexture is too big (' +
              t.width +
              'x' +
              t.height +
              ').'
          ),
        t
      )
    }
    return t
  }
  function w(t) {
    return m(t.width) && m(t.height)
  }
  function E(t, e) {
    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
  }
  function M(e) {
    t.generateMipmap(e)
  }
  function S(n, i, s, r, o = !1) {
    if (!1 === a) return i
    if (null !== n) {
      if (void 0 !== t[n]) return t[n]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'"
      )
    }
    let l = i
    return (
      6403 === i &&
        (5126 === s && (l = 33326), 5131 === s && (l = 33325), 5121 === s && (l = 33321)),
      33319 === i &&
        (5126 === s && (l = 33328), 5131 === s && (l = 33327), 5121 === s && (l = 33323)),
      6408 === i &&
        (5126 === s && (l = 34836),
        5131 === s && (l = 34842),
        5121 === s && (l = 3001 === r && !1 === o ? 35907 : 32856),
        32819 === s && (l = 32854),
        32820 === s && (l = 32855)),
      (33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l) ||
        e.get('EXT_color_buffer_float'),
      l
    )
  }
  function A(t, e, n) {
    return !0 === E(t, n) ||
      (t.isFramebufferTexture && 1003 !== t.minFilter && 1006 !== t.minFilter)
      ? Math.log2(Math.max(e.width, e.height)) + 1
      : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
          ? e.mipmaps.length
          : 1
  }
  function T(t) {
    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
  }
  function I(t) {
    const e = t.target
    e.removeEventListener('dispose', I),
      (function (t) {
        const e = i.get(t)
        if (void 0 === e.__webglInit) return
        const n = t.source,
          s = f.get(n)
        if (s) {
          const i = s[e.__cacheKey]
          i.usedTimes--, 0 === i.usedTimes && L(t), 0 === Object.keys(s).length && f.delete(n)
        }
        i.remove(t)
      })(e),
      e.isVideoTexture && p.delete(e)
  }
  function R(e) {
    const n = e.target
    n.removeEventListener('dispose', R),
      (function (e) {
        const n = e.texture,
          s = i.get(e),
          r = i.get(n)
        void 0 !== r.__webglTexture && (t.deleteTexture(r.__webglTexture), o.memory.textures--)
        e.depthTexture && e.depthTexture.dispose()
        if (e.isWebGLCubeRenderTarget)
          for (let e = 0; e < 6; e++)
            t.deleteFramebuffer(s.__webglFramebuffer[e]),
              s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer[e])
        else
          t.deleteFramebuffer(s.__webglFramebuffer),
            s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer),
            s.__webglMultisampledFramebuffer &&
              t.deleteFramebuffer(s.__webglMultisampledFramebuffer),
            s.__webglColorRenderbuffer && t.deleteRenderbuffer(s.__webglColorRenderbuffer),
            s.__webglDepthRenderbuffer && t.deleteRenderbuffer(s.__webglDepthRenderbuffer)
        if (e.isWebGLMultipleRenderTargets)
          for (let e = 0, s = n.length; e < s; e++) {
            const s = i.get(n[e])
            s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--),
              i.remove(n[e])
          }
        i.remove(n), i.remove(e)
      })(n)
  }
  function L(e) {
    const n = i.get(e)
    t.deleteTexture(n.__webglTexture)
    const s = e.source
    delete f.get(s)[n.__cacheKey], o.memory.textures--
  }
  let C = 0
  function P(t, e) {
    const s = i.get(t)
    if (
      (t.isVideoTexture &&
        (function (t) {
          const e = o.render.frame
          p.get(t) !== e && (p.set(t, e), t.update())
        })(t),
      !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version)
    ) {
      const n = t.image
      if (null === n)
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.')
      else {
        if (!1 !== n.complete) return void z(s, t, e)
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')
      }
    }
    n.activeTexture(33984 + e), n.bindTexture(3553, s.__webglTexture)
  }
  const D = { 1e3: 10497, 1001: 33071, 1002: 33648 },
    O = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 }
  function F(n, r, o) {
    if (
      (o
        ? (t.texParameteri(n, 10242, D[r.wrapS]),
          t.texParameteri(n, 10243, D[r.wrapT]),
          (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, D[r.wrapR]),
          t.texParameteri(n, 10240, O[r.magFilter]),
          t.texParameteri(n, 10241, O[r.minFilter]))
        : (t.texParameteri(n, 10242, 33071),
          t.texParameteri(n, 10243, 33071),
          (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
          (1001 === r.wrapS && 1001 === r.wrapT) ||
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
            ),
          t.texParameteri(n, 10240, T(r.magFilter)),
          t.texParameteri(n, 10241, T(r.minFilter)),
          1003 !== r.minFilter &&
            1006 !== r.minFilter &&
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
            )),
      !0 === e.has('EXT_texture_filter_anisotropic'))
    ) {
      const o = e.get('EXT_texture_filter_anisotropic')
      if (1015 === r.type && !1 === e.has('OES_texture_float_linear')) return
      if (!1 === a && 1016 === r.type && !1 === e.has('OES_texture_half_float_linear')) return
      ;(r.anisotropy > 1 || i.get(r).__currentAnisotropy) &&
        (t.texParameterf(
          n,
          o.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(r.anisotropy, s.getMaxAnisotropy())
        ),
        (i.get(r).__currentAnisotropy = r.anisotropy))
    }
  }
  function G(e, n) {
    let i = !1
    void 0 === e.__webglInit && ((e.__webglInit = !0), n.addEventListener('dispose', I))
    const s = n.source
    let r = f.get(s)
    void 0 === r && ((r = {}), f.set(s, r))
    const a = (function (t) {
      const e = []
      return (
        e.push(t.wrapS),
        e.push(t.wrapT),
        e.push(t.magFilter),
        e.push(t.minFilter),
        e.push(t.anisotropy),
        e.push(t.internalFormat),
        e.push(t.format),
        e.push(t.type),
        e.push(t.generateMipmaps),
        e.push(t.premultiplyAlpha),
        e.push(t.flipY),
        e.push(t.unpackAlignment),
        e.push(t.encoding),
        e.join()
      )
    })(n)
    if (a !== e.__cacheKey) {
      void 0 === r[a] &&
        ((r[a] = { texture: t.createTexture(), usedTimes: 0 }), o.memory.textures++, (i = !0)),
        r[a].usedTimes++
      const s = r[e.__cacheKey]
      void 0 !== s && (r[e.__cacheKey].usedTimes--, 0 === s.usedTimes && L(n)),
        (e.__cacheKey = a),
        (e.__webglTexture = r[a].texture)
    }
    return i
  }
  function z(e, i, s) {
    let o = 3553
    i.isDataArrayTexture && (o = 35866), i.isData3DTexture && (o = 32879)
    const l = G(e, i),
      h = i.source
    if (
      (n.activeTexture(33984 + s),
      n.bindTexture(o, e.__webglTexture),
      h.version !== h.__currentVersion || !0 === l)
    ) {
      t.pixelStorei(37440, i.flipY),
        t.pixelStorei(37441, i.premultiplyAlpha),
        t.pixelStorei(3317, i.unpackAlignment),
        t.pixelStorei(37443, 0)
      const s =
        (function (t) {
          return (
            !a &&
            (1001 !== t.wrapS || 1001 !== t.wrapT || (1003 !== t.minFilter && 1006 !== t.minFilter))
          )
        })(i) && !1 === w(i.image)
      let l = _(i.image, s, !1, c)
      l = W(i, l)
      const u = w(l) || a,
        d = r.convert(i.format, i.encoding)
      let p,
        g = r.convert(i.type),
        f = S(i.internalFormat, d, g, i.encoding, i.isVideoTexture)
      F(o, i, u)
      const m = i.mipmaps,
        y = a && !0 !== i.isVideoTexture,
        x = void 0 === e.__version,
        v = A(i, l, u)
      if (i.isDepthTexture)
        (f = 6402),
          a
            ? (f =
                1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189)
            : 1015 === i.type &&
              console.error('WebGLRenderer: Floating point depth texture requires WebGL2.'),
          1026 === i.format &&
            6402 === f &&
            1012 !== i.type &&
            1014 !== i.type &&
            (console.warn(
              'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
            ),
            (i.type = 1012),
            (g = r.convert(i.type))),
          1027 === i.format &&
            6402 === f &&
            ((f = 34041),
            1020 !== i.type &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
              ),
              (i.type = 1020),
              (g = r.convert(i.type)))),
          y && x
            ? n.texStorage2D(3553, 1, f, l.width, l.height)
            : n.texImage2D(3553, 0, f, l.width, l.height, 0, d, g, null)
      else if (i.isDataTexture)
        if (m.length > 0 && u) {
          y && x && n.texStorage2D(3553, v, f, m[0].width, m[0].height)
          for (let t = 0, e = m.length; t < e; t++)
            (p = m[t]),
              y
                ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, g, p.data)
                : n.texImage2D(3553, t, f, p.width, p.height, 0, d, g, p.data)
          i.generateMipmaps = !1
        } else
          y
            ? (x && n.texStorage2D(3553, v, f, l.width, l.height),
              n.texSubImage2D(3553, 0, 0, 0, l.width, l.height, d, g, l.data))
            : n.texImage2D(3553, 0, f, l.width, l.height, 0, d, g, l.data)
      else if (i.isCompressedTexture) {
        y && x && n.texStorage2D(3553, v, f, m[0].width, m[0].height)
        for (let t = 0, e = m.length; t < e; t++)
          (p = m[t]),
            1023 !== i.format
              ? null !== d
                ? y
                  ? n.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data)
                  : n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data)
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                  )
              : y
                ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, g, p.data)
                : n.texImage2D(3553, t, f, p.width, p.height, 0, d, g, p.data)
      } else if (i.isDataArrayTexture)
        y
          ? (x && n.texStorage3D(35866, v, f, l.width, l.height, l.depth),
            n.texSubImage3D(35866, 0, 0, 0, 0, l.width, l.height, l.depth, d, g, l.data))
          : n.texImage3D(35866, 0, f, l.width, l.height, l.depth, 0, d, g, l.data)
      else if (i.isData3DTexture)
        y
          ? (x && n.texStorage3D(32879, v, f, l.width, l.height, l.depth),
            n.texSubImage3D(32879, 0, 0, 0, 0, l.width, l.height, l.depth, d, g, l.data))
          : n.texImage3D(32879, 0, f, l.width, l.height, l.depth, 0, d, g, l.data)
      else if (i.isFramebufferTexture)
        y && x
          ? n.texStorage2D(3553, v, f, l.width, l.height)
          : n.texImage2D(3553, 0, f, l.width, l.height, 0, d, g, null)
      else if (m.length > 0 && u) {
        y && x && n.texStorage2D(3553, v, f, m[0].width, m[0].height)
        for (let t = 0, e = m.length; t < e; t++)
          (p = m[t]),
            y ? n.texSubImage2D(3553, t, 0, 0, d, g, p) : n.texImage2D(3553, t, f, d, g, p)
        i.generateMipmaps = !1
      } else
        y
          ? (x && n.texStorage2D(3553, v, f, l.width, l.height),
            n.texSubImage2D(3553, 0, 0, 0, d, g, l))
          : n.texImage2D(3553, 0, f, d, g, l)
      E(i, u) && M(o), (h.__currentVersion = h.version), i.onUpdate && i.onUpdate(i)
    }
    e.__version = i.version
  }
  function B(e, s, o, a, l) {
    const h = r.convert(o.format, o.encoding),
      c = r.convert(o.type),
      u = S(o.internalFormat, h, c, o.encoding)
    i.get(s).__hasExternalTextures ||
      (32879 === l || 35866 === l
        ? n.texImage3D(l, 0, u, s.width, s.height, s.depth, 0, h, c, null)
        : n.texImage2D(l, 0, u, s.width, s.height, 0, h, c, null)),
      n.bindFramebuffer(36160, e),
      k(s)
        ? d.framebufferTexture2DMultisampleEXT(36160, a, l, i.get(o).__webglTexture, 0, H(s))
        : t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
      n.bindFramebuffer(36160, null)
  }
  function U(e, n, i) {
    if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
      let s = 33189
      if (i || k(n)) {
        const e = n.depthTexture
        e && e.isDepthTexture && (1015 === e.type ? (s = 36012) : 1014 === e.type && (s = 33190))
        const i = H(n)
        k(n)
          ? d.renderbufferStorageMultisampleEXT(36161, i, s, n.width, n.height)
          : t.renderbufferStorageMultisample(36161, i, s, n.width, n.height)
      } else t.renderbufferStorage(36161, s, n.width, n.height)
      t.framebufferRenderbuffer(36160, 36096, 36161, e)
    } else if (n.depthBuffer && n.stencilBuffer) {
      const s = H(n)
      i && !1 === k(n)
        ? t.renderbufferStorageMultisample(36161, s, 35056, n.width, n.height)
        : k(n)
          ? d.renderbufferStorageMultisampleEXT(36161, s, 35056, n.width, n.height)
          : t.renderbufferStorage(36161, 34041, n.width, n.height),
        t.framebufferRenderbuffer(36160, 33306, 36161, e)
    } else {
      const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
        s = r.convert(e.format, e.encoding),
        o = r.convert(e.type),
        a = S(e.internalFormat, s, o, e.encoding),
        l = H(n)
      i && !1 === k(n)
        ? t.renderbufferStorageMultisample(36161, l, a, n.width, n.height)
        : k(n)
          ? d.renderbufferStorageMultisampleEXT(36161, l, a, n.width, n.height)
          : t.renderbufferStorage(36161, a, n.width, n.height)
    }
    t.bindRenderbuffer(36161, null)
  }
  function V(e) {
    const s = i.get(e),
      r = !0 === e.isWebGLCubeRenderTarget
    if (e.depthTexture && !s.__autoAllocateDepthBuffer) {
      if (r) throw new Error('target.depthTexture not supported in Cube render targets')
      !(function (e, s) {
        if (s && s.isWebGLCubeRenderTarget)
          throw new Error('Depth Texture with cube render targets is not supported')
        if ((n.bindFramebuffer(36160, e), !s.depthTexture || !s.depthTexture.isDepthTexture))
          throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
        ;(i.get(s.depthTexture).__webglTexture &&
          s.depthTexture.image.width === s.width &&
          s.depthTexture.image.height === s.height) ||
          ((s.depthTexture.image.width = s.width),
          (s.depthTexture.image.height = s.height),
          (s.depthTexture.needsUpdate = !0)),
          P(s.depthTexture, 0)
        const r = i.get(s.depthTexture).__webglTexture,
          o = H(s)
        if (1026 === s.depthTexture.format)
          k(s)
            ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, r, 0, o)
            : t.framebufferTexture2D(36160, 36096, 3553, r, 0)
        else {
          if (1027 !== s.depthTexture.format) throw new Error('Unknown depthTexture format')
          k(s)
            ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, r, 0, o)
            : t.framebufferTexture2D(36160, 33306, 3553, r, 0)
        }
      })(s.__webglFramebuffer, e)
    } else if (r) {
      s.__webglDepthbuffer = []
      for (let i = 0; i < 6; i++)
        n.bindFramebuffer(36160, s.__webglFramebuffer[i]),
          (s.__webglDepthbuffer[i] = t.createRenderbuffer()),
          U(s.__webglDepthbuffer[i], e, !1)
    } else
      n.bindFramebuffer(36160, s.__webglFramebuffer),
        (s.__webglDepthbuffer = t.createRenderbuffer()),
        U(s.__webglDepthbuffer, e, !1)
    n.bindFramebuffer(36160, null)
  }
  function H(t) {
    return Math.min(u, t.samples)
  }
  function k(t) {
    const n = i.get(t)
    return (
      a &&
      t.samples > 0 &&
      !0 === e.has('WEBGL_multisampled_render_to_texture') &&
      !1 !== n.__useRenderToTexture
    )
  }
  function W(t, n) {
    const i = t.encoding,
      s = t.format,
      r = t.type
    return (
      !0 === t.isCompressedTexture ||
        !0 === t.isVideoTexture ||
        1035 === t.format ||
        (3e3 !== i &&
          (3001 === i
            ? !1 === a
              ? !0 === e.has('EXT_sRGB') && 1023 === s
                ? ((t.format = 1035), (t.minFilter = 1006), (t.generateMipmaps = !1))
                : (n = N.sRGBToLinear(n))
              : (1023 === s && 1009 === r) ||
                console.warn(
                  'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
                )
            : console.error('THREE.WebGLTextures: Unsupported texture encoding:', i))),
      n
    )
  }
  ;(this.allocateTextureUnit = function () {
    const t = C
    return (
      t >= l &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            t +
            ' texture units while this GPU supports only ' +
            l
        ),
      (C += 1),
      t
    )
  }),
    (this.resetTextureUnits = function () {
      C = 0
    }),
    (this.setTexture2D = P),
    (this.setTexture2DArray = function (t, e) {
      const s = i.get(t)
      t.version > 0 && s.__version !== t.version
        ? z(s, t, e)
        : (n.activeTexture(33984 + e), n.bindTexture(35866, s.__webglTexture))
    }),
    (this.setTexture3D = function (t, e) {
      const s = i.get(t)
      t.version > 0 && s.__version !== t.version
        ? z(s, t, e)
        : (n.activeTexture(33984 + e), n.bindTexture(32879, s.__webglTexture))
    }),
    (this.setTextureCube = function (e, s) {
      const o = i.get(e)
      e.version > 0 && o.__version !== e.version
        ? (function (e, i, s) {
            if (6 !== i.image.length) return
            const o = G(e, i),
              l = i.source
            if (
              (n.activeTexture(33984 + s),
              n.bindTexture(34067, e.__webglTexture),
              l.version !== l.__currentVersion || !0 === o)
            ) {
              t.pixelStorei(37440, i.flipY),
                t.pixelStorei(37441, i.premultiplyAlpha),
                t.pixelStorei(3317, i.unpackAlignment),
                t.pixelStorei(37443, 0)
              const s = i.isCompressedTexture || i.image[0].isCompressedTexture,
                o = i.image[0] && i.image[0].isDataTexture,
                c = []
              for (let t = 0; t < 6; t++)
                (c[t] = s || o ? (o ? i.image[t].image : i.image[t]) : _(i.image[t], !1, !0, h)),
                  (c[t] = W(i, c[t]))
              const u = c[0],
                d = w(u) || a,
                p = r.convert(i.format, i.encoding),
                g = r.convert(i.type),
                f = S(i.internalFormat, p, g, i.encoding),
                m = a && !0 !== i.isVideoTexture,
                y = void 0 === e.__version
              let x,
                v = A(i, u, d)
              if ((F(34067, i, d), s)) {
                m && y && n.texStorage2D(34067, v, f, u.width, u.height)
                for (let t = 0; t < 6; t++) {
                  x = c[t].mipmaps
                  for (let e = 0; e < x.length; e++) {
                    const s = x[e]
                    1023 !== i.format
                      ? null !== p
                        ? m
                          ? n.compressedTexSubImage2D(
                              34069 + t,
                              e,
                              0,
                              0,
                              s.width,
                              s.height,
                              p,
                              s.data
                            )
                          : n.compressedTexImage2D(34069 + t, e, f, s.width, s.height, 0, s.data)
                        : console.warn(
                            'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                          )
                      : m
                        ? n.texSubImage2D(34069 + t, e, 0, 0, s.width, s.height, p, g, s.data)
                        : n.texImage2D(34069 + t, e, f, s.width, s.height, 0, p, g, s.data)
                  }
                }
              } else {
                ;(x = i.mipmaps),
                  m &&
                    y &&
                    (x.length > 0 && v++, n.texStorage2D(34067, v, f, c[0].width, c[0].height))
                for (let t = 0; t < 6; t++)
                  if (o) {
                    m
                      ? n.texSubImage2D(
                          34069 + t,
                          0,
                          0,
                          0,
                          c[t].width,
                          c[t].height,
                          p,
                          g,
                          c[t].data
                        )
                      : n.texImage2D(34069 + t, 0, f, c[t].width, c[t].height, 0, p, g, c[t].data)
                    for (let e = 0; e < x.length; e++) {
                      const i = x[e].image[t].image
                      m
                        ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, p, g, i.data)
                        : n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, g, i.data)
                    }
                  } else {
                    m
                      ? n.texSubImage2D(34069 + t, 0, 0, 0, p, g, c[t])
                      : n.texImage2D(34069 + t, 0, f, p, g, c[t])
                    for (let e = 0; e < x.length; e++) {
                      const i = x[e]
                      m
                        ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, g, i.image[t])
                        : n.texImage2D(34069 + t, e + 1, f, p, g, i.image[t])
                    }
                  }
              }
              E(i, d) && M(34067), (l.__currentVersion = l.version), i.onUpdate && i.onUpdate(i)
            }
            e.__version = i.version
          })(o, e, s)
        : (n.activeTexture(33984 + s), n.bindTexture(34067, o.__webglTexture))
    }),
    (this.rebindTextures = function (t, e, n) {
      const s = i.get(t)
      void 0 !== e && B(s.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && V(t)
    }),
    (this.setupRenderTarget = function (e) {
      const l = e.texture,
        h = i.get(e),
        c = i.get(l)
      e.addEventListener('dispose', R),
        !0 !== e.isWebGLMultipleRenderTargets &&
          (void 0 === c.__webglTexture && (c.__webglTexture = t.createTexture()),
          (c.__version = l.version),
          o.memory.textures++)
      const u = !0 === e.isWebGLCubeRenderTarget,
        d = !0 === e.isWebGLMultipleRenderTargets,
        p = w(e) || a
      if (u) {
        h.__webglFramebuffer = []
        for (let e = 0; e < 6; e++) h.__webglFramebuffer[e] = t.createFramebuffer()
      } else if (((h.__webglFramebuffer = t.createFramebuffer()), d))
        if (s.drawBuffers) {
          const n = e.texture
          for (let e = 0, s = n.length; e < s; e++) {
            const s = i.get(n[e])
            void 0 === s.__webglTexture &&
              ((s.__webglTexture = t.createTexture()), o.memory.textures++)
          }
        } else
          console.warn(
            'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
          )
      else if (a && e.samples > 0 && !1 === k(e)) {
        ;(h.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (h.__webglColorRenderbuffer = t.createRenderbuffer()),
          t.bindRenderbuffer(36161, h.__webglColorRenderbuffer)
        const i = r.convert(l.format, l.encoding),
          s = r.convert(l.type),
          o = S(l.internalFormat, i, s, l.encoding),
          a = H(e)
        t.renderbufferStorageMultisample(36161, a, o, e.width, e.height),
          n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
          t.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer),
          t.bindRenderbuffer(36161, null),
          e.depthBuffer &&
            ((h.__webglDepthRenderbuffer = t.createRenderbuffer()),
            U(h.__webglDepthRenderbuffer, e, !0)),
          n.bindFramebuffer(36160, null)
      }
      if (u) {
        n.bindTexture(34067, c.__webglTexture), F(34067, l, p)
        for (let t = 0; t < 6; t++) B(h.__webglFramebuffer[t], e, l, 36064, 34069 + t)
        E(l, p) && M(34067), n.unbindTexture()
      } else if (d) {
        const t = e.texture
        for (let s = 0, r = t.length; s < r; s++) {
          const r = t[s],
            o = i.get(r)
          n.bindTexture(3553, o.__webglTexture),
            F(3553, r, p),
            B(h.__webglFramebuffer, e, r, 36064 + s, 3553),
            E(r, p) && M(3553)
        }
        n.unbindTexture()
      } else {
        let t = 3553
        ;(e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
          (a
            ? (t = e.isWebGL3DRenderTarget ? 32879 : 35866)
            : console.error(
                'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.'
              )),
          n.bindTexture(t, c.__webglTexture),
          F(t, l, p),
          B(h.__webglFramebuffer, e, l, 36064, t),
          E(l, p) && M(t),
          n.unbindTexture()
      }
      e.depthBuffer && V(e)
    }),
    (this.updateRenderTargetMipmap = function (t) {
      const e = w(t) || a,
        s = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
      for (let r = 0, o = s.length; r < o; r++) {
        const o = s[r]
        if (E(o, e)) {
          const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
            s = i.get(o).__webglTexture
          n.bindTexture(e, s), M(e), n.unbindTexture()
        }
      }
    }),
    (this.updateMultisampleRenderTarget = function (e) {
      if (a && e.samples > 0 && !1 === k(e)) {
        const s = e.width,
          r = e.height
        let o = 16384
        const a = [36064],
          l = e.stencilBuffer ? 33306 : 36096
        e.depthBuffer && a.push(l)
        const h = i.get(e),
          c = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues
        !1 === c && (e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024)),
          n.bindFramebuffer(36008, h.__webglMultisampledFramebuffer),
          n.bindFramebuffer(36009, h.__webglFramebuffer),
          !0 === c && (t.invalidateFramebuffer(36008, [l]), t.invalidateFramebuffer(36009, [l])),
          t.blitFramebuffer(0, 0, s, r, 0, 0, s, r, o, 9728),
          t.invalidateFramebuffer(36008, a),
          n.bindFramebuffer(36008, null),
          n.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
      }
    }),
    (this.setupDepthRenderbuffer = V),
    (this.setupFrameBufferTexture = B),
    (this.useMultisampledRTT = k)
}
function As(t, e, n) {
  const i = n.isWebGL2
  return {
    convert: function (t, n = null) {
      let s
      if (1009 === t) return 5121
      if (1017 === t) return 32819
      if (1018 === t) return 32820
      if (1010 === t) return 5120
      if (1011 === t) return 5122
      if (1012 === t) return 5123
      if (1013 === t) return 5124
      if (1014 === t) return 5125
      if (1015 === t) return 5126
      if (1016 === t)
        return i
          ? 5131
          : ((s = e.get('OES_texture_half_float')), null !== s ? s.HALF_FLOAT_OES : null)
      if (1021 === t) return 6406
      if (1023 === t) return 6408
      if (1024 === t) return 6409
      if (1025 === t) return 6410
      if (1026 === t) return 6402
      if (1027 === t) return 34041
      if (1028 === t) return 6403
      if (1022 === t)
        return (
          console.warn(
            'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228'
          ),
          6408
        )
      if (1035 === t) return (s = e.get('EXT_sRGB')), null !== s ? s.SRGB_ALPHA_EXT : null
      if (1029 === t) return 36244
      if (1030 === t) return 33319
      if (1031 === t) return 33320
      if (1033 === t) return 36249
      if (33776 === t || 33777 === t || 33778 === t || 33779 === t)
        if (3001 === n) {
          if (((s = e.get('WEBGL_compressed_texture_s3tc_srgb')), null === s)) return null
          if (33776 === t) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (33777 === t) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (33778 === t) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (33779 === t) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else {
          if (((s = e.get('WEBGL_compressed_texture_s3tc')), null === s)) return null
          if (33776 === t) return s.COMPRESSED_RGB_S3TC_DXT1_EXT
          if (33777 === t) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT
          if (33778 === t) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT
          if (33779 === t) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
      if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
        if (((s = e.get('WEBGL_compressed_texture_pvrtc')), null === s)) return null
        if (35840 === t) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (35841 === t) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (35842 === t) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (35843 === t) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      }
      if (36196 === t)
        return (
          (s = e.get('WEBGL_compressed_texture_etc1')),
          null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
        )
      if (37492 === t || 37496 === t) {
        if (((s = e.get('WEBGL_compressed_texture_etc')), null === s)) return null
        if (37492 === t) return 3001 === n ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2
        if (37496 === t)
          return 3001 === n ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
      }
      if (
        37808 === t ||
        37809 === t ||
        37810 === t ||
        37811 === t ||
        37812 === t ||
        37813 === t ||
        37814 === t ||
        37815 === t ||
        37816 === t ||
        37817 === t ||
        37818 === t ||
        37819 === t ||
        37820 === t ||
        37821 === t
      ) {
        if (((s = e.get('WEBGL_compressed_texture_astc')), null === s)) return null
        if (37808 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (37809 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (37810 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (37811 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (37812 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (37813 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (37814 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (37815 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (37816 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (37817 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (37818 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (37819 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (37820 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (37821 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR
      }
      if (36492 === t) {
        if (((s = e.get('EXT_texture_compression_bptc')), null === s)) return null
        if (36492 === t)
          return 3001 === n
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
      }
      return 1020 === t
        ? i
          ? 34042
          : ((s = e.get('WEBGL_depth_texture')), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
        : void 0
    }
  }
}
class Ts extends We {
  constructor(t = []) {
    super(), (this.cameras = t)
  }
}
Ts.prototype.isArrayCamera = !0
class Is extends Wt {
  constructor() {
    super(), (this.type = 'Group')
  }
}
Is.prototype.isGroup = !0
const Rs = { type: 'move' }
class Ls {
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      null === this._hand &&
        ((this._hand = new Is()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      null === this._targetRay &&
        ((this._targetRay = new Is()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new H()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new H())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      null === this._grip &&
        ((this._grip = new Is()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new H()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new H())),
      this._grip
    )
  }
  dispatchEvent(t) {
    return (
      null !== this._targetRay && this._targetRay.dispatchEvent(t),
      null !== this._grip && this._grip.dispatchEvent(t),
      null !== this._hand && this._hand.dispatchEvent(t),
      this
    )
  }
  disconnect(t) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: t }),
      null !== this._targetRay && (this._targetRay.visible = !1),
      null !== this._grip && (this._grip.visible = !1),
      null !== this._hand && (this._hand.visible = !1),
      this
    )
  }
  update(t, e, n) {
    let i = null,
      s = null,
      r = null
    const o = this._targetRay,
      a = this._grip,
      l = this._hand
    if (t && 'visible-blurred' !== e.session.visibilityState)
      if (
        (null !== o &&
          ((i = e.getPose(t.targetRaySpace, n)),
          null !== i &&
            (o.matrix.fromArray(i.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale),
            i.linearVelocity
              ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(i.linearVelocity))
              : (o.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(i.angularVelocity))
              : (o.hasAngularVelocity = !1),
            this.dispatchEvent(Rs))),
        l && t.hand)
      ) {
        r = !0
        for (const i of t.hand.values()) {
          const t = e.getJointPose(i, n)
          if (void 0 === l.joints[i.jointName]) {
            const t = new Is()
            ;(t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[i.jointName] = t), l.add(t)
          }
          const s = l.joints[i.jointName]
          null !== t &&
            (s.matrix.fromArray(t.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale),
            (s.jointRadius = t.radius)),
            (s.visible = null !== t)
        }
        const i = l.joints['index-finger-tip'],
          s = l.joints['thumb-tip'],
          o = i.position.distanceTo(s.position),
          a = 0.02,
          h = 0.005
        l.inputState.pinching && o > a + h
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({ type: 'pinchend', handedness: t.handedness, target: this }))
          : !l.inputState.pinching &&
            o <= a - h &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({ type: 'pinchstart', handedness: t.handedness, target: this }))
      } else
        null !== a &&
          t.gripSpace &&
          ((s = e.getPose(t.gripSpace, n)),
          null !== s &&
            (a.matrix.fromArray(s.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            s.linearVelocity
              ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(s.linearVelocity))
              : (a.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(s.angularVelocity))
              : (a.hasAngularVelocity = !1)))
    return (
      null !== o && (o.visible = null !== i),
      null !== a && (a.visible = null !== s),
      null !== l && (l.visible = null !== r),
      this
    )
  }
}
class Cs extends F {
  constructor(t, e, n, i, s, r, o, a, l, h) {
    if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      )
    void 0 === n && 1026 === h && (n = 1012),
      void 0 === n && 1027 === h && (n = 1020),
      super(null, i, s, r, o, a, h, n, l),
      (this.image = { width: t, height: e }),
      (this.magFilter = void 0 !== o ? o : 1003),
      (this.minFilter = void 0 !== a ? a : 1003),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
Cs.prototype.isDepthTexture = !0
class Ns extends a {
  constructor(t, e) {
    super()
    const n = this
    let i = null,
      s = 1,
      r = null,
      o = 'local-floor',
      a = null,
      l = null,
      h = null,
      c = null,
      u = null
    const d = e.getContextAttributes()
    let p = null,
      g = null
    const f = [],
      m = new Map(),
      y = new We()
    y.layers.enable(1), (y.viewport = new G())
    const x = new We()
    x.layers.enable(2), (x.viewport = new G())
    const v = [y, x],
      _ = new Ts()
    _.layers.enable(1), _.layers.enable(2)
    let w = null,
      E = null
    function b(t) {
      const e = m.get(t.inputSource)
      e && e.dispatchEvent({ type: t.type, data: t.inputSource })
    }
    function M() {
      m.forEach(function (t, e) {
        t.disconnect(e)
      }),
        m.clear(),
        (w = null),
        (E = null),
        t.setRenderTarget(p),
        (c = null),
        (h = null),
        (l = null),
        (i = null),
        (g = null),
        L.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: 'sessionend' })
    }
    function S(t) {
      const e = i.inputSources
      for (let t = 0; t < f.length; t++) m.set(e[t], f[t])
      for (let e = 0; e < t.removed.length; e++) {
        const n = t.removed[e],
          i = m.get(n)
        i && (i.dispatchEvent({ type: 'disconnected', data: n }), m.delete(n))
      }
      for (let e = 0; e < t.added.length; e++) {
        const n = t.added[e],
          i = m.get(n)
        i && i.dispatchEvent({ type: 'connected', data: n })
      }
    }
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (t) {
        let e = f[t]
        return void 0 === e && ((e = new Ls()), (f[t] = e)), e.getTargetRaySpace()
      }),
      (this.getControllerGrip = function (t) {
        let e = f[t]
        return void 0 === e && ((e = new Ls()), (f[t] = e)), e.getGripSpace()
      }),
      (this.getHand = function (t) {
        let e = f[t]
        return void 0 === e && ((e = new Ls()), (f[t] = e)), e.getHandSpace()
      }),
      (this.setFramebufferScaleFactor = function (t) {
        ;(s = t),
          !0 === n.isPresenting &&
            console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.')
      }),
      (this.setReferenceSpaceType = function (t) {
        ;(o = t),
          !0 === n.isPresenting &&
            console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.')
      }),
      (this.getReferenceSpace = function () {
        return r
      }),
      (this.getBaseLayer = function () {
        return null !== h ? h : c
      }),
      (this.getBinding = function () {
        return l
      }),
      (this.getFrame = function () {
        return u
      }),
      (this.getSession = function () {
        return i
      }),
      (this.setSession = async function (a) {
        if (((i = a), null !== i)) {
          if (
            ((p = t.getRenderTarget()),
            i.addEventListener('select', b),
            i.addEventListener('selectstart', b),
            i.addEventListener('selectend', b),
            i.addEventListener('squeeze', b),
            i.addEventListener('squeezestart', b),
            i.addEventListener('squeezeend', b),
            i.addEventListener('end', M),
            i.addEventListener('inputsourceschange', S),
            !0 !== d.xrCompatible && (await e.makeXRCompatible()),
            void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2)
          ) {
            const n = {
              antialias: void 0 !== i.renderState.layers || d.antialias,
              alpha: d.alpha,
              depth: d.depth,
              stencil: d.stencil,
              framebufferScaleFactor: s
            }
            ;(c = new XRWebGLLayer(i, e, n)),
              i.updateRenderState({ baseLayer: c }),
              (g = new z(c.framebufferWidth, c.framebufferHeight, {
                format: 1023,
                type: 1009,
                encoding: t.outputEncoding
              }))
          } else {
            let n = null,
              r = null,
              o = null
            d.depth &&
              ((o = d.stencil ? 35056 : 33190),
              (n = d.stencil ? 1027 : 1026),
              (r = d.stencil ? 1020 : 1012))
            const a = {
              colorFormat: 3001 === t.outputEncoding ? 35907 : 32856,
              depthFormat: o,
              scaleFactor: s
            }
            ;(l = new XRWebGLBinding(i, e)),
              (h = l.createProjectionLayer(a)),
              i.updateRenderState({ layers: [h] }),
              (g = new z(h.textureWidth, h.textureHeight, {
                format: 1023,
                type: 1009,
                depthTexture: new Cs(
                  h.textureWidth,
                  h.textureHeight,
                  r,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  n
                ),
                stencilBuffer: d.stencil,
                encoding: t.outputEncoding,
                samples: d.antialias ? 4 : 0
              }))
            t.properties.get(g).__ignoreDepthValues = h.ignoreDepthValues
          }
          ;(g.isXRRenderTarget = !0),
            this.setFoveation(1),
            (r = await i.requestReferenceSpace(o)),
            L.setContext(i),
            L.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: 'sessionstart' })
        }
      })
    const A = new H(),
      T = new H()
    function I(t, e) {
      null === e
        ? t.matrixWorld.copy(t.matrix)
        : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
        t.matrixWorldInverse.copy(t.matrixWorld).invert()
    }
    ;(this.updateCamera = function (t) {
      if (null === i) return
      ;(_.near = x.near = y.near = t.near),
        (_.far = x.far = y.far = t.far),
        (w === _.near && E === _.far) ||
          (i.updateRenderState({ depthNear: _.near, depthFar: _.far }), (w = _.near), (E = _.far))
      const e = t.parent,
        n = _.cameras
      I(_, e)
      for (let t = 0; t < n.length; t++) I(n[t], e)
      _.matrixWorld.decompose(_.position, _.quaternion, _.scale),
        t.position.copy(_.position),
        t.quaternion.copy(_.quaternion),
        t.scale.copy(_.scale),
        t.matrix.copy(_.matrix),
        t.matrixWorld.copy(_.matrixWorld)
      const s = t.children
      for (let t = 0, e = s.length; t < e; t++) s[t].updateMatrixWorld(!0)
      2 === n.length
        ? (function (t, e, n) {
            A.setFromMatrixPosition(e.matrixWorld), T.setFromMatrixPosition(n.matrixWorld)
            const i = A.distanceTo(T),
              s = e.projectionMatrix.elements,
              r = n.projectionMatrix.elements,
              o = s[14] / (s[10] - 1),
              a = s[14] / (s[10] + 1),
              l = (s[9] + 1) / s[5],
              h = (s[9] - 1) / s[5],
              c = (s[8] - 1) / s[0],
              u = (r[8] + 1) / r[0],
              d = o * c,
              p = o * u,
              g = i / (-c + u),
              f = g * -c
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
              t.translateX(f),
              t.translateZ(g),
              t.matrixWorld.compose(t.position, t.quaternion, t.scale),
              t.matrixWorldInverse.copy(t.matrixWorld).invert()
            const m = o + g,
              y = a + g,
              x = d - f,
              v = p + (i - f),
              _ = ((l * a) / y) * m,
              w = ((h * a) / y) * m
            t.projectionMatrix.makePerspective(x, v, _, w, m, y)
          })(_, y, x)
        : _.projectionMatrix.copy(y.projectionMatrix)
    }),
      (this.getCamera = function () {
        return _
      }),
      (this.getFoveation = function () {
        return null !== h ? h.fixedFoveation : null !== c ? c.fixedFoveation : void 0
      }),
      (this.setFoveation = function (t) {
        null !== h && (h.fixedFoveation = t),
          null !== c && void 0 !== c.fixedFoveation && (c.fixedFoveation = t)
      })
    let R = null
    const L = new en()
    L.setAnimationLoop(function (e, n) {
      if (((a = n.getViewerPose(r)), (u = n), null !== a)) {
        const e = a.views
        null !== c && (t.setRenderTargetFramebuffer(g, c.framebuffer), t.setRenderTarget(g))
        let n = !1
        e.length !== _.cameras.length && ((_.cameras.length = 0), (n = !0))
        for (let i = 0; i < e.length; i++) {
          const s = e[i]
          let r = null
          if (null !== c) r = c.getViewport(s)
          else {
            const e = l.getViewSubImage(h, s)
            ;(r = e.viewport),
              0 === i &&
                (t.setRenderTargetTextures(
                  g,
                  e.colorTexture,
                  h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                ),
                t.setRenderTarget(g))
          }
          const o = v[i]
          o.matrix.fromArray(s.transform.matrix),
            o.projectionMatrix.fromArray(s.projectionMatrix),
            o.viewport.set(r.x, r.y, r.width, r.height),
            0 === i && _.matrix.copy(o.matrix),
            !0 === n && _.cameras.push(o)
        }
      }
      const s = i.inputSources
      for (let t = 0; t < f.length; t++) {
        const e = f[t],
          i = s[t]
        e.update(i, n, r)
      }
      R && R(e, n), (u = null)
    }),
      (this.setAnimationLoop = function (t) {
        R = t
      }),
      (this.dispose = function () {})
  }
}
function Ps(t, e) {
  function n(n, i) {
    ;(n.opacity.value = i.opacity),
      i.color && n.diffuse.value.copy(i.color),
      i.emissive && n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
      i.map && (n.map.value = i.map),
      i.alphaMap && (n.alphaMap.value = i.alphaMap),
      i.specularMap && (n.specularMap.value = i.specularMap),
      i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest)
    const s = e.get(i).envMap
    if (
      (s &&
        ((n.envMap.value = s),
        (n.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
        (n.reflectivity.value = i.reflectivity),
        (n.ior.value = i.ior),
        (n.refractionRatio.value = i.refractionRatio)),
      i.lightMap)
    ) {
      n.lightMap.value = i.lightMap
      const e = !0 !== t.physicallyCorrectLights ? Math.PI : 1
      n.lightMapIntensity.value = i.lightMapIntensity * e
    }
    let r, o
    i.aoMap && ((n.aoMap.value = i.aoMap), (n.aoMapIntensity.value = i.aoMapIntensity)),
      i.map
        ? (r = i.map)
        : i.specularMap
          ? (r = i.specularMap)
          : i.displacementMap
            ? (r = i.displacementMap)
            : i.normalMap
              ? (r = i.normalMap)
              : i.bumpMap
                ? (r = i.bumpMap)
                : i.roughnessMap
                  ? (r = i.roughnessMap)
                  : i.metalnessMap
                    ? (r = i.metalnessMap)
                    : i.alphaMap
                      ? (r = i.alphaMap)
                      : i.emissiveMap
                        ? (r = i.emissiveMap)
                        : i.clearcoatMap
                          ? (r = i.clearcoatMap)
                          : i.clearcoatNormalMap
                            ? (r = i.clearcoatNormalMap)
                            : i.clearcoatRoughnessMap
                              ? (r = i.clearcoatRoughnessMap)
                              : i.specularIntensityMap
                                ? (r = i.specularIntensityMap)
                                : i.specularColorMap
                                  ? (r = i.specularColorMap)
                                  : i.transmissionMap
                                    ? (r = i.transmissionMap)
                                    : i.thicknessMap
                                      ? (r = i.thicknessMap)
                                      : i.sheenColorMap
                                        ? (r = i.sheenColorMap)
                                        : i.sheenRoughnessMap && (r = i.sheenRoughnessMap),
      void 0 !== r &&
        (r.isWebGLRenderTarget && (r = r.texture),
        !0 === r.matrixAutoUpdate && r.updateMatrix(),
        n.uvTransform.value.copy(r.matrix)),
      i.aoMap ? (o = i.aoMap) : i.lightMap && (o = i.lightMap),
      void 0 !== o &&
        (o.isWebGLRenderTarget && (o = o.texture),
        !0 === o.matrixAutoUpdate && o.updateMatrix(),
        n.uv2Transform.value.copy(o.matrix))
  }
  function i(t, n) {
    ;(t.roughness.value = n.roughness),
      (t.metalness.value = n.metalness),
      n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
      n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
      n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
      n.bumpMap &&
        ((t.bumpMap.value = n.bumpMap),
        (t.bumpScale.value = n.bumpScale),
        1 === n.side && (t.bumpScale.value *= -1)),
      n.normalMap &&
        ((t.normalMap.value = n.normalMap),
        t.normalScale.value.copy(n.normalScale),
        1 === n.side && t.normalScale.value.negate()),
      n.displacementMap &&
        ((t.displacementMap.value = n.displacementMap),
        (t.displacementScale.value = n.displacementScale),
        (t.displacementBias.value = n.displacementBias))
    e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
  }
  return {
    refreshFogUniforms: function (t, e) {
      t.fogColor.value.copy(e.color),
        e.isFog
          ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
          : e.isFogExp2 && (t.fogDensity.value = e.density)
    },
    refreshMaterialUniforms: function (t, e, s, r, o) {
      e.isMeshBasicMaterial
        ? n(t, e)
        : e.isMeshLambertMaterial
          ? (n(t, e),
            (function (t, e) {
              e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            })(t, e))
          : e.isMeshToonMaterial
            ? (n(t, e),
              (function (t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap)
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1))
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate())
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias))
              })(t, e))
            : e.isMeshPhongMaterial
              ? (n(t, e),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4)),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale),
                    1 === e.side && (t.bumpScale.value *= -1))
                  e.normalMap &&
                    ((t.normalMap.value = e.normalMap),
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate())
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias))
                })(t, e))
              : e.isMeshStandardMaterial
                ? (n(t, e),
                  e.isMeshPhysicalMaterial
                    ? (function (t, e, n) {
                        i(t, e),
                          (t.ior.value = e.ior),
                          e.sheen > 0 &&
                            (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                            (t.sheenRoughness.value = e.sheenRoughness),
                            e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
                            e.sheenRoughnessMap &&
                              (t.sheenRoughnessMap.value = e.sheenRoughnessMap))
                        e.clearcoat > 0 &&
                          ((t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                          e.clearcoatRoughnessMap &&
                            (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                          e.clearcoatNormalMap &&
                            (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                            (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                            1 === e.side && t.clearcoatNormalScale.value.negate()))
                        e.transmission > 0 &&
                          ((t.transmission.value = e.transmission),
                          (t.transmissionSamplerMap.value = n.texture),
                          t.transmissionSamplerSize.value.set(n.width, n.height),
                          e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                          (t.thickness.value = e.thickness),
                          e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                          (t.attenuationDistance.value = e.attenuationDistance),
                          t.attenuationColor.value.copy(e.attenuationColor))
                        ;(t.specularIntensity.value = e.specularIntensity),
                          t.specularColor.value.copy(e.specularColor),
                          e.specularIntensityMap &&
                            (t.specularIntensityMap.value = e.specularIntensityMap)
                        e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                      })(t, e, o)
                    : i(t, e))
                : e.isMeshMatcapMaterial
                  ? (n(t, e),
                    (function (t, e) {
                      e.matcap && (t.matcap.value = e.matcap)
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        1 === e.side && (t.bumpScale.value *= -1))
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate())
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias))
                    })(t, e))
                  : e.isMeshDepthMaterial
                    ? (n(t, e),
                      (function (t, e) {
                        e.displacementMap &&
                          ((t.displacementMap.value = e.displacementMap),
                          (t.displacementScale.value = e.displacementScale),
                          (t.displacementBias.value = e.displacementBias))
                      })(t, e))
                    : e.isMeshDistanceMaterial
                      ? (n(t, e),
                        (function (t, e) {
                          e.displacementMap &&
                            ((t.displacementMap.value = e.displacementMap),
                            (t.displacementScale.value = e.displacementScale),
                            (t.displacementBias.value = e.displacementBias))
                          t.referencePosition.value.copy(e.referencePosition),
                            (t.nearDistance.value = e.nearDistance),
                            (t.farDistance.value = e.farDistance)
                        })(t, e))
                      : e.isMeshNormalMaterial
                        ? (n(t, e),
                          (function (t, e) {
                            e.bumpMap &&
                              ((t.bumpMap.value = e.bumpMap),
                              (t.bumpScale.value = e.bumpScale),
                              1 === e.side && (t.bumpScale.value *= -1))
                            e.normalMap &&
                              ((t.normalMap.value = e.normalMap),
                              t.normalScale.value.copy(e.normalScale),
                              1 === e.side && t.normalScale.value.negate())
                            e.displacementMap &&
                              ((t.displacementMap.value = e.displacementMap),
                              (t.displacementScale.value = e.displacementScale),
                              (t.displacementBias.value = e.displacementBias))
                          })(t, e))
                        : e.isLineBasicMaterial
                          ? ((function (t, e) {
                              t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity)
                            })(t, e),
                            e.isLineDashedMaterial &&
                              (function (t, e) {
                                ;(t.dashSize.value = e.dashSize),
                                  (t.totalSize.value = e.dashSize + e.gapSize),
                                  (t.scale.value = e.scale)
                              })(t, e))
                          : e.isPointsMaterial
                            ? (function (t, e, n, i) {
                                t.diffuse.value.copy(e.color),
                                  (t.opacity.value = e.opacity),
                                  (t.size.value = e.size * n),
                                  (t.scale.value = 0.5 * i),
                                  e.map && (t.map.value = e.map)
                                e.alphaMap && (t.alphaMap.value = e.alphaMap)
                                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                                let s
                                e.map ? (s = e.map) : e.alphaMap && (s = e.alphaMap)
                                void 0 !== s &&
                                  (!0 === s.matrixAutoUpdate && s.updateMatrix(),
                                  t.uvTransform.value.copy(s.matrix))
                              })(t, e, s, r)
                            : e.isSpriteMaterial
                              ? (function (t, e) {
                                  t.diffuse.value.copy(e.color),
                                    (t.opacity.value = e.opacity),
                                    (t.rotation.value = e.rotation),
                                    e.map && (t.map.value = e.map)
                                  e.alphaMap && (t.alphaMap.value = e.alphaMap)
                                  e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                                  let n
                                  e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap)
                                  void 0 !== n &&
                                    (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                                    t.uvTransform.value.copy(n.matrix))
                                })(t, e)
                              : e.isShadowMaterial
                                ? (t.color.value.copy(e.color), (t.opacity.value = e.opacity))
                                : e.isShaderMaterial && (e.uniformsNeedUpdate = !1)
    }
  }
}
function Ds(t = {}) {
  const e =
      void 0 !== t.canvas
        ? t.canvas
        : (function () {
            const t = b('canvas')
            return (t.style.display = 'block'), t
          })(),
    n = void 0 !== t.context ? t.context : null,
    i = void 0 === t.depth || t.depth,
    s = void 0 === t.stencil || t.stencil,
    r = void 0 !== t.antialias && t.antialias,
    o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
    a = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
    l = void 0 !== t.powerPreference ? t.powerPreference : 'default',
    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat
  let c
  c = void 0 !== t.context ? n.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha
  let u = null,
    d = null
  const p = [],
    g = []
  ;(this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = 3e3),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = 0),
    (this.toneMappingExposure = 1)
  const f = this
  let m = !1,
    y = 0,
    v = 0,
    w = null,
    E = -1,
    M = null
  const S = new G(),
    A = new G()
  let T = null,
    I = e.width,
    R = e.height,
    L = 1,
    C = null,
    N = null
  const P = new G(0, 0, I, R),
    D = new G(0, 0, I, R)
  let O = !1
  const F = new tn()
  let B = !1,
    U = !1,
    V = null
  const k = new vt(),
    W = new _(),
    Y = new H(),
    j = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }
  function q() {
    return null === w ? L : 1
  }
  let Z,
    X,
    K,
    J,
    Q,
    $,
    tt,
    et,
    nt,
    it,
    st,
    rt,
    ot,
    at,
    lt,
    ht,
    ct,
    ut,
    dt,
    pt,
    gt,
    ft,
    mt,
    yt = n
  function xt(t, n) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i],
        r = e.getContext(s, n)
      if (null !== r) return r
    }
    return null
  }
  try {
    const t = {
      alpha: !0,
      depth: i,
      stencil: s,
      antialias: r,
      premultipliedAlpha: o,
      preserveDrawingBuffer: a,
      powerPreference: l,
      failIfMajorPerformanceCaveat: h
    }
    if (
      ('setAttribute' in e && e.setAttribute('data-engine', 'three.js r139dev'),
      e.addEventListener('webglcontextlost', Et, !1),
      e.addEventListener('webglcontextrestored', bt, !1),
      null === yt)
    ) {
      const e = ['webgl2', 'webgl', 'experimental-webgl']
      if ((!0 === f.isWebGL1Renderer && e.shift(), (yt = xt(e, t)), null === yt))
        throw xt(e)
          ? new Error('Error creating WebGL context with your selected attributes.')
          : new Error('Error creating WebGL context.')
    }
    void 0 === yt.getShaderPrecisionFormat &&
      (yt.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 }
      })
  } catch (t) {
    throw (console.error('THREE.WebGLRenderer: ' + t.message), t)
  }
  function _t() {
    ;(Z = new Rn(yt)),
      (X = new un(yt, Z, t)),
      Z.init(X),
      (ft = new As(yt, Z, X)),
      (K = new Ms(yt, Z, X)),
      (J = new Nn()),
      (Q = new cs()),
      ($ = new Ss(yt, Z, K, Q, X, ft, J)),
      (tt = new pn(f)),
      (et = new In(f)),
      (nt = new nn(yt, X)),
      (mt = new hn(yt, Z, nt, X)),
      (it = new Ln(yt, nt, J, mt)),
      (st = new Gn(yt, it, nt, J)),
      (dt = new Fn(yt, X, $)),
      (ht = new dn(Q)),
      (rt = new hs(f, tt, et, Z, X, mt, ht)),
      (ot = new Ps(f, Q)),
      (at = new gs()),
      (lt = new _s(Z, X)),
      (ut = new ln(f, tt, K, st, c, o)),
      (ct = new bs(f, st, X)),
      (pt = new cn(yt, Z, J, X)),
      (gt = new Cn(yt, Z, J, X)),
      (J.programs = rt.programs),
      (f.capabilities = X),
      (f.extensions = Z),
      (f.properties = Q),
      (f.renderLists = at),
      (f.shadowMap = ct),
      (f.state = K),
      (f.info = J)
  }
  _t()
  const wt = new Ns(f, yt)
  function Et(t) {
    t.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (m = !0)
  }
  function bt() {
    console.log('THREE.WebGLRenderer: Context Restored.'), (m = !1)
    const t = J.autoReset,
      e = ct.enabled,
      n = ct.autoUpdate,
      i = ct.needsUpdate,
      s = ct.type
    _t(),
      (J.autoReset = t),
      (ct.enabled = e),
      (ct.autoUpdate = n),
      (ct.needsUpdate = i),
      (ct.type = s)
  }
  function Mt(t) {
    const e = t.target
    e.removeEventListener('dispose', Mt),
      (function (t) {
        ;(function (t) {
          const e = Q.get(t).programs
          void 0 !== e &&
            (e.forEach(function (t) {
              rt.releaseProgram(t)
            }),
            t.isShaderMaterial && rt.releaseShaderCache(t))
        })(t),
          Q.remove(t)
      })(e)
  }
  ;(this.xr = wt),
    (this.getContext = function () {
      return yt
    }),
    (this.getContextAttributes = function () {
      return yt.getContextAttributes()
    }),
    (this.forceContextLoss = function () {
      const t = Z.get('WEBGL_lose_context')
      t && t.loseContext()
    }),
    (this.forceContextRestore = function () {
      const t = Z.get('WEBGL_lose_context')
      t && t.restoreContext()
    }),
    (this.getPixelRatio = function () {
      return L
    }),
    (this.setPixelRatio = function (t) {
      void 0 !== t && ((L = t), this.setSize(I, R, !1))
    }),
    (this.getSize = function (t) {
      return t.set(I, R)
    }),
    (this.setSize = function (t, n, i) {
      wt.isPresenting
        ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.")
        : ((I = t),
          (R = n),
          (e.width = Math.floor(t * L)),
          (e.height = Math.floor(n * L)),
          !1 !== i && ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
          this.setViewport(0, 0, t, n))
    }),
    (this.getDrawingBufferSize = function (t) {
      return t.set(I * L, R * L).floor()
    }),
    (this.setDrawingBufferSize = function (t, n, i) {
      ;(I = t),
        (R = n),
        (L = i),
        (e.width = Math.floor(t * i)),
        (e.height = Math.floor(n * i)),
        this.setViewport(0, 0, t, n)
    }),
    (this.getCurrentViewport = function (t) {
      return t.copy(S)
    }),
    (this.getViewport = function (t) {
      return t.copy(P)
    }),
    (this.setViewport = function (t, e, n, i) {
      t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
        K.viewport(S.copy(P).multiplyScalar(L).floor())
    }),
    (this.getScissor = function (t) {
      return t.copy(D)
    }),
    (this.setScissor = function (t, e, n, i) {
      t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i),
        K.scissor(A.copy(D).multiplyScalar(L).floor())
    }),
    (this.getScissorTest = function () {
      return O
    }),
    (this.setScissorTest = function (t) {
      K.setScissorTest((O = t))
    }),
    (this.setOpaqueSort = function (t) {
      C = t
    }),
    (this.setTransparentSort = function (t) {
      N = t
    }),
    (this.getClearColor = function (t) {
      return t.copy(ut.getClearColor())
    }),
    (this.setClearColor = function () {
      ut.setClearColor.apply(ut, arguments)
    }),
    (this.getClearAlpha = function () {
      return ut.getClearAlpha()
    }),
    (this.setClearAlpha = function () {
      ut.setClearAlpha.apply(ut, arguments)
    }),
    (this.clear = function (t = !0, e = !0, n = !0) {
      let i = 0
      t && (i |= 16384), e && (i |= 256), n && (i |= 1024), yt.clear(i)
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1)
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1)
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0)
    }),
    (this.dispose = function () {
      e.removeEventListener('webglcontextlost', Et, !1),
        e.removeEventListener('webglcontextrestored', bt, !1),
        at.dispose(),
        lt.dispose(),
        Q.dispose(),
        tt.dispose(),
        et.dispose(),
        st.dispose(),
        mt.dispose(),
        rt.dispose(),
        wt.dispose(),
        wt.removeEventListener('sessionstart', At),
        wt.removeEventListener('sessionend', Tt),
        V && (V.dispose(), (V = null)),
        It.stop()
    }),
    (this.renderBufferDirect = function (t, e, n, i, s, r) {
      null === e && (e = j)
      const o = s.isMesh && s.matrixWorld.determinant() < 0,
        a = (function (t, e, n, i, s) {
          !0 !== e.isScene && (e = j)
          $.resetTextureUnits()
          const r = e.fog,
            o = i.isMeshStandardMaterial ? e.environment : null,
            a =
              null === w ? f.outputEncoding : !0 === w.isXRRenderTarget ? w.texture.encoding : 3e3,
            l = (i.isMeshStandardMaterial ? et : tt).get(i.envMap || o),
            h = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
            c = !!i.normalMap && !!n.attributes.tangent,
            u = !!n.morphAttributes.position,
            p = !!n.morphAttributes.normal,
            g = !!n.morphAttributes.color,
            m = i.toneMapped ? f.toneMapping : 0,
            y = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
            x = void 0 !== y ? y.length : 0,
            v = Q.get(i),
            _ = d.state.lights
          if (!0 === B && (!0 === U || t !== M)) {
            const e = t === M && i.id === E
            ht.setState(i, t, e)
          }
          let b = !1
          i.version === v.__version
            ? (v.needsLights && v.lightsStateVersion !== _.state.version) ||
              v.outputEncoding !== a ||
              (s.isInstancedMesh && !1 === v.instancing)
              ? (b = !0)
              : s.isInstancedMesh || !0 !== v.instancing
                ? s.isSkinnedMesh && !1 === v.skinning
                  ? (b = !0)
                  : s.isSkinnedMesh || !0 !== v.skinning
                    ? v.envMap !== l || (i.fog && v.fog !== r)
                      ? (b = !0)
                      : void 0 === v.numClippingPlanes ||
                          (v.numClippingPlanes === ht.numPlanes &&
                            v.numIntersection === ht.numIntersection)
                        ? (v.vertexAlphas !== h ||
                            v.vertexTangents !== c ||
                            v.morphTargets !== u ||
                            v.morphNormals !== p ||
                            v.morphColors !== g ||
                            v.toneMapping !== m ||
                            (!0 === X.isWebGL2 && v.morphTargetsCount !== x)) &&
                          (b = !0)
                        : (b = !0)
                    : (b = !0)
                : (b = !0)
            : ((b = !0), (v.__version = i.version))
          let S = v.currentProgram
          !0 === b && (S = Pt(i, e, s))
          let A = !1,
            T = !1,
            I = !1
          const C = S.getUniforms(),
            N = v.uniforms
          K.useProgram(S.program) && ((A = !0), (T = !0), (I = !0))
          i.id !== E && ((E = i.id), (T = !0))
          if (A || M !== t) {
            if (
              (C.setValue(yt, 'projectionMatrix', t.projectionMatrix),
              X.logarithmicDepthBuffer &&
                C.setValue(yt, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
              M !== t && ((M = t), (T = !0), (I = !0)),
              i.isShaderMaterial ||
                i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshStandardMaterial ||
                i.envMap)
            ) {
              const e = C.map.cameraPosition
              void 0 !== e && e.setValue(yt, Y.setFromMatrixPosition(t.matrixWorld))
            }
            ;(i.isMeshPhongMaterial ||
              i.isMeshToonMaterial ||
              i.isMeshLambertMaterial ||
              i.isMeshBasicMaterial ||
              i.isMeshStandardMaterial ||
              i.isShaderMaterial) &&
              C.setValue(yt, 'isOrthographic', !0 === t.isOrthographicCamera),
              (i.isMeshPhongMaterial ||
                i.isMeshToonMaterial ||
                i.isMeshLambertMaterial ||
                i.isMeshBasicMaterial ||
                i.isMeshStandardMaterial ||
                i.isShaderMaterial ||
                i.isShadowMaterial ||
                s.isSkinnedMesh) &&
                C.setValue(yt, 'viewMatrix', t.matrixWorldInverse)
          }
          if (s.isSkinnedMesh) {
            C.setOptional(yt, s, 'bindMatrix'), C.setOptional(yt, s, 'bindMatrixInverse')
            const t = s.skeleton
            t &&
              (X.floatVertexTextures
                ? (null === t.boneTexture && t.computeBoneTexture(),
                  C.setValue(yt, 'boneTexture', t.boneTexture, $),
                  C.setValue(yt, 'boneTextureSize', t.boneTextureSize))
                : C.setOptional(yt, t, 'boneMatrices'))
          }
          const P = n.morphAttributes
          ;(void 0 !== P.position ||
            void 0 !== P.normal ||
            (void 0 !== P.color && !0 === X.isWebGL2)) &&
            dt.update(s, n, i, S)
          ;(T || v.receiveShadow !== s.receiveShadow) &&
            ((v.receiveShadow = s.receiveShadow), C.setValue(yt, 'receiveShadow', s.receiveShadow))
          T &&
            (C.setValue(yt, 'toneMappingExposure', f.toneMappingExposure),
            v.needsLights &&
              ((O = I),
              ((D = N).ambientLightColor.needsUpdate = O),
              (D.lightProbe.needsUpdate = O),
              (D.directionalLights.needsUpdate = O),
              (D.directionalLightShadows.needsUpdate = O),
              (D.pointLights.needsUpdate = O),
              (D.pointLightShadows.needsUpdate = O),
              (D.spotLights.needsUpdate = O),
              (D.spotLightShadows.needsUpdate = O),
              (D.rectAreaLights.needsUpdate = O),
              (D.hemisphereLights.needsUpdate = O)),
            r && i.fog && ot.refreshFogUniforms(N, r),
            ot.refreshMaterialUniforms(N, i, L, R, V),
            Vi.upload(yt, v.uniformsList, N, $))
          var D, O
          i.isShaderMaterial &&
            !0 === i.uniformsNeedUpdate &&
            (Vi.upload(yt, v.uniformsList, N, $), (i.uniformsNeedUpdate = !1))
          i.isSpriteMaterial && C.setValue(yt, 'center', s.center)
          return (
            C.setValue(yt, 'modelViewMatrix', s.modelViewMatrix),
            C.setValue(yt, 'normalMatrix', s.normalMatrix),
            C.setValue(yt, 'modelMatrix', s.matrixWorld),
            S
          )
        })(t, e, n, i, s)
      K.setMaterial(i, o)
      let l = n.index
      const h = n.attributes.position
      if (null === l) {
        if (void 0 === h || 0 === h.count) return
      } else if (0 === l.count) return
      let c,
        u = 1
      !0 === i.wireframe && ((l = it.getWireframeAttribute(n)), (u = 2)), mt.setup(s, i, a, n, l)
      let p = pt
      null !== l && ((c = nt.get(l)), (p = gt), p.setIndex(c))
      const g = null !== l ? l.count : h.count,
        m = n.drawRange.start * u,
        y = n.drawRange.count * u,
        x = null !== r ? r.start * u : 0,
        v = null !== r ? r.count * u : 1 / 0,
        _ = Math.max(m, x),
        b = Math.min(g, m + y, x + v) - 1,
        S = Math.max(0, b - _ + 1)
      if (0 !== S) {
        if (s.isMesh)
          !0 === i.wireframe
            ? (K.setLineWidth(i.wireframeLinewidth * q()), p.setMode(1))
            : p.setMode(4)
        else if (s.isLine) {
          let t = i.linewidth
          void 0 === t && (t = 1),
            K.setLineWidth(t * q()),
            s.isLineSegments ? p.setMode(1) : s.isLineLoop ? p.setMode(2) : p.setMode(3)
        } else s.isPoints ? p.setMode(0) : s.isSprite && p.setMode(4)
        if (s.isInstancedMesh) p.renderInstances(_, S, s.count)
        else if (n.isInstancedBufferGeometry) {
          const t = Math.min(n.instanceCount, n._maxInstanceCount)
          p.renderInstances(_, S, t)
        } else p.render(_, S)
      }
    }),
    (this.compile = function (t, e) {
      ;(d = lt.get(t)),
        d.init(),
        g.push(d),
        t.traverseVisible(function (t) {
          t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
        }),
        d.setupLights(f.physicallyCorrectLights),
        t.traverse(function (e) {
          const n = e.material
          if (n)
            if (Array.isArray(n))
              for (let i = 0; i < n.length; i++) {
                Pt(n[i], t, e)
              }
            else Pt(n, t, e)
        }),
        g.pop(),
        (d = null)
    })
  let St = null
  function At() {
    It.stop()
  }
  function Tt() {
    It.start()
  }
  const It = new en()
  function Rt(t, e, n, i) {
    if (!1 === t.visible) return
    if (t.layers.test(e.layers))
      if (t.isGroup) n = t.renderOrder
      else if (t.isLOD) !0 === t.autoUpdate && t.update(e)
      else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t)
      else if (t.isSprite) {
        if (!t.frustumCulled || F.intersectsSprite(t)) {
          i && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k)
          const e = st.update(t),
            s = t.material
          s.visible && u.push(t, e, s, n, Y.z, null)
        }
      } else if (
        (t.isMesh || t.isLine || t.isPoints) &&
        (t.isSkinnedMesh &&
          t.skeleton.frame !== J.render.frame &&
          (t.skeleton.update(), (t.skeleton.frame = J.render.frame)),
        !t.frustumCulled || F.intersectsObject(t))
      ) {
        i && Y.setFromMatrixPosition(t.matrixWorld).applyMatrix4(k)
        const e = st.update(t),
          s = t.material
        if (Array.isArray(s)) {
          const i = e.groups
          for (let r = 0, o = i.length; r < o; r++) {
            const o = i[r],
              a = s[o.materialIndex]
            a && a.visible && u.push(t, e, a, n, Y.z, o)
          }
        } else s.visible && u.push(t, e, s, n, Y.z, null)
      }
    const s = t.children
    for (let t = 0, r = s.length; t < r; t++) Rt(s[t], e, n, i)
  }
  function Lt(t, e, n, i) {
    const s = t.opaque,
      o = t.transmissive,
      a = t.transparent
    d.setupLightsView(n),
      o.length > 0 &&
        (function (t, e, n) {
          const i = X.isWebGL2
          null === V &&
            (V = new z(1, 1, {
              generateMipmaps: !0,
              type: null !== ft.convert(1016) ? 1016 : 1009,
              minFilter: 1008,
              samples: i && !0 === r ? 4 : 0
            }))
          f.getDrawingBufferSize(W), i ? V.setSize(W.x, W.y) : V.setSize(x(W.x), x(W.y))
          const s = f.getRenderTarget()
          f.setRenderTarget(V), f.clear()
          const o = f.toneMapping
          ;(f.toneMapping = 0),
            Ct(t, e, n),
            (f.toneMapping = o),
            $.updateMultisampleRenderTarget(V),
            $.updateRenderTargetMipmap(V),
            f.setRenderTarget(s)
        })(s, e, n),
      i && K.viewport(S.copy(i)),
      s.length > 0 && Ct(s, e, n),
      o.length > 0 && Ct(o, e, n),
      a.length > 0 && Ct(a, e, n),
      K.buffers.depth.setTest(!0),
      K.buffers.depth.setMask(!0),
      K.buffers.color.setMask(!0),
      K.setPolygonOffset(!1)
  }
  function Ct(t, e, n) {
    const i = !0 === e.isScene ? e.overrideMaterial : null
    for (let s = 0, r = t.length; s < r; s++) {
      const r = t[s],
        o = r.object,
        a = r.geometry,
        l = null === i ? r.material : i,
        h = r.group
      o.layers.test(n.layers) && Nt(o, e, n, a, l, h)
    }
  }
  function Nt(t, e, n, i, s, r) {
    t.onBeforeRender(f, e, n, i, s, r),
      t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
      t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
      s.onBeforeRender(f, e, n, i, t, r),
      !0 === s.transparent && 2 === s.side
        ? ((s.side = 1),
          (s.needsUpdate = !0),
          f.renderBufferDirect(n, e, i, s, t, r),
          (s.side = 0),
          (s.needsUpdate = !0),
          f.renderBufferDirect(n, e, i, s, t, r),
          (s.side = 2))
        : f.renderBufferDirect(n, e, i, s, t, r),
      t.onAfterRender(f, e, n, i, s, r)
  }
  function Pt(t, e, n) {
    !0 !== e.isScene && (e = j)
    const i = Q.get(t),
      s = d.state.lights,
      r = d.state.shadowsArray,
      o = s.state.version,
      a = rt.getParameters(t, s.state, r, e, n),
      l = rt.getProgramCacheKey(a)
    let h = i.programs
    ;(i.environment = t.isMeshStandardMaterial ? e.environment : null),
      (i.fog = e.fog),
      (i.envMap = (t.isMeshStandardMaterial ? et : tt).get(t.envMap || i.environment)),
      void 0 === h && (t.addEventListener('dispose', Mt), (h = new Map()), (i.programs = h))
    let c = h.get(l)
    if (void 0 !== c) {
      if (i.currentProgram === c && i.lightsStateVersion === o) return Dt(t, a), c
    } else
      (a.uniforms = rt.getUniforms(t)),
        t.onBuild(n, a, f),
        t.onBeforeCompile(a, f),
        (c = rt.acquireProgram(a, l)),
        h.set(l, c),
        (i.uniforms = a.uniforms)
    const u = i.uniforms
    ;((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
      (u.clippingPlanes = ht.uniform),
      Dt(t, a),
      (i.needsLights = (function (t) {
        return (
          t.isMeshLambertMaterial ||
          t.isMeshToonMaterial ||
          t.isMeshPhongMaterial ||
          t.isMeshStandardMaterial ||
          t.isShadowMaterial ||
          (t.isShaderMaterial && !0 === t.lights)
        )
      })(t)),
      (i.lightsStateVersion = o),
      i.needsLights &&
        ((u.ambientLightColor.value = s.state.ambient),
        (u.lightProbe.value = s.state.probe),
        (u.directionalLights.value = s.state.directional),
        (u.directionalLightShadows.value = s.state.directionalShadow),
        (u.spotLights.value = s.state.spot),
        (u.spotLightShadows.value = s.state.spotShadow),
        (u.rectAreaLights.value = s.state.rectArea),
        (u.ltc_1.value = s.state.rectAreaLTC1),
        (u.ltc_2.value = s.state.rectAreaLTC2),
        (u.pointLights.value = s.state.point),
        (u.pointLightShadows.value = s.state.pointShadow),
        (u.hemisphereLights.value = s.state.hemi),
        (u.directionalShadowMap.value = s.state.directionalShadowMap),
        (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
        (u.spotShadowMap.value = s.state.spotShadowMap),
        (u.spotShadowMatrix.value = s.state.spotShadowMatrix),
        (u.pointShadowMap.value = s.state.pointShadowMap),
        (u.pointShadowMatrix.value = s.state.pointShadowMatrix))
    const p = c.getUniforms(),
      g = Vi.seqWithValue(p.seq, u)
    return (i.currentProgram = c), (i.uniformsList = g), c
  }
  function Dt(t, e) {
    const n = Q.get(t)
    ;(n.outputEncoding = e.outputEncoding),
      (n.instancing = e.instancing),
      (n.skinning = e.skinning),
      (n.morphTargets = e.morphTargets),
      (n.morphNormals = e.morphNormals),
      (n.morphColors = e.morphColors),
      (n.morphTargetsCount = e.morphTargetsCount),
      (n.numClippingPlanes = e.numClippingPlanes),
      (n.numIntersection = e.numClipIntersection),
      (n.vertexAlphas = e.vertexAlphas),
      (n.vertexTangents = e.vertexTangents),
      (n.toneMapping = e.toneMapping)
  }
  It.setAnimationLoop(function (t) {
    St && St(t)
  }),
    'undefined' != typeof window && It.setContext(window),
    (this.setAnimationLoop = function (t) {
      ;(St = t), wt.setAnimationLoop(t), null === t ? It.stop() : It.start()
    }),
    wt.addEventListener('sessionstart', At),
    wt.addEventListener('sessionend', Tt),
    (this.render = function (t, e) {
      if (void 0 !== e && !0 !== e.isCamera)
        return void console.error(
          'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
        )
      if (!0 === m) return
      !0 === t.autoUpdate && t.updateMatrixWorld(),
        null === e.parent && e.updateMatrixWorld(),
        !0 === wt.enabled &&
          !0 === wt.isPresenting &&
          (!0 === wt.cameraAutoUpdate && wt.updateCamera(e), (e = wt.getCamera())),
        !0 === t.isScene && t.onBeforeRender(f, t, e, w),
        (d = lt.get(t, g.length)),
        d.init(),
        g.push(d),
        k.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        F.setFromProjectionMatrix(k),
        (U = this.localClippingEnabled),
        (B = ht.init(this.clippingPlanes, U, e)),
        (u = at.get(t, p.length)),
        u.init(),
        p.push(u),
        Rt(t, e, 0, f.sortObjects),
        u.finish(),
        !0 === f.sortObjects && u.sort(C, N),
        !0 === B && ht.beginShadows()
      const n = d.state.shadowsArray
      if (
        (ct.render(n, t, e),
        !0 === B && ht.endShadows(),
        !0 === this.info.autoReset && this.info.reset(),
        ut.render(u, t),
        d.setupLights(f.physicallyCorrectLights),
        e.isArrayCamera)
      ) {
        const n = e.cameras
        for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e]
          Lt(u, t, i, i.viewport)
        }
      } else Lt(u, t, e)
      null !== w && ($.updateMultisampleRenderTarget(w), $.updateRenderTargetMipmap(w)),
        !0 === t.isScene && t.onAfterRender(f, t, e),
        mt.resetDefaultState(),
        (E = -1),
        (M = null),
        g.pop(),
        (d = g.length > 0 ? g[g.length - 1] : null),
        p.pop(),
        (u = p.length > 0 ? p[p.length - 1] : null)
    }),
    (this.getActiveCubeFace = function () {
      return y
    }),
    (this.getActiveMipmapLevel = function () {
      return v
    }),
    (this.getRenderTarget = function () {
      return w
    }),
    (this.setRenderTargetTextures = function (t, e, n) {
      ;(Q.get(t.texture).__webglTexture = e), (Q.get(t.depthTexture).__webglTexture = n)
      const i = Q.get(t)
      ;(i.__hasExternalTextures = !0),
        i.__hasExternalTextures &&
          ((i.__autoAllocateDepthBuffer = void 0 === n),
          i.__autoAllocateDepthBuffer ||
            (!0 === Z.has('WEBGL_multisampled_render_to_texture') &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
              ),
              (i.__useRenderToTexture = !1))))
    }),
    (this.setRenderTargetFramebuffer = function (t, e) {
      const n = Q.get(t)
      ;(n.__webglFramebuffer = e), (n.__useDefaultFramebuffer = void 0 === e)
    }),
    (this.setRenderTarget = function (t, e = 0, n = 0) {
      ;(w = t), (y = e), (v = n)
      let i = !0
      if (t) {
        const e = Q.get(t)
        void 0 !== e.__useDefaultFramebuffer
          ? (K.bindFramebuffer(36160, null), (i = !1))
          : void 0 === e.__webglFramebuffer
            ? $.setupRenderTarget(t)
            : e.__hasExternalTextures &&
              $.rebindTextures(
                t,
                Q.get(t.texture).__webglTexture,
                Q.get(t.depthTexture).__webglTexture
              )
      }
      let s = null,
        r = !1,
        o = !1
      if (t) {
        const n = t.texture
        ;(n.isData3DTexture || n.isDataArrayTexture) && (o = !0)
        const i = Q.get(t).__webglFramebuffer
        t.isWebGLCubeRenderTarget
          ? ((s = i[e]), (r = !0))
          : (s =
              X.isWebGL2 && t.samples > 0 && !1 === $.useMultisampledRTT(t)
                ? Q.get(t).__webglMultisampledFramebuffer
                : i),
          S.copy(t.viewport),
          A.copy(t.scissor),
          (T = t.scissorTest)
      } else S.copy(P).multiplyScalar(L).floor(), A.copy(D).multiplyScalar(L).floor(), (T = O)
      if (
        (K.bindFramebuffer(36160, s) && X.drawBuffers && i && K.drawBuffers(t, s),
        K.viewport(S),
        K.scissor(A),
        K.setScissorTest(T),
        r)
      ) {
        const i = Q.get(t.texture)
        yt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
      } else if (o) {
        const i = Q.get(t.texture),
          s = e || 0
        yt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, s)
      }
      E = -1
    }),
    (this.readRenderTargetPixels = function (t, e, n, i, s, r, o) {
      if (!t || !t.isWebGLRenderTarget)
        return void console.error(
          'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
        )
      let a = Q.get(t).__webglFramebuffer
      if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
        K.bindFramebuffer(36160, a)
        try {
          const o = t.texture,
            a = o.format,
            l = o.type
          if (1023 !== a && ft.convert(a) !== yt.getParameter(35739))
            return void console.error(
              'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
            )
          const h =
            1016 === l &&
            (Z.has('EXT_color_buffer_half_float') ||
              (X.isWebGL2 && Z.has('EXT_color_buffer_float')))
          if (
            !(
              1009 === l ||
              ft.convert(l) === yt.getParameter(35738) ||
              (1015 === l &&
                (X.isWebGL2 || Z.has('OES_texture_float') || Z.has('WEBGL_color_buffer_float'))) ||
              h
            )
          )
            return void console.error(
              'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
            )
          36053 === yt.checkFramebufferStatus(36160)
            ? e >= 0 &&
              e <= t.width - i &&
              n >= 0 &&
              n <= t.height - s &&
              yt.readPixels(e, n, i, s, ft.convert(a), ft.convert(l), r)
            : console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
              )
        } finally {
          const t = null !== w ? Q.get(w).__webglFramebuffer : null
          K.bindFramebuffer(36160, t)
        }
      }
    }),
    (this.copyFramebufferToTexture = function (t, e, n = 0) {
      if (!0 !== e.isFramebufferTexture)
        return void console.error(
          'THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.'
        )
      const i = Math.pow(2, -n),
        s = Math.floor(e.image.width * i),
        r = Math.floor(e.image.height * i)
      $.setTexture2D(e, 0), yt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, s, r), K.unbindTexture()
    }),
    (this.copyTextureToTexture = function (t, e, n, i = 0) {
      const s = e.image.width,
        r = e.image.height,
        o = ft.convert(n.format),
        a = ft.convert(n.type)
      $.setTexture2D(n, 0),
        yt.pixelStorei(37440, n.flipY),
        yt.pixelStorei(37441, n.premultiplyAlpha),
        yt.pixelStorei(3317, n.unpackAlignment),
        e.isDataTexture
          ? yt.texSubImage2D(3553, i, t.x, t.y, s, r, o, a, e.image.data)
          : e.isCompressedTexture
            ? yt.compressedTexSubImage2D(
                3553,
                i,
                t.x,
                t.y,
                e.mipmaps[0].width,
                e.mipmaps[0].height,
                o,
                e.mipmaps[0].data
              )
            : yt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
        0 === i && n.generateMipmaps && yt.generateMipmap(3553),
        K.unbindTexture()
    }),
    (this.copyTextureToTexture3D = function (t, e, n, i, s = 0) {
      if (f.isWebGL1Renderer)
        return void console.warn(
          'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
        )
      const r = t.max.x - t.min.x + 1,
        o = t.max.y - t.min.y + 1,
        a = t.max.z - t.min.z + 1,
        l = ft.convert(i.format),
        h = ft.convert(i.type)
      let c
      if (i.isData3DTexture) $.setTexture3D(i, 0), (c = 32879)
      else {
        if (!i.isDataArrayTexture)
          return void console.warn(
            'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
          )
        $.setTexture2DArray(i, 0), (c = 35866)
      }
      yt.pixelStorei(37440, i.flipY),
        yt.pixelStorei(37441, i.premultiplyAlpha),
        yt.pixelStorei(3317, i.unpackAlignment)
      const u = yt.getParameter(3314),
        d = yt.getParameter(32878),
        p = yt.getParameter(3316),
        g = yt.getParameter(3315),
        m = yt.getParameter(32877),
        y = n.isCompressedTexture ? n.mipmaps[0] : n.image
      yt.pixelStorei(3314, y.width),
        yt.pixelStorei(32878, y.height),
        yt.pixelStorei(3316, t.min.x),
        yt.pixelStorei(3315, t.min.y),
        yt.pixelStorei(32877, t.min.z),
        n.isDataTexture || n.isData3DTexture
          ? yt.texSubImage3D(c, s, e.x, e.y, e.z, r, o, a, l, h, y.data)
          : n.isCompressedTexture
            ? (console.warn(
                'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
              ),
              yt.compressedTexSubImage3D(c, s, e.x, e.y, e.z, r, o, a, l, y.data))
            : yt.texSubImage3D(c, s, e.x, e.y, e.z, r, o, a, l, h, y),
        yt.pixelStorei(3314, u),
        yt.pixelStorei(32878, d),
        yt.pixelStorei(3316, p),
        yt.pixelStorei(3315, g),
        yt.pixelStorei(32877, m),
        0 === s && i.generateMipmaps && yt.generateMipmap(c),
        K.unbindTexture()
    }),
    (this.initTexture = function (t) {
      $.setTexture2D(t, 0), K.unbindTexture()
    }),
    (this.resetState = function () {
      ;(y = 0), (v = 0), (w = null), K.reset(), mt.reset()
    }),
    'undefined' != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
}
Ds.prototype.isWebGLRenderer = !0
;(class extends Ds {}).prototype.isWebGL1Renderer = !0
class Os extends Wt {
  constructor() {
    super(),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      'undefined' != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }))
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      null !== t.background && (this.background = t.background.clone()),
      null !== t.environment && (this.environment = t.environment.clone()),
      null !== t.fog && (this.fog = t.fog.clone()),
      null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.autoUpdate = t.autoUpdate),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
  }
}
Os.prototype.isScene = !0
class Fs {
  constructor(t, e) {
    ;(this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.usage = 35044),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = d())
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    !0 === t && this.version++
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.stride), (n *= e.stride)
    for (let i = 0, s = this.stride; i < s; i++) this.array[t + i] = e.array[n + i]
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  clone(t) {
    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = d()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
      n = new this.constructor(e, this.stride)
    return n.setUsage(this.usage), n
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  toJSON(t) {
    return (
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = d()),
      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      }
    )
  }
}
Fs.prototype.isInterleavedBuffer = !0
const Gs = new H()
class zs {
  constructor(t, e, n, i = !1) {
    ;(this.name = ''),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = !0 === i)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      (Gs.x = this.getX(e)),
        (Gs.y = this.getY(e)),
        (Gs.z = this.getZ(e)),
        Gs.applyMatrix4(t),
        this.setXYZ(e, Gs.x, Gs.y, Gs.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (Gs.x = this.getX(e)),
        (Gs.y = this.getY(e)),
        (Gs.z = this.getZ(e)),
        Gs.applyNormalMatrix(t),
        this.setXYZ(e, Gs.x, Gs.y, Gs.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (Gs.x = this.getX(e)),
        (Gs.y = this.getY(e)),
        (Gs.z = this.getZ(e)),
        Gs.transformDirection(t),
        this.setXYZ(e, Gs.x, Gs.y, Gs.z)
    return this
  }
  setX(t, e) {
    return (this.data.array[t * this.data.stride + this.offset] = e), this
  }
  setY(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this
  }
  setZ(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this
  }
  setW(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this
  }
  getX(t) {
    return this.data.array[t * this.data.stride + this.offset]
  }
  getY(t) {
    return this.data.array[t * this.data.stride + this.offset + 1]
  }
  getZ(t) {
    return this.data.array[t * this.data.stride + this.offset + 2]
  }
  getW(t) {
    return this.data.array[t * this.data.stride + this.offset + 3]
  }
  setXY(t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, s) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      (this.data.array[t + 3] = s),
      this
    )
  }
  clone(t) {
    if (void 0 === t) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.'
      )
      const t = []
      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
      }
      return new ae(new this.array.constructor(t), this.itemSize, this.normalized)
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
      new zs(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    )
  }
  toJSON(t) {
    if (void 0 === t) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.'
      )
      const t = []
      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset
        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      }
    }
    return (
      void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
      void 0 === t.interleavedBuffers[this.data.uuid] &&
        (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      }
    )
  }
}
zs.prototype.isInterleavedBufferAttribute = !0
class Bs extends ie {
  constructor(t) {
    super(),
      (this.type = 'SpriteMaterial'),
      (this.color = new L(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    )
  }
}
let Us
Bs.prototype.isSpriteMaterial = !0
const Vs = new H(),
  Hs = new H(),
  ks = new H(),
  Ws = new _(),
  Ys = new _(),
  js = new vt(),
  qs = new H(),
  Zs = new H(),
  Xs = new H(),
  Ks = new _(),
  Js = new _(),
  Qs = new _()
class $s extends Wt {
  constructor(t) {
    if ((super(), (this.type = 'Sprite'), void 0 === Us)) {
      Us = new xe()
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1
        ]),
        e = new Fs(t, 5)
      Us.setIndex([0, 1, 2, 0, 2, 3]),
        Us.setAttribute('position', new zs(e, 3, 0, !1)),
        Us.setAttribute('uv', new zs(e, 2, 3, !1))
    }
    ;(this.geometry = Us),
      (this.material = void 0 !== t ? t : new Bs()),
      (this.center = new _(0.5, 0.5))
  }
  raycast(t, e) {
    null === t.camera &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Hs.setFromMatrixScale(this.matrixWorld),
      js.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
      ks.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        !1 === this.material.sizeAttenuation &&
        Hs.multiplyScalar(-ks.z)
    const n = this.material.rotation
    let i, s
    0 !== n && ((s = Math.cos(n)), (i = Math.sin(n)))
    const r = this.center
    tr(qs.set(-0.5, -0.5, 0), ks, r, Hs, i, s),
      tr(Zs.set(0.5, -0.5, 0), ks, r, Hs, i, s),
      tr(Xs.set(0.5, 0.5, 0), ks, r, Hs, i, s),
      Ks.set(0, 0),
      Js.set(1, 0),
      Qs.set(1, 1)
    let o = t.ray.intersectTriangle(qs, Zs, Xs, !1, Vs)
    if (
      null === o &&
      (tr(Zs.set(-0.5, 0.5, 0), ks, r, Hs, i, s),
      Js.set(0, 1),
      (o = t.ray.intersectTriangle(qs, Xs, Zs, !1, Vs)),
      null === o)
    )
      return
    const a = t.ray.origin.distanceTo(Vs)
    a < t.near ||
      a > t.far ||
      e.push({
        distance: a,
        point: Vs.clone(),
        uv: ee.getUV(Vs, qs, Zs, Xs, Ks, Js, Qs, new _()),
        face: null,
        object: this
      })
  }
  copy(t) {
    return (
      super.copy(t),
      void 0 !== t.center && this.center.copy(t.center),
      (this.material = t.material),
      this
    )
  }
}
function tr(t, e, n, i, s, r) {
  Ws.subVectors(t, n).addScalar(0.5).multiply(i),
    void 0 !== s ? ((Ys.x = r * Ws.x - s * Ws.y), (Ys.y = s * Ws.x + r * Ws.y)) : Ys.copy(Ws),
    t.copy(e),
    (t.x += Ys.x),
    (t.y += Ys.y),
    t.applyMatrix4(js)
}
$s.prototype.isSprite = !0
const er = new H(),
  nr = new G(),
  ir = new G(),
  sr = new H(),
  rr = new vt()
class or extends Fe {
  constructor(t, e) {
    super(t, e),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = 'attached'),
      (this.bindMatrix = new vt()),
      (this.bindMatrixInverse = new vt())
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      this
    )
  }
  bind(t, e) {
    ;(this.skeleton = t),
      void 0 === e &&
        (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.copy(e).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const t = new G(),
      e = this.geometry.attributes.skinWeight
    for (let n = 0, i = e.count; n < i; n++) {
      ;(t.x = e.getX(n)), (t.y = e.getY(n)), (t.z = e.getZ(n)), (t.w = e.getW(n))
      const i = 1 / t.manhattanLength()
      i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      'attached' === this.bindMode
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : 'detached' === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode)
  }
  boneTransform(t, e) {
    const n = this.skeleton,
      i = this.geometry
    nr.fromBufferAttribute(i.attributes.skinIndex, t),
      ir.fromBufferAttribute(i.attributes.skinWeight, t),
      er.copy(e).applyMatrix4(this.bindMatrix),
      e.set(0, 0, 0)
    for (let t = 0; t < 4; t++) {
      const i = ir.getComponent(t)
      if (0 !== i) {
        const s = nr.getComponent(t)
        rr.multiplyMatrices(n.bones[s].matrixWorld, n.boneInverses[s]),
          e.addScaledVector(sr.copy(er).applyMatrix4(rr), i)
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse)
  }
}
or.prototype.isSkinnedMesh = !0
class ar extends Wt {
  constructor() {
    super(), (this.type = 'Bone')
  }
}
ar.prototype.isBone = !0
class lr extends F {
  constructor(t = null, e = 1, n = 1, i, s, r, o, a, l = 1003, h = 1003, c, u) {
    super(null, r, o, a, l, h, i, s, c, u),
      (this.image = { data: t, width: e, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
lr.prototype.isDataTexture = !0
const hr = new vt(),
  cr = new vt()
class ur {
  constructor(t = [], e = []) {
    ;(this.uuid = d()),
      (this.bones = t.slice(0)),
      (this.boneInverses = e),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init()
  }
  init() {
    const t = this.bones,
      e = this.boneInverses
    if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length))
      this.calculateInverses()
    else if (t.length !== e.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
      ),
        (this.boneInverses = [])
      for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new vt())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = new vt()
      this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t]
      e && e.matrixWorld.copy(this.boneInverses[t]).invert()
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t]
      e &&
        (e.parent && e.parent.isBone
          ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld))
          : e.matrix.copy(e.matrixWorld),
        e.matrix.decompose(e.position, e.quaternion, e.scale))
    }
  }
  update() {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture
    for (let i = 0, s = t.length; i < s; i++) {
      const s = t[i] ? t[i].matrixWorld : cr
      hr.multiplyMatrices(s, e[i]), hr.toArray(n, 16 * i)
    }
    null !== i && (i.needsUpdate = !0)
  }
  clone() {
    return new ur(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let t = Math.sqrt(4 * this.bones.length)
    ;(t = y(t)), (t = Math.max(t, 4))
    const e = new Float32Array(t * t * 4)
    e.set(this.boneMatrices)
    const n = new lr(e, t, t, 1023, 1015)
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = e),
      (this.boneTexture = n),
      (this.boneTextureSize = t),
      this
    )
  }
  getBoneByName(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const n = this.bones[e]
      if (n.name === t) return n
    }
  }
  dispose() {
    null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(t, e) {
    this.uuid = t.uuid
    for (let n = 0, i = t.bones.length; n < i; n++) {
      const i = t.bones[n]
      let s = e[i]
      void 0 === s && (console.warn('THREE.Skeleton: No bone found with UUID:', i), (s = new ar())),
        this.bones.push(s),
        this.boneInverses.push(new vt().fromArray(t.boneInverses[n]))
    }
    return this.init(), this
  }
  toJSON() {
    const t = {
      metadata: { version: 4.5, type: 'Skeleton', generator: 'Skeleton.toJSON' },
      bones: [],
      boneInverses: []
    }
    t.uuid = this.uuid
    const e = this.bones,
      n = this.boneInverses
    for (let i = 0, s = e.length; i < s; i++) {
      const s = e[i]
      t.bones.push(s.uuid)
      const r = n[i]
      t.boneInverses.push(r.toArray())
    }
    return t
  }
}
class dr extends ae {
  constructor(t, e, n, i = 1) {
    'number' == typeof n &&
      ((i = n),
      (n = !1),
      console.error(
        'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.'
      )),
      super(t, e, n),
      (this.meshPerAttribute = i)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t
  }
}
dr.prototype.isInstancedBufferAttribute = !0
const pr = new vt(),
  gr = new vt(),
  fr = [],
  mr = new Fe()
;(class extends Fe {
  constructor(t, e, n) {
    super(t, e),
      (this.instanceMatrix = new dr(new Float32Array(16 * n), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.frustumCulled = !1)
  }
  copy(t) {
    return (
      super.copy(t),
      this.instanceMatrix.copy(t.instanceMatrix),
      null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      this
    )
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, 3 * t)
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t)
  }
  raycast(t, e) {
    const n = this.matrixWorld,
      i = this.count
    if (((mr.geometry = this.geometry), (mr.material = this.material), void 0 !== mr.material))
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, pr),
          gr.multiplyMatrices(n, pr),
          (mr.matrixWorld = gr),
          mr.raycast(t, fr)
        for (let t = 0, n = fr.length; t < n; t++) {
          const n = fr[t]
          ;(n.instanceId = s), (n.object = this), e.push(n)
        }
        fr.length = 0
      }
  }
  setColorAt(t, e) {
    null === this.instanceColor &&
      (this.instanceColor = new dr(new Float32Array(3 * this.instanceMatrix.count), 3)),
      e.toArray(this.instanceColor.array, 3 * t)
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t)
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}).prototype.isInstancedMesh = !0
class yr extends ie {
  constructor(t) {
    super(),
      (this.type = 'LineBasicMaterial'),
      (this.color = new L(16777215)),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      this
    )
  }
}
yr.prototype.isLineBasicMaterial = !0
const xr = new H(),
  vr = new H(),
  _r = new vt(),
  wr = new xt(),
  Er = new ct()
class br extends Wt {
  constructor(t = new xe(), e = new yr()) {
    super(),
      (this.type = 'Line'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t) {
    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this
  }
  computeLineDistances() {
    const t = this.geometry
    if (t.isBufferGeometry)
      if (null === t.index) {
        const e = t.attributes.position,
          n = [0]
        for (let t = 1, i = e.count; t < i; t++)
          xr.fromBufferAttribute(e, t - 1),
            vr.fromBufferAttribute(e, t),
            (n[t] = n[t - 1]),
            (n[t] += xr.distanceTo(vr))
        t.setAttribute('lineDistance', new ce(n, 1))
      } else
        console.warn(
          'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
        )
    else
      t.isGeometry &&
        console.error(
          'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
    return this
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = t.params.Line.threshold,
      r = n.drawRange
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      Er.copy(n.boundingSphere),
      Er.applyMatrix4(i),
      (Er.radius += s),
      !1 === t.ray.intersectsSphere(Er))
    )
      return
    _r.copy(i).invert(), wr.copy(t.ray).applyMatrix4(_r)
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      a = o * o,
      l = new H(),
      h = new H(),
      c = new H(),
      u = new H(),
      d = this.isLineSegments ? 2 : 1
    if (n.isBufferGeometry) {
      const i = n.index,
        s = n.attributes.position
      if (null !== i) {
        for (
          let n = Math.max(0, r.start), o = Math.min(i.count, r.start + r.count) - 1;
          n < o;
          n += d
        ) {
          const r = i.getX(n),
            o = i.getX(n + 1)
          l.fromBufferAttribute(s, r), h.fromBufferAttribute(s, o)
          if (wr.distanceSqToSegment(l, h, u, c) > a) continue
          u.applyMatrix4(this.matrixWorld)
          const d = t.ray.origin.distanceTo(u)
          d < t.near ||
            d > t.far ||
            e.push({
              distance: d,
              point: c.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this
            })
        }
      } else {
        for (
          let n = Math.max(0, r.start), i = Math.min(s.count, r.start + r.count) - 1;
          n < i;
          n += d
        ) {
          l.fromBufferAttribute(s, n), h.fromBufferAttribute(s, n + 1)
          if (wr.distanceSqToSegment(l, h, u, c) > a) continue
          u.applyMatrix4(this.matrixWorld)
          const i = t.ray.origin.distanceTo(u)
          i < t.near ||
            i > t.far ||
            e.push({
              distance: i,
              point: c.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this
            })
        }
      }
    } else
      n.isGeometry &&
        console.error(
          'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
  }
  updateMorphTargets() {
    const t = this.geometry
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e)
      if (n.length > 0) {
        const t = e[n[0]]
        if (void 0 !== t) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e)
            this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
          }
        }
      }
    } else {
      const e = t.morphTargets
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
    }
  }
}
br.prototype.isLine = !0
const Mr = new H(),
  Sr = new H()
class Ar extends br {
  constructor(t, e) {
    super(t, e), (this.type = 'LineSegments')
  }
  computeLineDistances() {
    const t = this.geometry
    if (t.isBufferGeometry)
      if (null === t.index) {
        const e = t.attributes.position,
          n = []
        for (let t = 0, i = e.count; t < i; t += 2)
          Mr.fromBufferAttribute(e, t),
            Sr.fromBufferAttribute(e, t + 1),
            (n[t] = 0 === t ? 0 : n[t - 1]),
            (n[t + 1] = n[t] + Mr.distanceTo(Sr))
        t.setAttribute('lineDistance', new ce(n, 1))
      } else
        console.warn(
          'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
        )
    else
      t.isGeometry &&
        console.error(
          'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
    return this
  }
}
Ar.prototype.isLineSegments = !0
class Tr extends br {
  constructor(t, e) {
    super(t, e), (this.type = 'LineLoop')
  }
}
Tr.prototype.isLineLoop = !0
class Ir extends ie {
  constructor(t) {
    super(),
      (this.type = 'PointsMaterial'),
      (this.color = new L(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    )
  }
}
Ir.prototype.isPointsMaterial = !0
const Rr = new vt(),
  Lr = new xt(),
  Cr = new ct(),
  Nr = new H()
class Pr extends Wt {
  constructor(t = new xe(), e = new Ir()) {
    super(),
      (this.type = 'Points'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t) {
    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = t.params.Points.threshold,
      r = n.drawRange
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      Cr.copy(n.boundingSphere),
      Cr.applyMatrix4(i),
      (Cr.radius += s),
      !1 === t.ray.intersectsSphere(Cr))
    )
      return
    Rr.copy(i).invert(), Lr.copy(t.ray).applyMatrix4(Rr)
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      a = o * o
    if (n.isBufferGeometry) {
      const s = n.index,
        o = n.attributes.position
      if (null !== s) {
        for (let n = Math.max(0, r.start), l = Math.min(s.count, r.start + r.count); n < l; n++) {
          const r = s.getX(n)
          Nr.fromBufferAttribute(o, r), Dr(Nr, r, a, i, t, e, this)
        }
      } else {
        for (let n = Math.max(0, r.start), s = Math.min(o.count, r.start + r.count); n < s; n++)
          Nr.fromBufferAttribute(o, n), Dr(Nr, n, a, i, t, e, this)
      }
    } else
      console.error(
        'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
      )
  }
  updateMorphTargets() {
    const t = this.geometry
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e)
      if (n.length > 0) {
        const t = e[n[0]]
        if (void 0 !== t) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e)
            this.morphTargetInfluences.push(0), (this.morphTargetDictionary[n] = e)
          }
        }
      }
    } else {
      const e = t.morphTargets
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
        )
    }
  }
}
function Dr(t, e, n, i, s, r, o) {
  const a = Lr.distanceSqToPoint(t)
  if (a < n) {
    const n = new H()
    Lr.closestPointToPoint(t, n), n.applyMatrix4(i)
    const l = s.ray.origin.distanceTo(n)
    if (l < s.near || l > s.far) return
    r.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o })
  }
}
Pr.prototype.isPoints = !0
;(class extends F {
  constructor(t, e, n, i, s, r, o, a, l) {
    super(t, e, n, i, s, r, o, a, l),
      (this.minFilter = void 0 !== r ? r : 1006),
      (this.magFilter = void 0 !== s ? s : 1006),
      (this.generateMipmaps = !1)
    const h = this
    'requestVideoFrameCallback' in t &&
      t.requestVideoFrameCallback(function e() {
        ;(h.needsUpdate = !0), t.requestVideoFrameCallback(e)
      })
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const t = this.image
    !1 === 'requestVideoFrameCallback' in t &&
      t.readyState >= t.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0)
  }
}).prototype.isVideoTexture = !0
;(class extends F {
  constructor(t, e, n) {
    super({ width: t, height: e }),
      (this.format = n),
      (this.magFilter = 1003),
      (this.minFilter = 1003),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0)
  }
}).prototype.isFramebufferTexture = !0
;(class extends F {
  constructor(t, e, n, i, s, r, o, a, l, h, c, u) {
    super(null, r, o, a, l, h, i, s, c, u),
      (this.image = { width: e, height: n }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}).prototype.isCompressedTexture = !0
class Or extends F {
  constructor(t, e, n, i, s, r, o, a, l) {
    super(t, e, n, i, s, r, o, a, l), (this.needsUpdate = !0)
  }
}
Or.prototype.isCanvasTexture = !0
class Fr {
  constructor() {
    ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn('THREE.Curve: .getPoint() not implemented.'), null
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getPoint(n, e)
  }
  getPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return e
  }
  getSpacedPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t))
    return e
  }
  getLength() {
    const t = this.getLengths()
    return t[t.length - 1]
  }
  getLengths(t = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths
    this.needsUpdate = !1
    const e = []
    let n,
      i = this.getPoint(0),
      s = 0
    e.push(0)
    for (let r = 1; r <= t; r++)
      (n = this.getPoint(r / t)), (s += n.distanceTo(i)), e.push(s), (i = n)
    return (this.cacheArcLengths = e), e
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(t, e) {
    const n = this.getLengths()
    let i = 0
    const s = n.length
    let r
    r = e || t * n[s - 1]
    let o,
      a = 0,
      l = s - 1
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (o = n[i] - r), o < 0)) a = i + 1
      else {
        if (!(o > 0)) {
          l = i
          break
        }
        l = i - 1
      }
    if (((i = l), n[i] === r)) return i / (s - 1)
    const h = n[i]
    return (i + (r - h) / (n[i + 1] - h)) / (s - 1)
  }
  getTangent(t, e) {
    const n = 1e-4
    let i = t - n,
      s = t + n
    i < 0 && (i = 0), s > 1 && (s = 1)
    const r = this.getPoint(i),
      o = this.getPoint(s),
      a = e || (r.isVector2 ? new _() : new H())
    return a.copy(o).sub(r).normalize(), a
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getTangent(n, e)
  }
  computeFrenetFrames(t, e) {
    const n = new H(),
      i = [],
      s = [],
      r = [],
      o = new H(),
      a = new vt()
    for (let e = 0; e <= t; e++) {
      const n = e / t
      i[e] = this.getTangentAt(n, new H())
    }
    ;(s[0] = new H()), (r[0] = new H())
    let l = Number.MAX_VALUE
    const h = Math.abs(i[0].x),
      c = Math.abs(i[0].y),
      u = Math.abs(i[0].z)
    h <= l && ((l = h), n.set(1, 0, 0)),
      c <= l && ((l = c), n.set(0, 1, 0)),
      u <= l && n.set(0, 0, 1),
      o.crossVectors(i[0], n).normalize(),
      s[0].crossVectors(i[0], o),
      r[0].crossVectors(i[0], s[0])
    for (let e = 1; e <= t; e++) {
      if (
        ((s[e] = s[e - 1].clone()),
        (r[e] = r[e - 1].clone()),
        o.crossVectors(i[e - 1], i[e]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize()
        const t = Math.acos(p(i[e - 1].dot(i[e]), -1, 1))
        s[e].applyMatrix4(a.makeRotationAxis(o, t))
      }
      r[e].crossVectors(i[e], s[e])
    }
    if (!0 === e) {
      let e = Math.acos(p(s[0].dot(s[t]), -1, 1))
      ;(e /= t), i[0].dot(o.crossVectors(s[0], s[t])) > 0 && (e = -e)
      for (let n = 1; n <= t; n++)
        s[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), r[n].crossVectors(i[n], s[n])
    }
    return { tangents: i, normals: s, binormals: r }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
  toJSON() {
    const t = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } }
    return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
}
class Gr extends Fr {
  constructor(t = 0, e = 0, n = 1, i = 1, s = 0, r = 2 * Math.PI, o = !1, a = 0) {
    super(),
      (this.type = 'EllipseCurve'),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = r),
      (this.aClockwise = o),
      (this.aRotation = a)
  }
  getPoint(t, e) {
    const n = e || new _(),
      i = 2 * Math.PI
    let s = this.aEndAngle - this.aStartAngle
    const r = Math.abs(s) < Number.EPSILON
    for (; s < 0; ) s += i
    for (; s > i; ) s -= i
    s < Number.EPSILON && (s = r ? 0 : i),
      !0 !== this.aClockwise || r || (s === i ? (s = -i) : (s -= i))
    const o = this.aStartAngle + t * s
    let a = this.aX + this.xRadius * Math.cos(o),
      l = this.aY + this.yRadius * Math.sin(o)
    if (0 !== this.aRotation) {
      const t = Math.cos(this.aRotation),
        e = Math.sin(this.aRotation),
        n = a - this.aX,
        i = l - this.aY
      ;(a = n * t - i * e + this.aX), (l = n * e + i * t + this.aY)
    }
    return n.set(a, l)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
}
Gr.prototype.isEllipseCurve = !0
class zr extends Gr {
  constructor(t, e, n, i, s, r) {
    super(t, e, n, n, i, s, r), (this.type = 'ArcCurve')
  }
}
function Br() {
  let t = 0,
    e = 0,
    n = 0,
    i = 0
  function s(s, r, o, a) {
    ;(t = s), (e = o), (n = -3 * s + 3 * r - 2 * o - a), (i = 2 * s - 2 * r + o + a)
  }
  return {
    initCatmullRom: function (t, e, n, i, r) {
      s(e, n, r * (n - t), r * (i - e))
    },
    initNonuniformCatmullRom: function (t, e, n, i, r, o, a) {
      let l = (e - t) / r - (n - t) / (r + o) + (n - e) / o,
        h = (n - e) / o - (i - e) / (o + a) + (i - n) / a
      ;(l *= o), (h *= o), s(e, n, l, h)
    },
    calc: function (s) {
      const r = s * s
      return t + e * s + n * r + i * (r * s)
    }
  }
}
zr.prototype.isArcCurve = !0
const Ur = new H(),
  Vr = new Br(),
  Hr = new Br(),
  kr = new Br()
class Wr extends Fr {
  constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
    super(),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t),
      (this.closed = e),
      (this.curveType = n),
      (this.tension = i)
  }
  getPoint(t, e = new H()) {
    const n = e,
      i = this.points,
      s = i.length,
      r = (s - (this.closed ? 0 : 1)) * t
    let o,
      a,
      l = Math.floor(r),
      h = r - l
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
      : 0 === h && l === s - 1 && ((l = s - 2), (h = 1)),
      this.closed || l > 0 ? (o = i[(l - 1) % s]) : (Ur.subVectors(i[0], i[1]).add(i[0]), (o = Ur))
    const c = i[l % s],
      u = i[(l + 1) % s]
    if (
      (this.closed || l + 2 < s
        ? (a = i[(l + 2) % s])
        : (Ur.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (a = Ur)),
      'centripetal' === this.curveType || 'chordal' === this.curveType)
    ) {
      const t = 'chordal' === this.curveType ? 0.5 : 0.25
      let e = Math.pow(o.distanceToSquared(c), t),
        n = Math.pow(c.distanceToSquared(u), t),
        i = Math.pow(u.distanceToSquared(a), t)
      n < 1e-4 && (n = 1),
        e < 1e-4 && (e = n),
        i < 1e-4 && (i = n),
        Vr.initNonuniformCatmullRom(o.x, c.x, u.x, a.x, e, n, i),
        Hr.initNonuniformCatmullRom(o.y, c.y, u.y, a.y, e, n, i),
        kr.initNonuniformCatmullRom(o.z, c.z, u.z, a.z, e, n, i)
    } else
      'catmullrom' === this.curveType &&
        (Vr.initCatmullRom(o.x, c.x, u.x, a.x, this.tension),
        Hr.initCatmullRom(o.y, c.y, u.y, a.y, this.tension),
        kr.initCatmullRom(o.z, c.z, u.z, a.z, this.tension))
    return n.set(Vr.calc(h), Hr.calc(h), kr.calc(h)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(n.clone())
    }
    return (
      (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
    )
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e]
      t.points.push(n.toArray())
    }
    return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(new H().fromArray(n))
    }
    return (
      (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this
    )
  }
}
function Yr(t, e, n, i, s) {
  const r = 0.5 * (i - e),
    o = 0.5 * (s - n),
    a = t * t
  return (2 * n - 2 * i + r + o) * (t * a) + (-3 * n + 3 * i - 2 * r - o) * a + r * t + n
}
function jr(t, e, n, i) {
  return (
    (function (t, e) {
      const n = 1 - t
      return n * n * e
    })(t, e) +
    (function (t, e) {
      return 2 * (1 - t) * t * e
    })(t, n) +
    (function (t, e) {
      return t * t * e
    })(t, i)
  )
}
function qr(t, e, n, i, s) {
  return (
    (function (t, e) {
      const n = 1 - t
      return n * n * n * e
    })(t, e) +
    (function (t, e) {
      const n = 1 - t
      return 3 * n * n * t * e
    })(t, n) +
    (function (t, e) {
      return 3 * (1 - t) * t * t * e
    })(t, i) +
    (function (t, e) {
      return t * t * t * e
    })(t, s)
  )
}
Wr.prototype.isCatmullRomCurve3 = !0
class Zr extends Fr {
  constructor(t = new _(), e = new _(), n = new _(), i = new _()) {
    super(),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new _()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2,
      o = this.v3
    return n.set(qr(t, i.x, s.x, r.x, o.x), qr(t, i.y, s.y, r.y, o.y)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
Zr.prototype.isCubicBezierCurve = !0
class Xr extends Fr {
  constructor(t = new H(), e = new H(), n = new H(), i = new H()) {
    super(),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new H()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2,
      o = this.v3
    return n.set(qr(t, i.x, s.x, r.x, o.x), qr(t, i.y, s.y, r.y, o.y), qr(t, i.z, s.z, r.z, o.z)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
Xr.prototype.isCubicBezierCurve3 = !0
class Kr extends Fr {
  constructor(t = new _(), e = new _()) {
    super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e)
  }
  getPoint(t, e = new _()) {
    const n = e
    return (
      1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    )
  }
  getPointAt(t, e) {
    return this.getPoint(t, e)
  }
  getTangent(t, e) {
    const n = e || new _()
    return n.copy(this.v2).sub(this.v1).normalize(), n
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
  }
}
Kr.prototype.isLineCurve = !0
class Jr extends Fr {
  constructor(t = new _(), e = new _(), n = new _()) {
    super(), (this.type = 'QuadraticBezierCurve'), (this.v0 = t), (this.v1 = e), (this.v2 = n)
  }
  getPoint(t, e = new _()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2
    return n.set(jr(t, i.x, s.x, r.x), jr(t, i.y, s.y, r.y)), n
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
Jr.prototype.isQuadraticBezierCurve = !0
class Qr extends Fr {
  constructor(t = new H(), e = new H(), n = new H()) {
    super(), (this.type = 'QuadraticBezierCurve3'), (this.v0 = t), (this.v1 = e), (this.v2 = n)
  }
  getPoint(t, e = new H()) {
    const n = e,
      i = this.v0,
      s = this.v1,
      r = this.v2
    return n.set(jr(t, i.x, s.x, r.x), jr(t, i.y, s.y, r.y), jr(t, i.z, s.z, r.z)), n
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
Qr.prototype.isQuadraticBezierCurve3 = !0
class $r extends Fr {
  constructor(t = []) {
    super(), (this.type = 'SplineCurve'), (this.points = t)
  }
  getPoint(t, e = new _()) {
    const n = e,
      i = this.points,
      s = (i.length - 1) * t,
      r = Math.floor(s),
      o = s - r,
      a = i[0 === r ? r : r - 1],
      l = i[r],
      h = i[r > i.length - 2 ? i.length - 1 : r + 1],
      c = i[r > i.length - 3 ? i.length - 1 : r + 2]
    return n.set(Yr(o, a.x, l.x, h.x, c.x), Yr(o, a.y, l.y, h.y, c.y)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(n.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e]
      t.points.push(n.toArray())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e]
      this.points.push(new _().fromArray(n))
    }
    return this
  }
}
$r.prototype.isSplineCurve = !0
var to = Object.freeze({
  __proto__: null,
  ArcCurve: zr,
  CatmullRomCurve3: Wr,
  CubicBezierCurve: Zr,
  CubicBezierCurve3: Xr,
  EllipseCurve: Gr,
  LineCurve: Kr,
  LineCurve3: class extends Fr {
    constructor(t = new H(), e = new H()) {
      super(), (this.type = 'LineCurve3'), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e)
    }
    getPoint(t, e = new H()) {
      const n = e
      return (
        1 === t
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
        n
      )
    }
    getPointAt(t, e) {
      return this.getPoint(t, e)
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }
    toJSON() {
      const t = super.toJSON()
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
  },
  QuadraticBezierCurve: Jr,
  QuadraticBezierCurve3: Qr,
  SplineCurve: $r
})
class eo extends Fr {
  constructor() {
    super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1)
  }
  add(t) {
    this.curves.push(t)
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1)
    t.equals(e) || this.curves.push(new Kr(e, t))
  }
  getPoint(t, e) {
    const n = t * this.getLength(),
      i = this.getCurveLengths()
    let s = 0
    for (; s < i.length; ) {
      if (i[s] >= n) {
        const t = i[s] - n,
          r = this.curves[s],
          o = r.getLength(),
          a = 0 === o ? 0 : 1 - t / o
        return r.getPointAt(a, e)
      }
      s++
    }
    return null
  }
  getLength() {
    const t = this.getCurveLengths()
    return t[t.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const t = []
    let e = 0
    for (let n = 0, i = this.curves.length; n < i; n++) (e += this.curves[n].getLength()), t.push(e)
    return (this.cacheLengths = t), t
  }
  getSpacedPoints(t = 40) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return this.autoClose && e.push(e[0]), e
  }
  getPoints(t = 12) {
    const e = []
    let n
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const r = s[i],
        o = r.isEllipseCurve
          ? 2 * t
          : r.isLineCurve || r.isLineCurve3
            ? 1
            : r.isSplineCurve
              ? t * r.points.length
              : t,
        a = r.getPoints(o)
      for (let t = 0; t < a.length; t++) {
        const i = a[t]
        ;(n && n.equals(i)) || (e.push(i), (n = i))
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
  }
  copy(t) {
    super.copy(t), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e]
      this.curves.push(n.clone())
    }
    return (this.autoClose = t.autoClose), this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.autoClose = this.autoClose), (t.curves = [])
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const n = this.curves[e]
      t.curves.push(n.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e]
      this.curves.push(new to[n.type]().fromJSON(n))
    }
    return this
  }
}
class no extends eo {
  constructor(t) {
    super(), (this.type = 'Path'), (this.currentPoint = new _()), t && this.setFromPoints(t)
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y)
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
    return this
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this
  }
  lineTo(t, e) {
    const n = new Kr(this.currentPoint.clone(), new _(t, e))
    return this.curves.push(n), this.currentPoint.set(t, e), this
  }
  quadraticCurveTo(t, e, n, i) {
    const s = new Jr(this.currentPoint.clone(), new _(t, e), new _(n, i))
    return this.curves.push(s), this.currentPoint.set(n, i), this
  }
  bezierCurveTo(t, e, n, i, s, r) {
    const o = new Zr(this.currentPoint.clone(), new _(t, e), new _(n, i), new _(s, r))
    return this.curves.push(o), this.currentPoint.set(s, r), this
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new $r(e)
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
  }
  arc(t, e, n, i, s, r) {
    const o = this.currentPoint.x,
      a = this.currentPoint.y
    return this.absarc(t + o, e + a, n, i, s, r), this
  }
  absarc(t, e, n, i, s, r) {
    return this.absellipse(t, e, n, n, i, s, r), this
  }
  ellipse(t, e, n, i, s, r, o, a) {
    const l = this.currentPoint.x,
      h = this.currentPoint.y
    return this.absellipse(t + l, e + h, n, i, s, r, o, a), this
  }
  absellipse(t, e, n, i, s, r, o, a) {
    const l = new Gr(t, e, n, i, s, r, o, a)
    if (this.curves.length > 0) {
      const t = l.getPoint(0)
      t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
    }
    this.curves.push(l)
    const h = l.getPoint(1)
    return this.currentPoint.copy(h), this
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.currentPoint = this.currentPoint.toArray()), t
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
  }
}
new H(), new H(), new H(), new ee()
class io extends no {
  constructor(t) {
    super(t), (this.uuid = d()), (this.type = 'Shape'), (this.holes = [])
  }
  getPointsHoles(t) {
    const e = []
    for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t)
    return e
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) }
  }
  copy(t) {
    super.copy(t), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e]
      this.holes.push(n.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.uuid = this.uuid), (t.holes = [])
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const n = this.holes[e]
      t.holes.push(n.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e]
      this.holes.push(new no().fromJSON(n))
    }
    return this
  }
}
const so = function (t, e, n = 2) {
  const i = e && e.length,
    s = i ? e[0] * n : t.length
  let r = ro(t, 0, s, n, !0)
  const o = []
  if (!r || r.next === r.prev) return o
  let a, l, h, c, u, d, p
  if (
    (i &&
      (r = (function (t, e, n, i) {
        const s = []
        let r, o, a, l, h
        for (r = 0, o = e.length; r < o; r++)
          (a = e[r] * i),
            (l = r < o - 1 ? e[r + 1] * i : t.length),
            (h = ro(t, a, l, i, !1)),
            h === h.next && (h.steiner = !0),
            s.push(yo(h))
        for (s.sort(po), r = 0; r < s.length; r++) go(s[r], n), (n = oo(n, n.next))
        return n
      })(t, e, r, n)),
    t.length > 80 * n)
  ) {
    ;(a = h = t[0]), (l = c = t[1])
    for (let e = n; e < s; e += n)
      (u = t[e]),
        (d = t[e + 1]),
        u < a && (a = u),
        d < l && (l = d),
        u > h && (h = u),
        d > c && (c = d)
    ;(p = Math.max(h - a, c - l)), (p = 0 !== p ? 1 / p : 0)
  }
  return ao(r, o, n, a, l, p), o
}
function ro(t, e, n, i, s) {
  let r, o
  if (
    s ===
    (function (t, e, n, i) {
      let s = 0
      for (let r = e, o = n - i; r < n; r += i)
        (s += (t[o] - t[r]) * (t[r + 1] + t[o + 1])), (o = r)
      return s
    })(t, e, n, i) >
      0
  )
    for (r = e; r < n; r += i) o = To(r, t[r], t[r + 1], o)
  else for (r = n - i; r >= e; r -= i) o = To(r, t[r], t[r + 1], o)
  return o && wo(o, o.next) && (Io(o), (o = o.next)), o
}
function oo(t, e) {
  if (!t) return t
  e || (e = t)
  let n,
    i = t
  do {
    if (((n = !1), i.steiner || (!wo(i, i.next) && 0 !== _o(i.prev, i, i.next)))) i = i.next
    else {
      if ((Io(i), (i = e = i.prev), i === i.next)) break
      n = !0
    }
  } while (n || i !== e)
  return e
}
function ao(t, e, n, i, s, r, o) {
  if (!t) return
  !o &&
    r &&
    (function (t, e, n, i) {
      let s = t
      do {
        null === s.z && (s.z = mo(s.x, s.y, e, n, i)),
          (s.prevZ = s.prev),
          (s.nextZ = s.next),
          (s = s.next)
      } while (s !== t)
      ;(s.prevZ.nextZ = null),
        (s.prevZ = null),
        (function (t) {
          let e,
            n,
            i,
            s,
            r,
            o,
            a,
            l,
            h = 1
          do {
            for (n = t, t = null, r = null, o = 0; n; ) {
              for (o++, i = n, a = 0, e = 0; e < h && (a++, (i = i.nextZ), i); e++);
              for (l = h; a > 0 || (l > 0 && i); )
                0 !== a && (0 === l || !i || n.z <= i.z)
                  ? ((s = n), (n = n.nextZ), a--)
                  : ((s = i), (i = i.nextZ), l--),
                  r ? (r.nextZ = s) : (t = s),
                  (s.prevZ = r),
                  (r = s)
              n = i
            }
            ;(r.nextZ = null), (h *= 2)
          } while (o > 1)
        })(s)
    })(t, i, s, r)
  let a,
    l,
    h = t
  for (; t.prev !== t.next; )
    if (((a = t.prev), (l = t.next), r ? ho(t, i, s, r) : lo(t)))
      e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Io(t), (t = l.next), (h = l.next)
    else if ((t = l) === h) {
      o
        ? 1 === o
          ? ao((t = co(oo(t), e, n)), e, n, i, s, r, 2)
          : 2 === o && uo(t, e, n, i, s, r)
        : ao(oo(t), e, n, i, s, r, 1)
      break
    }
}
function lo(t) {
  const e = t.prev,
    n = t,
    i = t.next
  if (_o(e, n, i) >= 0) return !1
  let s = t.next.next
  for (; s !== t.prev; ) {
    if (xo(e.x, e.y, n.x, n.y, i.x, i.y, s.x, s.y) && _o(s.prev, s, s.next) >= 0) return !1
    s = s.next
  }
  return !0
}
function ho(t, e, n, i) {
  const s = t.prev,
    r = t,
    o = t.next
  if (_o(s, r, o) >= 0) return !1
  const a = s.x < r.x ? (s.x < o.x ? s.x : o.x) : r.x < o.x ? r.x : o.x,
    l = s.y < r.y ? (s.y < o.y ? s.y : o.y) : r.y < o.y ? r.y : o.y,
    h = s.x > r.x ? (s.x > o.x ? s.x : o.x) : r.x > o.x ? r.x : o.x,
    c = s.y > r.y ? (s.y > o.y ? s.y : o.y) : r.y > o.y ? r.y : o.y,
    u = mo(a, l, e, n, i),
    d = mo(h, c, e, n, i)
  let p = t.prevZ,
    g = t.nextZ
  for (; p && p.z >= u && g && g.z <= d; ) {
    if (
      p !== t.prev &&
      p !== t.next &&
      xo(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
      _o(p.prev, p, p.next) >= 0
    )
      return !1
    if (
      ((p = p.prevZ),
      g !== t.prev &&
        g !== t.next &&
        xo(s.x, s.y, r.x, r.y, o.x, o.y, g.x, g.y) &&
        _o(g.prev, g, g.next) >= 0)
    )
      return !1
    g = g.nextZ
  }
  for (; p && p.z >= u; ) {
    if (
      p !== t.prev &&
      p !== t.next &&
      xo(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
      _o(p.prev, p, p.next) >= 0
    )
      return !1
    p = p.prevZ
  }
  for (; g && g.z <= d; ) {
    if (
      g !== t.prev &&
      g !== t.next &&
      xo(s.x, s.y, r.x, r.y, o.x, o.y, g.x, g.y) &&
      _o(g.prev, g, g.next) >= 0
    )
      return !1
    g = g.nextZ
  }
  return !0
}
function co(t, e, n) {
  let i = t
  do {
    const s = i.prev,
      r = i.next.next
    !wo(s, r) &&
      Eo(s, i, i.next, r) &&
      So(s, r) &&
      So(r, s) &&
      (e.push(s.i / n), e.push(i.i / n), e.push(r.i / n), Io(i), Io(i.next), (i = t = r)),
      (i = i.next)
  } while (i !== t)
  return oo(i)
}
function uo(t, e, n, i, s, r) {
  let o = t
  do {
    let t = o.next.next
    for (; t !== o.prev; ) {
      if (o.i !== t.i && vo(o, t)) {
        let a = Ao(o, t)
        return (
          (o = oo(o, o.next)), (a = oo(a, a.next)), ao(o, e, n, i, s, r), void ao(a, e, n, i, s, r)
        )
      }
      t = t.next
    }
    o = o.next
  } while (o !== t)
}
function po(t, e) {
  return t.x - e.x
}
function go(t, e) {
  if (
    ((e = (function (t, e) {
      let n = e
      const i = t.x,
        s = t.y
      let r,
        o = -1 / 0
      do {
        if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
          const t = n.x + ((s - n.y) * (n.next.x - n.x)) / (n.next.y - n.y)
          if (t <= i && t > o) {
            if (((o = t), t === i)) {
              if (s === n.y) return n
              if (s === n.next.y) return n.next
            }
            r = n.x < n.next.x ? n : n.next
          }
        }
        n = n.next
      } while (n !== e)
      if (!r) return null
      if (i === o) return r
      const a = r,
        l = r.x,
        h = r.y
      let c,
        u = 1 / 0
      n = r
      do {
        i >= n.x &&
          n.x >= l &&
          i !== n.x &&
          xo(s < h ? i : o, s, l, h, s < h ? o : i, s, n.x, n.y) &&
          ((c = Math.abs(s - n.y) / (i - n.x)),
          So(n, t) &&
            (c < u || (c === u && (n.x > r.x || (n.x === r.x && fo(r, n))))) &&
            ((r = n), (u = c))),
          (n = n.next)
      } while (n !== a)
      return r
    })(t, e)),
    e)
  ) {
    const n = Ao(e, t)
    oo(e, e.next), oo(n, n.next)
  }
}
function fo(t, e) {
  return _o(t.prev, t, e.prev) < 0 && _o(e.next, t, t.next) < 0
}
function mo(t, e, n, i, s) {
  return (
    (t =
      1431655765 &
      ((t =
        858993459 &
        ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * s) | (t << 8))) | (t << 4))) |
          (t << 2))) |
        (t << 1))) |
    ((e =
      1431655765 &
      ((e =
        858993459 &
        ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * s) | (e << 8))) | (e << 4))) |
          (e << 2))) |
        (e << 1))) <<
      1)
  )
}
function yo(t) {
  let e = t,
    n = t
  do {
    ;(e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next)
  } while (e !== t)
  return n
}
function xo(t, e, n, i, s, r, o, a) {
  return (
    (s - o) * (e - a) - (t - o) * (r - a) >= 0 &&
    (t - o) * (i - a) - (n - o) * (e - a) >= 0 &&
    (n - o) * (r - a) - (s - o) * (i - a) >= 0
  )
}
function vo(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !(function (t, e) {
      let n = t
      do {
        if (
          n.i !== t.i &&
          n.next.i !== t.i &&
          n.i !== e.i &&
          n.next.i !== e.i &&
          Eo(n, n.next, t, e)
        )
          return !0
        n = n.next
      } while (n !== t)
      return !1
    })(t, e) &&
    ((So(t, e) &&
      So(e, t) &&
      (function (t, e) {
        let n = t,
          i = !1
        const s = (t.x + e.x) / 2,
          r = (t.y + e.y) / 2
        do {
          n.y > r != n.next.y > r &&
            n.next.y !== n.y &&
            s < ((n.next.x - n.x) * (r - n.y)) / (n.next.y - n.y) + n.x &&
            (i = !i),
            (n = n.next)
        } while (n !== t)
        return i
      })(t, e) &&
      (_o(t.prev, t, e.prev) || _o(t, e.prev, e))) ||
      (wo(t, e) && _o(t.prev, t, t.next) > 0 && _o(e.prev, e, e.next) > 0))
  )
}
function _o(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}
function wo(t, e) {
  return t.x === e.x && t.y === e.y
}
function Eo(t, e, n, i) {
  const s = Mo(_o(t, e, n)),
    r = Mo(_o(t, e, i)),
    o = Mo(_o(n, i, t)),
    a = Mo(_o(n, i, e))
  return (
    (s !== r && o !== a) ||
    !(0 !== s || !bo(t, n, e)) ||
    !(0 !== r || !bo(t, i, e)) ||
    !(0 !== o || !bo(n, t, i)) ||
    !(0 !== a || !bo(n, e, i))
  )
}
function bo(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  )
}
function Mo(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0
}
function So(t, e) {
  return _o(t.prev, t, t.next) < 0
    ? _o(t, e, t.next) >= 0 && _o(t, t.prev, e) >= 0
    : _o(t, e, t.prev) < 0 || _o(t, t.next, e) < 0
}
function Ao(t, e) {
  const n = new Ro(t.i, t.x, t.y),
    i = new Ro(e.i, e.x, e.y),
    s = t.next,
    r = e.prev
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = s),
    (s.prev = n),
    (i.next = n),
    (n.prev = i),
    (r.next = i),
    (i.prev = r),
    i
  )
}
function To(t, e, n, i) {
  const s = new Ro(t, e, n)
  return (
    i
      ? ((s.next = i.next), (s.prev = i), (i.next.prev = s), (i.next = s))
      : ((s.prev = s), (s.next = s)),
    s
  )
}
function Io(t) {
  ;(t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ)
}
function Ro(t, e, n) {
  ;(this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
class Lo {
  static area(t) {
    const e = t.length
    let n = 0
    for (let i = e - 1, s = 0; s < e; i = s++) n += t[i].x * t[s].y - t[s].x * t[i].y
    return 0.5 * n
  }
  static isClockWise(t) {
    return Lo.area(t) < 0
  }
  static triangulateShape(t, e) {
    const n = [],
      i = [],
      s = []
    Co(t), No(n, t)
    let r = t.length
    e.forEach(Co)
    for (let t = 0; t < e.length; t++) i.push(r), (r += e[t].length), No(n, e[t])
    const o = so(n, i)
    for (let t = 0; t < o.length; t += 3) s.push(o.slice(t, t + 3))
    return s
  }
}
function Co(t) {
  const e = t.length
  e > 2 && t[e - 1].equals(t[0]) && t.pop()
}
function No(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
}
class Po extends xe {
  constructor(
    t = new io([new _(0.5, 0.5), new _(-0.5, 0.5), new _(-0.5, -0.5), new _(0.5, -0.5)]),
    e = {}
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t])
    const n = this,
      i = [],
      s = []
    for (let e = 0, n = t.length; e < n; e++) {
      r(t[e])
    }
    function r(t) {
      const r = [],
        o = void 0 !== e.curveSegments ? e.curveSegments : 12,
        a = void 0 !== e.steps ? e.steps : 1
      let l = void 0 !== e.depth ? e.depth : 1,
        h = void 0 === e.bevelEnabled || e.bevelEnabled,
        c = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
        u = void 0 !== e.bevelSize ? e.bevelSize : c - 0.1,
        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3
      const g = e.extrudePath,
        f = void 0 !== e.UVGenerator ? e.UVGenerator : Do
      void 0 !== e.amount &&
        (console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'),
        (l = e.amount))
      let m,
        y,
        x,
        v,
        w,
        E = !1
      g &&
        ((m = g.getSpacedPoints(a)),
        (E = !0),
        (h = !1),
        (y = g.computeFrenetFrames(a, !1)),
        (x = new H()),
        (v = new H()),
        (w = new H())),
        h || ((p = 0), (c = 0), (u = 0), (d = 0))
      const b = t.extractPoints(o)
      let M = b.shape
      const S = b.holes
      if (!Lo.isClockWise(M)) {
        M = M.reverse()
        for (let t = 0, e = S.length; t < e; t++) {
          const e = S[t]
          Lo.isClockWise(e) && (S[t] = e.reverse())
        }
      }
      const A = Lo.triangulateShape(M, S),
        T = M
      for (let t = 0, e = S.length; t < e; t++) {
        const e = S[t]
        M = M.concat(e)
      }
      function I(t, e, n) {
        return (
          e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          e.clone().multiplyScalar(n).add(t)
        )
      }
      const R = M.length,
        L = A.length
      function C(t, e, n) {
        let i, s, r
        const o = t.x - e.x,
          a = t.y - e.y,
          l = n.x - t.x,
          h = n.y - t.y,
          c = o * o + a * a,
          u = o * h - a * l
        if (Math.abs(u) > Number.EPSILON) {
          const u = Math.sqrt(c),
            d = Math.sqrt(l * l + h * h),
            p = e.x - a / u,
            g = e.y + o / u,
            f = ((n.x - h / d - p) * h - (n.y + l / d - g) * l) / (o * h - a * l)
          ;(i = p + o * f - t.x), (s = g + a * f - t.y)
          const m = i * i + s * s
          if (m <= 2) return new _(i, s)
          r = Math.sqrt(m / 2)
        } else {
          let t = !1
          o > Number.EPSILON
            ? l > Number.EPSILON && (t = !0)
            : o < -Number.EPSILON
              ? l < -Number.EPSILON && (t = !0)
              : Math.sign(a) === Math.sign(h) && (t = !0),
            t ? ((i = -a), (s = o), (r = Math.sqrt(c))) : ((i = o), (s = a), (r = Math.sqrt(c / 2)))
        }
        return new _(i / r, s / r)
      }
      const N = []
      for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)
        n === e && (n = 0), i === e && (i = 0), (N[t] = C(T[t], T[n], T[i]))
      const P = []
      let D,
        O = N.concat()
      for (let t = 0, e = S.length; t < e; t++) {
        const e = S[t]
        D = []
        for (let t = 0, n = e.length, i = n - 1, s = t + 1; t < n; t++, i++, s++)
          i === n && (i = 0), s === n && (s = 0), (D[t] = C(e[t], e[i], e[s]))
        P.push(D), (O = O.concat(D))
      }
      for (let t = 0; t < p; t++) {
        const e = t / p,
          n = c * Math.cos((e * Math.PI) / 2),
          i = u * Math.sin((e * Math.PI) / 2) + d
        for (let t = 0, e = T.length; t < e; t++) {
          const e = I(T[t], N[t], i)
          z(e.x, e.y, -n)
        }
        for (let t = 0, e = S.length; t < e; t++) {
          const e = S[t]
          D = P[t]
          for (let t = 0, s = e.length; t < s; t++) {
            const s = I(e[t], D[t], i)
            z(s.x, s.y, -n)
          }
        }
      }
      const F = u + d
      for (let t = 0; t < R; t++) {
        const e = h ? I(M[t], O[t], F) : M[t]
        E
          ? (v.copy(y.normals[0]).multiplyScalar(e.x),
            x.copy(y.binormals[0]).multiplyScalar(e.y),
            w.copy(m[0]).add(v).add(x),
            z(w.x, w.y, w.z))
          : z(e.x, e.y, 0)
      }
      for (let t = 1; t <= a; t++)
        for (let e = 0; e < R; e++) {
          const n = h ? I(M[e], O[e], F) : M[e]
          E
            ? (v.copy(y.normals[t]).multiplyScalar(n.x),
              x.copy(y.binormals[t]).multiplyScalar(n.y),
              w.copy(m[t]).add(v).add(x),
              z(w.x, w.y, w.z))
            : z(n.x, n.y, (l / a) * t)
        }
      for (let t = p - 1; t >= 0; t--) {
        const e = t / p,
          n = c * Math.cos((e * Math.PI) / 2),
          i = u * Math.sin((e * Math.PI) / 2) + d
        for (let t = 0, e = T.length; t < e; t++) {
          const e = I(T[t], N[t], i)
          z(e.x, e.y, l + n)
        }
        for (let t = 0, e = S.length; t < e; t++) {
          const e = S[t]
          D = P[t]
          for (let t = 0, s = e.length; t < s; t++) {
            const s = I(e[t], D[t], i)
            E ? z(s.x, s.y + m[a - 1].y, m[a - 1].x + n) : z(s.x, s.y, l + n)
          }
        }
      }
      function G(t, e) {
        let n = t.length
        for (; --n >= 0; ) {
          const i = n
          let s = n - 1
          s < 0 && (s = t.length - 1)
          for (let t = 0, n = a + 2 * p; t < n; t++) {
            const n = R * t,
              r = R * (t + 1)
            U(e + i + n, e + s + n, e + s + r, e + i + r)
          }
        }
      }
      function z(t, e, n) {
        r.push(t), r.push(e), r.push(n)
      }
      function B(t, e, s) {
        V(t), V(e), V(s)
        const r = i.length / 3,
          o = f.generateTopUV(n, i, r - 3, r - 2, r - 1)
        k(o[0]), k(o[1]), k(o[2])
      }
      function U(t, e, s, r) {
        V(t), V(e), V(r), V(e), V(s), V(r)
        const o = i.length / 3,
          a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1)
        k(a[0]), k(a[1]), k(a[3]), k(a[1]), k(a[2]), k(a[3])
      }
      function V(t) {
        i.push(r[3 * t + 0]), i.push(r[3 * t + 1]), i.push(r[3 * t + 2])
      }
      function k(t) {
        s.push(t.x), s.push(t.y)
      }
      !(function () {
        const t = i.length / 3
        if (h) {
          let t = 0,
            e = R * t
          for (let t = 0; t < L; t++) {
            const n = A[t]
            B(n[2] + e, n[1] + e, n[0] + e)
          }
          ;(t = a + 2 * p), (e = R * t)
          for (let t = 0; t < L; t++) {
            const n = A[t]
            B(n[0] + e, n[1] + e, n[2] + e)
          }
        } else {
          for (let t = 0; t < L; t++) {
            const e = A[t]
            B(e[2], e[1], e[0])
          }
          for (let t = 0; t < L; t++) {
            const e = A[t]
            B(e[0] + R * a, e[1] + R * a, e[2] + R * a)
          }
        }
        n.addGroup(t, i.length / 3 - t, 0)
      })(),
        (function () {
          const t = i.length / 3
          let e = 0
          G(T, e), (e += T.length)
          for (let t = 0, n = S.length; t < n; t++) {
            const n = S[t]
            G(n, e), (e += n.length)
          }
          n.addGroup(t, i.length / 3 - t, 1)
        })()
    }
    this.setAttribute('position', new ce(i, 3)),
      this.setAttribute('uv', new ce(s, 2)),
      this.computeVertexNormals()
  }
  toJSON() {
    const t = super.toJSON()
    return (function (t, e, n) {
      if (((n.shapes = []), Array.isArray(t)))
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e]
          n.shapes.push(i.uuid)
        }
      else n.shapes.push(t.uuid)
      void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON())
      return n
    })(this.parameters.shapes, this.parameters.options, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let i = 0, s = t.shapes.length; i < s; i++) {
      const s = e[t.shapes[i]]
      n.push(s)
    }
    const i = t.options.extrudePath
    return (
      void 0 !== i && (t.options.extrudePath = new to[i.type]().fromJSON(i)), new Po(n, t.options)
    )
  }
}
const Do = {
  generateTopUV: function (t, e, n, i, s) {
    const r = e[3 * n],
      o = e[3 * n + 1],
      a = e[3 * i],
      l = e[3 * i + 1],
      h = e[3 * s],
      c = e[3 * s + 1]
    return [new _(r, o), new _(a, l), new _(h, c)]
  },
  generateSideWallUV: function (t, e, n, i, s, r) {
    const o = e[3 * n],
      a = e[3 * n + 1],
      l = e[3 * n + 2],
      h = e[3 * i],
      c = e[3 * i + 1],
      u = e[3 * i + 2],
      d = e[3 * s],
      p = e[3 * s + 1],
      g = e[3 * s + 2],
      f = e[3 * r],
      m = e[3 * r + 1],
      y = e[3 * r + 2]
    return Math.abs(a - c) < Math.abs(o - h)
      ? [new _(o, 1 - l), new _(h, 1 - u), new _(d, 1 - g), new _(f, 1 - y)]
      : [new _(a, 1 - l), new _(c, 1 - u), new _(p, 1 - g), new _(m, 1 - y)]
  }
}
class Oo extends xe {
  constructor(t = new io([new _(0, 0.5), new _(-0.5, -0.5), new _(0.5, -0.5)]), e = 12) {
    super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: t, curveSegments: e })
    const n = [],
      i = [],
      s = [],
      r = []
    let o = 0,
      a = 0
    if (!1 === Array.isArray(t)) l(t)
    else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), (o += a), (a = 0)
    function l(t) {
      const o = i.length / 3,
        l = t.extractPoints(e)
      let h = l.shape
      const c = l.holes
      !1 === Lo.isClockWise(h) && (h = h.reverse())
      for (let t = 0, e = c.length; t < e; t++) {
        const e = c[t]
        !0 === Lo.isClockWise(e) && (c[t] = e.reverse())
      }
      const u = Lo.triangulateShape(h, c)
      for (let t = 0, e = c.length; t < e; t++) {
        const e = c[t]
        h = h.concat(e)
      }
      for (let t = 0, e = h.length; t < e; t++) {
        const e = h[t]
        i.push(e.x, e.y, 0), s.push(0, 0, 1), r.push(e.x, e.y)
      }
      for (let t = 0, e = u.length; t < e; t++) {
        const e = u[t],
          i = e[0] + o,
          s = e[1] + o,
          r = e[2] + o
        n.push(i, s, r), (a += 3)
      }
    }
    this.setIndex(n),
      this.setAttribute('position', new ce(i, 3)),
      this.setAttribute('normal', new ce(s, 3)),
      this.setAttribute('uv', new ce(r, 2))
  }
  toJSON() {
    const t = super.toJSON()
    return (function (t, e) {
      if (((e.shapes = []), Array.isArray(t)))
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n]
          e.shapes.push(i.uuid)
        }
      else e.shapes.push(t.uuid)
      return e
    })(this.parameters.shapes, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let i = 0, s = t.shapes.length; i < s; i++) {
      const s = e[t.shapes[i]]
      n.push(s)
    }
    return new Oo(n, t.curveSegments)
  }
}
class Fo extends xe {
  constructor(t = 1, e = 32, n = 16, i = 0, s = 2 * Math.PI, r = 0, o = Math.PI) {
    super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: r,
        thetaLength: o
      }),
      (e = Math.max(3, Math.floor(e))),
      (n = Math.max(2, Math.floor(n)))
    const a = Math.min(r + o, Math.PI)
    let l = 0
    const h = [],
      c = new H(),
      u = new H(),
      d = [],
      p = [],
      g = [],
      f = []
    for (let d = 0; d <= n; d++) {
      const m = [],
        y = d / n
      let x = 0
      0 == d && 0 == r ? (x = 0.5 / e) : d == n && a == Math.PI && (x = -0.5 / e)
      for (let n = 0; n <= e; n++) {
        const a = n / e
        ;(c.x = -t * Math.cos(i + a * s) * Math.sin(r + y * o)),
          (c.y = t * Math.cos(r + y * o)),
          (c.z = t * Math.sin(i + a * s) * Math.sin(r + y * o)),
          p.push(c.x, c.y, c.z),
          u.copy(c).normalize(),
          g.push(u.x, u.y, u.z),
          f.push(a + x, 1 - y),
          m.push(l++)
      }
      h.push(m)
    }
    for (let t = 0; t < n; t++)
      for (let i = 0; i < e; i++) {
        const e = h[t][i + 1],
          s = h[t][i],
          o = h[t + 1][i],
          l = h[t + 1][i + 1]
        ;(0 !== t || r > 0) && d.push(e, s, l), (t !== n - 1 || a < Math.PI) && d.push(s, o, l)
      }
    this.setIndex(d),
      this.setAttribute('position', new ce(p, 3)),
      this.setAttribute('normal', new ce(g, 3)),
      this.setAttribute('uv', new ce(f, 2))
  }
  static fromJSON(t) {
    return new Fo(
      t.radius,
      t.widthSegments,
      t.heightSegments,
      t.phiStart,
      t.phiLength,
      t.thetaStart,
      t.thetaLength
    )
  }
}
class Go extends ie {
  constructor(t) {
    super(),
      (this.type = 'ShadowMaterial'),
      (this.color = new L(0)),
      (this.transparent = !0),
      this.setValues(t)
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this
  }
}
Go.prototype.isShadowMaterial = !0
class zo extends He {
  constructor(t) {
    super(t), (this.type = 'RawShaderMaterial')
  }
}
zo.prototype.isRawShaderMaterial = !0
class Bo extends ie {
  constructor(t) {
    super(),
      (this.defines = { STANDARD: '' }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new L(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new L(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new _(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: '' }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.envMapIntensity = t.envMapIntensity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      this
    )
  }
}
Bo.prototype.isMeshStandardMaterial = !0
class Uo extends Bo {
  constructor(t) {
    super(),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new _(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return p((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
        }
      }),
      (this.sheenColor = new L(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 0),
      (this.attenuationColor = new L(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new L(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._transmission = 0),
      this.setValues(t)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.ior = t.ior),
      (this.sheen = t.sheen),
      this.sheenColor.copy(t.sheenColor),
      (this.sheenColorMap = t.sheenColorMap),
      (this.sheenRoughness = t.sheenRoughness),
      (this.sheenRoughnessMap = t.sheenRoughnessMap),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      (this.thickness = t.thickness),
      (this.thicknessMap = t.thicknessMap),
      (this.attenuationDistance = t.attenuationDistance),
      this.attenuationColor.copy(t.attenuationColor),
      (this.specularIntensity = t.specularIntensity),
      (this.specularIntensityMap = t.specularIntensityMap),
      this.specularColor.copy(t.specularColor),
      (this.specularColorMap = t.specularColorMap),
      this
    )
  }
}
Uo.prototype.isMeshPhysicalMaterial = !0
class Vo extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new L(16777215)),
      (this.specular = new L(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new L(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new _(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      this
    )
  }
}
Vo.prototype.isMeshPhongMaterial = !0
class Ho extends ie {
  constructor(t) {
    super(),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.color = new L(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new L(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new _(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.gradientMap = t.gradientMap),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    )
  }
}
Ho.prototype.isMeshToonMaterial = !0
class ko extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new _(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.flatShading = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.flatShading = t.flatShading),
      this
    )
  }
}
ko.prototype.isMeshNormalMaterial = !0
class Wo extends ie {
  constructor(t) {
    super(),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new L(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new L(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    )
  }
}
Wo.prototype.isMeshLambertMaterial = !0
class Yo extends ie {
  constructor(t) {
    super(),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new L(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new _(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { MATCAP: '' }),
      this.color.copy(t.color),
      (this.matcap = t.matcap),
      (this.map = t.map),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.flatShading = t.flatShading),
      this
    )
  }
}
Yo.prototype.isMeshMatcapMaterial = !0
class jo extends yr {
  constructor(t) {
    super(),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.scale = t.scale),
      (this.dashSize = t.dashSize),
      (this.gapSize = t.gapSize),
      this
    )
  }
}
jo.prototype.isLineDashedMaterial = !0
const qo = {
  ShadowMaterial: Go,
  SpriteMaterial: Bs,
  RawShaderMaterial: zo,
  ShaderMaterial: He,
  PointsMaterial: Ir,
  MeshPhysicalMaterial: Uo,
  MeshStandardMaterial: Bo,
  MeshPhongMaterial: Vo,
  MeshToonMaterial: Ho,
  MeshNormalMaterial: ko,
  MeshLambertMaterial: Wo,
  MeshDepthMaterial: ws,
  MeshDistanceMaterial: Es,
  MeshBasicMaterial: se,
  MeshMatcapMaterial: Yo,
  LineDashedMaterial: jo,
  LineBasicMaterial: yr,
  Material: ie
}
ie.fromType = function (t) {
  return new qo[t]()
}
const Zo = {
  arraySlice: function (t, e, n) {
    return Zo.isTypedArray(t)
      ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
      : t.slice(e, n)
  },
  convertArray: function (t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : 'number' == typeof e.BYTES_PER_ELEMENT
        ? new e(t)
        : Array.prototype.slice.call(t)
  },
  isTypedArray: function (t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView)
  },
  getKeyframeOrder: function (t) {
    const e = t.length,
      n = new Array(e)
    for (let t = 0; t !== e; ++t) n[t] = t
    return (
      n.sort(function (e, n) {
        return t[e] - t[n]
      }),
      n
    )
  },
  sortedArray: function (t, e, n) {
    const i = t.length,
      s = new t.constructor(i)
    for (let r = 0, o = 0; o !== i; ++r) {
      const i = n[r] * e
      for (let n = 0; n !== e; ++n) s[o++] = t[i + n]
    }
    return s
  },
  flattenJSON: function (t, e, n, i) {
    let s = 1,
      r = t[0]
    for (; void 0 !== r && void 0 === r[i]; ) r = t[s++]
    if (void 0 === r) return
    let o = r[i]
    if (void 0 !== o)
      if (Array.isArray(o))
        do {
          ;(o = r[i]), void 0 !== o && (e.push(r.time), n.push.apply(n, o)), (r = t[s++])
        } while (void 0 !== r)
      else if (void 0 !== o.toArray)
        do {
          ;(o = r[i]), void 0 !== o && (e.push(r.time), o.toArray(n, n.length)), (r = t[s++])
        } while (void 0 !== r)
      else
        do {
          ;(o = r[i]), void 0 !== o && (e.push(r.time), n.push(o)), (r = t[s++])
        } while (void 0 !== r)
  },
  subclip: function (t, e, n, i, s = 30) {
    const r = t.clone()
    r.name = e
    const o = []
    for (let t = 0; t < r.tracks.length; ++t) {
      const e = r.tracks[t],
        a = e.getValueSize(),
        l = [],
        h = []
      for (let t = 0; t < e.times.length; ++t) {
        const r = e.times[t] * s
        if (!(r < n || r >= i)) {
          l.push(e.times[t])
          for (let n = 0; n < a; ++n) h.push(e.values[t * a + n])
        }
      }
      0 !== l.length &&
        ((e.times = Zo.convertArray(l, e.times.constructor)),
        (e.values = Zo.convertArray(h, e.values.constructor)),
        o.push(e))
    }
    r.tracks = o
    let a = 1 / 0
    for (let t = 0; t < r.tracks.length; ++t) a > r.tracks[t].times[0] && (a = r.tracks[t].times[0])
    for (let t = 0; t < r.tracks.length; ++t) r.tracks[t].shift(-1 * a)
    return r.resetDuration(), r
  },
  makeClipAdditive: function (t, e = 0, n = t, i = 30) {
    i <= 0 && (i = 30)
    const s = n.tracks.length,
      r = e / i
    for (let e = 0; e < s; ++e) {
      const i = n.tracks[e],
        s = i.ValueTypeName
      if ('bool' === s || 'string' === s) continue
      const o = t.tracks.find(function (t) {
        return t.name === i.name && t.ValueTypeName === s
      })
      if (void 0 === o) continue
      let a = 0
      const l = i.getValueSize()
      i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3)
      let h = 0
      const c = o.getValueSize()
      o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = c / 3)
      const u = i.times.length - 1
      let d
      if (r <= i.times[0]) {
        const t = a,
          e = l - a
        d = Zo.arraySlice(i.values, t, e)
      } else if (r >= i.times[u]) {
        const t = u * l + a,
          e = t + l - a
        d = Zo.arraySlice(i.values, t, e)
      } else {
        const t = i.createInterpolant(),
          e = a,
          n = l - a
        t.evaluate(r), (d = Zo.arraySlice(t.resultBuffer, e, n))
      }
      if ('quaternion' === s) {
        new V().fromArray(d).normalize().conjugate().toArray(d)
      }
      const p = o.times.length
      for (let t = 0; t < p; ++t) {
        const e = t * c + h
        if ('quaternion' === s) V.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e)
        else {
          const t = c - 2 * h
          for (let n = 0; n < t; ++n) o.values[e + n] -= d[n]
        }
      }
    }
    return (t.blendMode = 2501), t
  }
}
class Xo {
  constructor(t, e, n, i) {
    ;(this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(t) {
    const e = this.parameterPositions
    let n = this._cachedIndex,
      i = e[n],
      s = e[n - 1]
    t: {
      e: {
        let r
        n: {
          i: if (!(t < i)) {
            for (let r = n + 2; ; ) {
              if (void 0 === i) {
                if (t < s) break i
                return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, t, s)
              }
              if (n === r) break
              if (((s = i), (i = e[++n]), t < i)) break e
            }
            r = e.length
            break n
          }
          if (t >= s) break t
          {
            const o = e[1]
            t < o && ((n = 2), (s = o))
            for (let r = n - 2; ; ) {
              if (void 0 === s) return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
              if (n === r) break
              if (((i = s), (s = e[--n - 1]), t >= s)) break e
            }
            ;(r = n), (n = 0)
          }
        }
        for (; n < r; ) {
          const i = (n + r) >>> 1
          t < e[i] ? (r = i) : (n = i + 1)
        }
        if (((i = e[n]), (s = e[n - 1]), void 0 === s))
          return (this._cachedIndex = 0), this.beforeStart_(0, t, i)
        if (void 0 === i)
          return (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, s, t)
      }
      ;(this._cachedIndex = n), this.intervalChanged_(n, s, i)
    }
    return this.interpolate_(n, s, t, i)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = t * i
    for (let t = 0; t !== i; ++t) e[t] = n[s + t]
    return e
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
;(Xo.prototype.beforeStart_ = Xo.prototype.copySampleValue_),
  (Xo.prototype.afterEnd_ = Xo.prototype.copySampleValue_)
class Ko extends Xo {
  constructor(t, e, n, i) {
    super(t, e, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 })
  }
  intervalChanged_(t, e, n) {
    const i = this.parameterPositions
    let s = t - 2,
      r = t + 1,
      o = i[s],
      a = i[r]
    if (void 0 === o)
      switch (this.getSettings_().endingStart) {
        case 2401:
          ;(s = t), (o = 2 * e - n)
          break
        case 2402:
          ;(s = i.length - 2), (o = e + i[s] - i[s + 1])
          break
        default:
          ;(s = t), (o = n)
      }
    if (void 0 === a)
      switch (this.getSettings_().endingEnd) {
        case 2401:
          ;(r = t), (a = 2 * n - e)
          break
        case 2402:
          ;(r = 1), (a = n + i[1] - i[0])
          break
        default:
          ;(r = t - 1), (a = e)
      }
    const l = 0.5 * (n - e),
      h = this.valueSize
    ;(this._weightPrev = l / (e - o)),
      (this._weightNext = l / (a - n)),
      (this._offsetPrev = s * h),
      (this._offsetNext = r * h)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      o = this.valueSize,
      a = t * o,
      l = a - o,
      h = this._offsetPrev,
      c = this._offsetNext,
      u = this._weightPrev,
      d = this._weightNext,
      p = (n - e) / (i - e),
      g = p * p,
      f = g * p,
      m = -u * f + 2 * u * g - u * p,
      y = (1 + u) * f + (-1.5 - 2 * u) * g + (-0.5 + u) * p + 1,
      x = (-1 - d) * f + (1.5 + d) * g + 0.5 * p,
      v = d * f - d * g
    for (let t = 0; t !== o; ++t) s[t] = m * r[h + t] + y * r[l + t] + x * r[a + t] + v * r[c + t]
    return s
  }
}
class Jo extends Xo {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      o = this.valueSize,
      a = t * o,
      l = a - o,
      h = (n - e) / (i - e),
      c = 1 - h
    for (let t = 0; t !== o; ++t) s[t] = r[l + t] * c + r[a + t] * h
    return s
  }
}
class Qo extends Xo {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1)
  }
}
class $o {
  constructor(t, e, n, i) {
    if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (void 0 === e || 0 === e.length)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t)
    ;(this.name = t),
      (this.times = Zo.convertArray(e, this.TimeBufferType)),
      (this.values = Zo.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation)
  }
  static toJSON(t) {
    const e = t.constructor
    let n
    if (e.toJSON !== this.toJSON) n = e.toJSON(t)
    else {
      n = {
        name: t.name,
        times: Zo.convertArray(t.times, Array),
        values: Zo.convertArray(t.values, Array)
      }
      const e = t.getInterpolation()
      e !== t.DefaultInterpolation && (n.interpolation = e)
    }
    return (n.type = t.ValueTypeName), n
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new Qo(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodLinear(t) {
    return new Jo(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodSmooth(t) {
    return new Ko(this.times, this.values, this.getValueSize(), t)
  }
  setInterpolation(t) {
    let e
    switch (t) {
      case 2300:
        e = this.InterpolantFactoryMethodDiscrete
        break
      case 2301:
        e = this.InterpolantFactoryMethodLinear
        break
      case 2302:
        e = this.InterpolantFactoryMethodSmooth
    }
    if (void 0 === e) {
      const e =
        'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name
      if (void 0 === this.createInterpolant) {
        if (t === this.DefaultInterpolation) throw new Error(e)
        this.setInterpolation(this.DefaultInterpolation)
      }
      return console.warn('THREE.KeyframeTrack:', e), this
    }
    return (this.createInterpolant = e), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300
      case this.InterpolantFactoryMethodLinear:
        return 2301
      case this.InterpolantFactoryMethodSmooth:
        return 2302
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(t) {
    if (0 !== t) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
    }
    return this
  }
  scale(t) {
    if (1 !== t) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
    }
    return this
  }
  trim(t, e) {
    const n = this.times,
      i = n.length
    let s = 0,
      r = i - 1
    for (; s !== i && n[s] < t; ) ++s
    for (; -1 !== r && n[r] > e; ) --r
    if ((++r, 0 !== s || r !== i)) {
      s >= r && ((r = Math.max(r, 1)), (s = r - 1))
      const t = this.getValueSize()
      ;(this.times = Zo.arraySlice(n, s, r)),
        (this.values = Zo.arraySlice(this.values, s * t, r * t))
    }
    return this
  }
  validate() {
    let t = !0
    const e = this.getValueSize()
    e - Math.floor(e) != 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (t = !1))
    const n = this.times,
      i = this.values,
      s = n.length
    0 === s && (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1))
    let r = null
    for (let e = 0; e !== s; e++) {
      const i = n[e]
      if ('number' == typeof i && isNaN(i)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, e, i), (t = !1)
        break
      }
      if (null !== r && r > i) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, e, i, r), (t = !1)
        break
      }
      r = i
    }
    if (void 0 !== i && Zo.isTypedArray(i))
      for (let e = 0, n = i.length; e !== n; ++e) {
        const n = i[e]
        if (isNaN(n)) {
          console.error('THREE.KeyframeTrack: Value is not a valid number.', this, e, n), (t = !1)
          break
        }
      }
    return t
  }
  optimize() {
    const t = Zo.arraySlice(this.times),
      e = Zo.arraySlice(this.values),
      n = this.getValueSize(),
      i = 2302 === this.getInterpolation(),
      s = t.length - 1
    let r = 1
    for (let o = 1; o < s; ++o) {
      let s = !1
      const a = t[o]
      if (a !== t[o + 1] && (1 !== o || a !== t[0]))
        if (i) s = !0
        else {
          const t = o * n,
            i = t - n,
            r = t + n
          for (let o = 0; o !== n; ++o) {
            const n = e[t + o]
            if (n !== e[i + o] || n !== e[r + o]) {
              s = !0
              break
            }
          }
        }
      if (s) {
        if (o !== r) {
          t[r] = t[o]
          const i = o * n,
            s = r * n
          for (let t = 0; t !== n; ++t) e[s + t] = e[i + t]
        }
        ++r
      }
    }
    if (s > 0) {
      t[r] = t[s]
      for (let t = s * n, i = r * n, o = 0; o !== n; ++o) e[i + o] = e[t + o]
      ++r
    }
    return (
      r !== t.length
        ? ((this.times = Zo.arraySlice(t, 0, r)), (this.values = Zo.arraySlice(e, 0, r * n)))
        : ((this.times = t), (this.values = e)),
      this
    )
  }
  clone() {
    const t = Zo.arraySlice(this.times, 0),
      e = Zo.arraySlice(this.values, 0),
      n = new (0, this.constructor)(this.name, t, e)
    return (n.createInterpolant = this.createInterpolant), n
  }
}
;($o.prototype.TimeBufferType = Float32Array),
  ($o.prototype.ValueBufferType = Float32Array),
  ($o.prototype.DefaultInterpolation = 2301)
class ta extends $o {}
;(ta.prototype.ValueTypeName = 'bool'),
  (ta.prototype.ValueBufferType = Array),
  (ta.prototype.DefaultInterpolation = 2300),
  (ta.prototype.InterpolantFactoryMethodLinear = void 0),
  (ta.prototype.InterpolantFactoryMethodSmooth = void 0)
class ea extends $o {}
ea.prototype.ValueTypeName = 'color'
class na extends $o {}
na.prototype.ValueTypeName = 'number'
class ia extends Xo {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      o = this.valueSize,
      a = (n - e) / (i - e)
    let l = t * o
    for (let t = l + o; l !== t; l += 4) V.slerpFlat(s, 0, r, l - o, r, l, a)
    return s
  }
}
class sa extends $o {
  InterpolantFactoryMethodLinear(t) {
    return new ia(this.times, this.values, this.getValueSize(), t)
  }
}
;(sa.prototype.ValueTypeName = 'quaternion'),
  (sa.prototype.DefaultInterpolation = 2301),
  (sa.prototype.InterpolantFactoryMethodSmooth = void 0)
class ra extends $o {}
;(ra.prototype.ValueTypeName = 'string'),
  (ra.prototype.ValueBufferType = Array),
  (ra.prototype.DefaultInterpolation = 2300),
  (ra.prototype.InterpolantFactoryMethodLinear = void 0),
  (ra.prototype.InterpolantFactoryMethodSmooth = void 0)
class oa extends $o {}
oa.prototype.ValueTypeName = 'vector'
class aa {
  constructor(t, e = -1, n, i = 2500) {
    ;(this.name = t),
      (this.tracks = n),
      (this.duration = e),
      (this.blendMode = i),
      (this.uuid = d()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(t) {
    const e = [],
      n = t.tracks,
      i = 1 / (t.fps || 1)
    for (let t = 0, s = n.length; t !== s; ++t) e.push(la(n[t]).scale(i))
    const s = new this(t.name, t.duration, e, t.blendMode)
    return (s.uuid = t.uuid), s
  }
  static toJSON(t) {
    const e = [],
      n = t.tracks,
      i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }
    for (let t = 0, i = n.length; t !== i; ++t) e.push($o.toJSON(n[t]))
    return i
  }
  static CreateFromMorphTargetSequence(t, e, n, i) {
    const s = e.length,
      r = []
    for (let t = 0; t < s; t++) {
      let o = [],
        a = []
      o.push((t + s - 1) % s, t, (t + 1) % s), a.push(0, 1, 0)
      const l = Zo.getKeyframeOrder(o)
      ;(o = Zo.sortedArray(o, 1, l)),
        (a = Zo.sortedArray(a, 1, l)),
        i || 0 !== o[0] || (o.push(s), a.push(a[0])),
        r.push(new na('.morphTargetInfluences[' + e[t].name + ']', o, a).scale(1 / n))
    }
    return new this(t, -1, r)
  }
  static findByName(t, e) {
    let n = t
    if (!Array.isArray(t)) {
      const e = t
      n = (e.geometry && e.geometry.animations) || e.animations
    }
    for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t]
    return null
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/
    for (let e = 0, n = t.length; e < n; e++) {
      const n = t[e],
        r = n.name.match(s)
      if (r && r.length > 1) {
        const t = r[1]
        let e = i[t]
        e || (i[t] = e = []), e.push(n)
      }
    }
    const r = []
    for (const t in i) r.push(this.CreateFromMorphTargetSequence(t, i[t], e, n))
    return r
  }
  static parseAnimation(t, e) {
    if (!t) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null
    const n = function (t, e, n, i, s) {
        if (0 !== n.length) {
          const r = [],
            o = []
          Zo.flattenJSON(n, r, o, i), 0 !== r.length && s.push(new t(e, r, o))
        }
      },
      i = [],
      s = t.name || 'default',
      r = t.fps || 30,
      o = t.blendMode
    let a = t.length || -1
    const l = t.hierarchy || []
    for (let t = 0; t < l.length; t++) {
      const s = l[t].keys
      if (s && 0 !== s.length)
        if (s[0].morphTargets) {
          const t = {}
          let e
          for (e = 0; e < s.length; e++)
            if (s[e].morphTargets)
              for (let n = 0; n < s[e].morphTargets.length; n++) t[s[e].morphTargets[n]] = -1
          for (const n in t) {
            const t = [],
              r = []
            for (let i = 0; i !== s[e].morphTargets.length; ++i) {
              const i = s[e]
              t.push(i.time), r.push(i.morphTarget === n ? 1 : 0)
            }
            i.push(new na('.morphTargetInfluence[' + n + ']', t, r))
          }
          a = t.length * r
        } else {
          const r = '.bones[' + e[t].name + ']'
          n(oa, r + '.position', s, 'pos', i),
            n(sa, r + '.quaternion', s, 'rot', i),
            n(oa, r + '.scale', s, 'scl', i)
        }
    }
    if (0 === i.length) return null
    return new this(s, a, i, o)
  }
  resetDuration() {
    let t = 0
    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
      const n = this.tracks[e]
      t = Math.max(t, n.times[n.times.length - 1])
    }
    return (this.duration = t), this
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration)
    return this
  }
  validate() {
    let t = !0
    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate()
    return t
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
    return this
  }
  clone() {
    const t = []
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone())
    return new this.constructor(this.name, this.duration, t, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function la(t) {
  if (void 0 === t.type) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  const e = (function (t) {
    switch (t.toLowerCase()) {
      case 'scalar':
      case 'double':
      case 'float':
      case 'number':
      case 'integer':
        return na
      case 'vector':
      case 'vector2':
      case 'vector3':
      case 'vector4':
        return oa
      case 'color':
        return ea
      case 'quaternion':
        return sa
      case 'bool':
      case 'boolean':
        return ta
      case 'string':
        return ra
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t)
  })(t.type)
  if (void 0 === t.times) {
    const e = [],
      n = []
    Zo.flattenJSON(t.keys, e, n, 'value'), (t.times = e), (t.values = n)
  }
  return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
}
const ha = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    !1 !== this.enabled && (this.files[t] = e)
  },
  get: function (t) {
    if (!1 !== this.enabled) return this.files[t]
  },
  remove: function (t) {
    delete this.files[t]
  },
  clear: function () {
    this.files = {}
  }
}
const ca = new (class {
  constructor(t, e, n) {
    const i = this
    let s,
      r = !1,
      o = 0,
      a = 0
    const l = []
    ;(this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (t) {
        a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), (r = !0)
      }),
      (this.itemEnd = function (t) {
        o++,
          void 0 !== i.onProgress && i.onProgress(t, o, a),
          o === a && ((r = !1), void 0 !== i.onLoad && i.onLoad())
      }),
      (this.itemError = function (t) {
        void 0 !== i.onError && i.onError(t)
      }),
      (this.resolveURL = function (t) {
        return s ? s(t) : t
      }),
      (this.setURLModifier = function (t) {
        return (s = t), this
      }),
      (this.addHandler = function (t, e) {
        return l.push(t, e), this
      }),
      (this.removeHandler = function (t) {
        const e = l.indexOf(t)
        return -1 !== e && l.splice(e, 2), this
      }),
      (this.getHandler = function (t) {
        for (let e = 0, n = l.length; e < n; e += 2) {
          const n = l[e],
            i = l[e + 1]
          if ((n.global && (n.lastIndex = 0), n.test(t))) return i
        }
        return null
      })
  }
})()
class ua {
  constructor(t) {
    ;(this.manager = void 0 !== t ? t : ca),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(t, e) {
    const n = this
    return new Promise(function (i, s) {
      n.load(t, i, e, s)
    })
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this
  }
  setPath(t) {
    return (this.path = t), this
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this
  }
}
const da = {}
class pa extends ua {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    void 0 === t && (t = ''),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const s = ha.get(t)
    if (void 0 !== s)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          e && e(s), this.manager.itemEnd(t)
        }, 0),
        s
      )
    if (void 0 !== da[t]) return void da[t].push({ onLoad: e, onProgress: n, onError: i })
    ;(da[t] = []), da[t].push({ onLoad: e, onProgress: n, onError: i })
    const r = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin'
      }),
      o = this.mimeType,
      a = this.responseType
    fetch(r)
      .then((e) => {
        if (200 === e.status || 0 === e.status) {
          if (
            (0 === e.status && console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            'undefined' == typeof ReadableStream ||
              void 0 === e.body ||
              void 0 === e.body.getReader)
          )
            return e
          const n = da[t],
            i = e.body.getReader(),
            s = e.headers.get('Content-Length'),
            r = s ? parseInt(s) : 0,
            o = 0 !== r
          let a = 0
          const l = new ReadableStream({
            start(t) {
              !(function e() {
                i.read().then(({ done: i, value: s }) => {
                  if (i) t.close()
                  else {
                    a += s.byteLength
                    const i = new ProgressEvent('progress', {
                      lengthComputable: o,
                      loaded: a,
                      total: r
                    })
                    for (let t = 0, e = n.length; t < e; t++) {
                      const e = n[t]
                      e.onProgress && e.onProgress(i)
                    }
                    t.enqueue(s), e()
                  }
                })
              })()
            }
          })
          return new Response(l)
        }
        throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
      })
      .then((t) => {
        switch (a) {
          case 'arraybuffer':
            return t.arrayBuffer()
          case 'blob':
            return t.blob()
          case 'document':
            return t.text().then((t) => new DOMParser().parseFromString(t, o))
          case 'json':
            return t.json()
          default:
            if (void 0 === o) return t.text()
            {
              const e = /charset="?([^;"\s]*)"?/i.exec(o),
                n = e && e[1] ? e[1].toLowerCase() : void 0,
                i = new TextDecoder(n)
              return t.arrayBuffer().then((t) => i.decode(t))
            }
        }
      })
      .then((e) => {
        ha.add(t, e)
        const n = da[t]
        delete da[t]
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t]
          i.onLoad && i.onLoad(e)
        }
      })
      .catch((e) => {
        const n = da[t]
        if (void 0 === n) throw (this.manager.itemError(t), e)
        delete da[t]
        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t]
          i.onError && i.onError(e)
        }
        this.manager.itemError(t)
      })
      .finally(() => {
        this.manager.itemEnd(t)
      }),
      this.manager.itemStart(t)
  }
  setResponseType(t) {
    return (this.responseType = t), this
  }
  setMimeType(t) {
    return (this.mimeType = t), this
  }
}
class ga extends ua {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t))
    const s = this,
      r = ha.get(t)
    if (void 0 !== r)
      return (
        s.manager.itemStart(t),
        setTimeout(function () {
          e && e(r), s.manager.itemEnd(t)
        }, 0),
        r
      )
    const o = b('img')
    function a() {
      h(), ha.add(t, this), e && e(this), s.manager.itemEnd(t)
    }
    function l(e) {
      h(), i && i(e), s.manager.itemError(t), s.manager.itemEnd(t)
    }
    function h() {
      o.removeEventListener('load', a, !1), o.removeEventListener('error', l, !1)
    }
    return (
      o.addEventListener('load', a, !1),
      o.addEventListener('error', l, !1),
      'data:' !== t.slice(0, 5) &&
        void 0 !== this.crossOrigin &&
        (o.crossOrigin = this.crossOrigin),
      s.manager.itemStart(t),
      (o.src = t),
      o
    )
  }
}
class fa extends ua {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = new je(),
      r = new ga(this.manager)
    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path)
    let o = 0
    function a(n) {
      r.load(
        t[n],
        function (t) {
          ;(s.images[n] = t), o++, 6 === o && ((s.needsUpdate = !0), e && e(s))
        },
        void 0,
        i
      )
    }
    for (let e = 0; e < t.length; ++e) a(e)
    return s
  }
}
class ma extends ua {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = new F(),
      r = new ga(this.manager)
    return (
      r.setCrossOrigin(this.crossOrigin),
      r.setPath(this.path),
      r.load(
        t,
        function (t) {
          ;(s.image = t), (s.needsUpdate = !0), void 0 !== e && e(s)
        },
        n,
        i
      ),
      s
    )
  }
}
class ya extends Wt {
  constructor(t, e = 1) {
    super(), (this.type = 'Light'), (this.color = new L(t)), (this.intensity = e)
  }
  dispose() {}
  copy(t) {
    return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (e.object.distance = this.distance),
      void 0 !== this.angle && (e.object.angle = this.angle),
      void 0 !== this.decay && (e.object.decay = this.decay),
      void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
      e
    )
  }
}
ya.prototype.isLight = !0
;(class extends ya {
  constructor(t, e, n) {
    super(t, n),
      (this.type = 'HemisphereLight'),
      this.position.copy(Wt.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new L(e))
  }
  copy(t) {
    return ya.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
  }
}).prototype.isHemisphereLight = !0
const xa = new vt(),
  va = new H(),
  _a = new H()
class wa {
  constructor(t) {
    ;(this.camera = t),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new _(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new vt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new tn()),
      (this._frameExtents = new _(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new G(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(t) {
    const e = this.camera,
      n = this.matrix
    va.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(va),
      _a.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(_a),
      e.updateMatrixWorld(),
      xa.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(xa),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(e.projectionMatrix),
      n.multiply(e.matrixWorldInverse)
  }
  getViewport(t) {
    return this._viewports[t]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const t = {}
    return (
      0 !== this.bias && (t.bias = this.bias),
      0 !== this.normalBias && (t.normalBias = this.normalBias),
      1 !== this.radius && (t.radius = this.radius),
      (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    )
  }
}
class Ea extends wa {
  constructor() {
    super(new We(50, 1, 0.5, 500)), (this.focus = 1)
  }
  updateMatrices(t) {
    const e = this.camera,
      n = 2 * u * t.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = t.distance || e.far
    ;(n === e.fov && i === e.aspect && s === e.far) ||
      ((e.fov = n), (e.aspect = i), (e.far = s), e.updateProjectionMatrix()),
      super.updateMatrices(t)
  }
  copy(t) {
    return super.copy(t), (this.focus = t.focus), this
  }
}
Ea.prototype.isSpotLightShadow = !0
class ba extends ya {
  constructor(t, e, n = 0, i = Math.PI / 3, s = 0, r = 1) {
    super(t, e),
      (this.type = 'SpotLight'),
      this.position.copy(Wt.DefaultUp),
      this.updateMatrix(),
      (this.target = new Wt()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = r),
      (this.shadow = new Ea())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(t) {
    this.intensity = t / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t) {
    return (
      super.copy(t),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
ba.prototype.isSpotLight = !0
const Ma = new vt(),
  Sa = new H(),
  Aa = new H()
class Ta extends wa {
  constructor() {
    super(new We(90, 1, 0.5, 500)),
      (this._frameExtents = new _(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new G(2, 1, 1, 1),
        new G(0, 1, 1, 1),
        new G(3, 1, 1, 1),
        new G(1, 1, 1, 1),
        new G(3, 0, 1, 1),
        new G(1, 0, 1, 1)
      ]),
      (this._cubeDirections = [
        new H(1, 0, 0),
        new H(-1, 0, 0),
        new H(0, 0, 1),
        new H(0, 0, -1),
        new H(0, 1, 0),
        new H(0, -1, 0)
      ]),
      (this._cubeUps = [
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 0, 1),
        new H(0, 0, -1)
      ])
  }
  updateMatrices(t, e = 0) {
    const n = this.camera,
      i = this.matrix,
      s = t.distance || n.far
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      Sa.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(Sa),
      Aa.copy(n.position),
      Aa.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(Aa),
      n.updateMatrixWorld(),
      i.makeTranslation(-Sa.x, -Sa.y, -Sa.z),
      Ma.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Ma)
  }
}
Ta.prototype.isPointLightShadow = !0
class Ia extends ya {
  constructor(t, e, n = 0, i = 1) {
    super(t, e),
      (this.type = 'PointLight'),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new Ta())
  }
  get power() {
    return 4 * this.intensity * Math.PI
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t) {
    return (
      super.copy(t),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
Ia.prototype.isPointLight = !0
class Ra extends wa {
  constructor() {
    super(new gn(-5, 5, 5, -5, 0.5, 500))
  }
}
Ra.prototype.isDirectionalLightShadow = !0
class La extends ya {
  constructor(t, e) {
    super(t, e),
      (this.type = 'DirectionalLight'),
      this.position.copy(Wt.DefaultUp),
      this.updateMatrix(),
      (this.target = new Wt()),
      (this.shadow = new Ra())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t) {
    return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this
  }
}
La.prototype.isDirectionalLight = !0
class Ca extends ya {
  constructor(t, e) {
    super(t, e), (this.type = 'AmbientLight')
  }
}
Ca.prototype.isAmbientLight = !0
;(class extends ya {
  constructor(t, e, n = 10, i = 10) {
    super(t, e), (this.type = 'RectAreaLight'), (this.width = n), (this.height = i)
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(t) {
    this.intensity = t / (this.width * this.height * Math.PI)
  }
  copy(t) {
    return super.copy(t), (this.width = t.width), (this.height = t.height), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (e.object.width = this.width), (e.object.height = this.height), e
  }
}).prototype.isRectAreaLight = !0
class Na {
  constructor() {
    this.coefficients = []
    for (let t = 0; t < 9; t++) this.coefficients.push(new H())
  }
  set(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
    return this
  }
  zero() {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0)
    return this
  }
  getAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = this.coefficients
    return (
      e.copy(r[0]).multiplyScalar(0.282095),
      e.addScaledVector(r[1], 0.488603 * i),
      e.addScaledVector(r[2], 0.488603 * s),
      e.addScaledVector(r[3], 0.488603 * n),
      e.addScaledVector(r[4], n * i * 1.092548),
      e.addScaledVector(r[5], i * s * 1.092548),
      e.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)),
      e.addScaledVector(r[7], n * s * 1.092548),
      e.addScaledVector(r[8], 0.546274 * (n * n - i * i)),
      e
    )
  }
  getIrradianceAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z,
      r = this.coefficients
    return (
      e.copy(r[0]).multiplyScalar(0.886227),
      e.addScaledVector(r[1], 1.023328 * i),
      e.addScaledVector(r[2], 1.023328 * s),
      e.addScaledVector(r[3], 1.023328 * n),
      e.addScaledVector(r[4], 0.858086 * n * i),
      e.addScaledVector(r[5], 0.858086 * i * s),
      e.addScaledVector(r[6], 0.743125 * s * s - 0.247708),
      e.addScaledVector(r[7], 0.858086 * n * s),
      e.addScaledVector(r[8], 0.429043 * (n * n - i * i)),
      e
    )
  }
  add(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e])
    return this
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e)
    return this
  }
  scale(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t)
    return this
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e)
    return this
  }
  equals(t) {
    for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1
    return !0
  }
  copy(t) {
    return this.set(t.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(t, e = 0) {
    const n = this.coefficients
    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i)
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.coefficients
    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i)
    return t
  }
  static getBasisAt(t, e) {
    const n = t.x,
      i = t.y,
      s = t.z
    ;(e[0] = 0.282095),
      (e[1] = 0.488603 * i),
      (e[2] = 0.488603 * s),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * i),
      (e[5] = 1.092548 * i * s),
      (e[6] = 0.315392 * (3 * s * s - 1)),
      (e[7] = 1.092548 * n * s),
      (e[8] = 0.546274 * (n * n - i * i))
  }
}
Na.prototype.isSphericalHarmonics3 = !0
class Pa extends ya {
  constructor(t = new Na(), e = 1) {
    super(void 0, e), (this.sh = t)
  }
  copy(t) {
    return super.copy(t), this.sh.copy(t.sh), this
  }
  fromJSON(t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (e.object.sh = this.sh.toArray()), e
  }
}
Pa.prototype.isLightProbe = !0
class Da {
  static decodeText(t) {
    if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t)
    let e = ''
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n])
    try {
      return decodeURIComponent(escape(e))
    } catch (t) {
      return e
    }
  }
  static extractUrlBase(t) {
    const e = t.lastIndexOf('/')
    return -1 === e ? './' : t.slice(0, e + 1)
  }
  static resolveURL(t, e) {
    return 'string' != typeof t || '' === t
      ? ''
      : (/^https?:\/\//i.test(e) &&
          /^\//.test(t) &&
          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
  }
}
;(class extends xe {
  constructor() {
    super(), (this.type = 'InstancedBufferGeometry'), (this.instanceCount = 1 / 0)
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const t = super.toJSON(this)
    return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t
  }
}).prototype.isInstancedBufferGeometry = !0
class Oa extends ua {
  constructor(t) {
    super(t),
      'undefined' == typeof createImageBitmap &&
        console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
      'undefined' == typeof fetch &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' })
  }
  setOptions(t) {
    return (this.options = t), this
  }
  load(t, e, n, i) {
    void 0 === t && (t = ''),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const s = this,
      r = ha.get(t)
    if (void 0 !== r)
      return (
        s.manager.itemStart(t),
        setTimeout(function () {
          e && e(r), s.manager.itemEnd(t)
        }, 0),
        r
      )
    const o = {}
    ;(o.credentials = 'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
      (o.headers = this.requestHeader),
      fetch(t, o)
        .then(function (t) {
          return t.blob()
        })
        .then(function (t) {
          return createImageBitmap(t, Object.assign(s.options, { colorSpaceConversion: 'none' }))
        })
        .then(function (n) {
          ha.add(t, n), e && e(n), s.manager.itemEnd(t)
        })
        .catch(function (e) {
          i && i(e), s.manager.itemError(t), s.manager.itemEnd(t)
        }),
      s.manager.itemStart(t)
  }
}
let Fa
Oa.prototype.isImageBitmapLoader = !0
const Ga = function () {
  return void 0 === Fa && (Fa = new (window.AudioContext || window.webkitAudioContext)()), Fa
}
class za extends ua {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const s = this,
      r = new pa(this.manager)
    r.setResponseType('arraybuffer'),
      r.setPath(this.path),
      r.setRequestHeader(this.requestHeader),
      r.setWithCredentials(this.withCredentials),
      r.load(
        t,
        function (n) {
          try {
            const t = n.slice(0)
            Ga().decodeAudioData(t, function (t) {
              e(t)
            })
          } catch (e) {
            i ? i(e) : console.error(e), s.manager.itemError(t)
          }
        },
        n,
        i
      )
  }
}
;(class extends Pa {
  constructor(t, e, n = 1) {
    super(void 0, n)
    const i = new L().set(t),
      s = new L().set(e),
      r = new H(i.r, i.g, i.b),
      o = new H(s.r, s.g, s.b),
      a = Math.sqrt(Math.PI),
      l = a * Math.sqrt(0.75)
    this.sh.coefficients[0].copy(r).add(o).multiplyScalar(a),
      this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(l)
  }
}).prototype.isHemisphereLightProbe = !0
;(class extends Pa {
  constructor(t, e = 1) {
    super(void 0, e)
    const n = new L().set(t)
    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
  }
}).prototype.isAmbientLightProbe = !0
class Ba {
  constructor(t = !0) {
    ;(this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = Ua()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let t = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const e = Ua()
      ;(t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t)
    }
    return t
  }
}
function Ua() {
  return ('undefined' == typeof performance ? Date : performance).now()
}
class Va {
  constructor(t, e, n) {
    let i, s, r
    switch (((this.binding = t), (this.valueSize = n), e)) {
      case 'quaternion':
        ;(i = this._slerp),
          (s = this._slerpAdditive),
          (r = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(6 * n)),
          (this._workIndex = 5)
        break
      case 'string':
      case 'bool':
        ;(i = this._select),
          (s = this._select),
          (r = this._setAdditiveIdentityOther),
          (this.buffer = new Array(5 * n))
        break
      default:
        ;(i = this._lerp),
          (s = this._lerpAdditive),
          (r = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(5 * n))
    }
    ;(this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = r),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0)
  }
  accumulate(t, e) {
    const n = this.buffer,
      i = this.valueSize,
      s = t * i + i
    let r = this.cumulativeWeight
    if (0 === r) {
      for (let t = 0; t !== i; ++t) n[s + t] = n[t]
      r = e
    } else {
      r += e
      const t = e / r
      this._mixBufferRegion(n, s, 0, t, i)
    }
    this.cumulativeWeight = r
  }
  accumulateAdditive(t) {
    const e = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex
    0 === this.cumulativeWeightAdditive && this._setIdentity(),
      this._mixBufferRegionAdditive(e, i, 0, t, n),
      (this.cumulativeWeightAdditive += t)
  }
  apply(t) {
    const e = this.valueSize,
      n = this.buffer,
      i = t * e + e,
      s = this.cumulativeWeight,
      r = this.cumulativeWeightAdditive,
      o = this.binding
    if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)) {
      const t = e * this._origIndex
      this._mixBufferRegion(n, i, t, 1 - s, e)
    }
    r > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e)
    for (let t = e, s = e + e; t !== s; ++t)
      if (n[t] !== n[t + e]) {
        o.setValue(n, i)
        break
      }
  }
  saveOriginalState() {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex
    t.getValue(e, i)
    for (let t = n, s = i; t !== s; ++t) e[t] = e[i + (t % n)]
    this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0)
  }
  restoreOriginalState() {
    const t = 3 * this.valueSize
    this.binding.setValue(this.buffer, t)
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize
    for (let n = t; n < e; n++) this.buffer[n] = 0
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1)
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize
    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
  }
  _select(t, e, n, i, s) {
    if (i >= 0.5) for (let i = 0; i !== s; ++i) t[e + i] = t[n + i]
  }
  _slerp(t, e, n, i) {
    V.slerpFlat(t, e, t, e, t, n, i)
  }
  _slerpAdditive(t, e, n, i, s) {
    const r = this._workIndex * s
    V.multiplyQuaternionsFlat(t, r, t, e, t, n), V.slerpFlat(t, e, t, e, t, r, i)
  }
  _lerp(t, e, n, i, s) {
    const r = 1 - i
    for (let o = 0; o !== s; ++o) {
      const s = e + o
      t[s] = t[s] * r + t[n + o] * i
    }
  }
  _lerpAdditive(t, e, n, i, s) {
    for (let r = 0; r !== s; ++r) {
      const s = e + r
      t[s] = t[s] + t[n + r] * i
    }
  }
}
const Ha = new RegExp('[\\[\\]\\.:\\/]', 'g'),
  ka = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
  Wa = /((?:WC+[\/:])*)/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
  Ya = /(WCOD+)?/.source.replace('WCOD', ka),
  ja = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
  qa = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
  Za = new RegExp('^' + Wa + Ya + ja + qa + '$'),
  Xa = ['material', 'materials', 'bones']
class Ka {
  constructor(t, e, n) {
    ;(this.path = e),
      (this.parsedPath = n || Ka.parseTrackName(e)),
      (this.node = Ka.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup ? new Ka.Composite(t, e, n) : new Ka(t, e, n)
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, '_').replace(Ha, '')
  }
  static parseTrackName(t) {
    const e = Za.exec(t)
    if (null === e) throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6]
      },
      i = n.nodeName && n.nodeName.lastIndexOf('.')
    if (void 0 !== i && -1 !== i) {
      const t = n.nodeName.substring(i + 1)
      ;-1 !== Xa.indexOf(t) && ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t))
    }
    if (null === n.propertyName || 0 === n.propertyName.length)
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + t)
    return n
  }
  static findNode(t, e) {
    if (void 0 === e || '' === e || '.' === e || -1 === e || e === t.name || e === t.uuid) return t
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e)
      if (void 0 !== n) return n
    }
    if (t.children) {
      const n = function (t) {
          for (let i = 0; i < t.length; i++) {
            const s = t[i]
            if (s.name === e || s.uuid === e) return s
            const r = n(s.children)
            if (r) return r
          }
          return null
        },
        i = n(t.children)
      if (i) return i
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName]
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) t[e++] = n[i]
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e)
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e]
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = t[e++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e]
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e)
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e)
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e)
  }
  bind() {
    let t = this.node
    const e = this.parsedPath,
      n = e.objectName,
      i = e.propertyName
    let s = e.propertyIndex
    if (
      (t || ((t = Ka.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    )
      return void console.error(
        'THREE.PropertyBinding: Trying to update node for track: ' +
          this.path +
          " but it wasn't found."
      )
    if (n) {
      let i = e.objectIndex
      switch (n) {
        case 'materials':
          if (!t.material)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this
            )
          if (!t.material.materials)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this
            )
          t = t.material.materials
          break
        case 'bones':
          if (!t.skeleton)
            return void console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this
            )
          t = t.skeleton.bones
          for (let e = 0; e < t.length; e++)
            if (t[e].name === i) {
              i = e
              break
            }
          break
        default:
          if (void 0 === t[n])
            return void console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this
            )
          t = t[n]
      }
      if (void 0 !== i) {
        if (void 0 === t[i])
          return void console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            t
          )
        t = t[i]
      }
    }
    const r = t[i]
    if (void 0 === r) {
      const n = e.nodeName
      return void console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          n +
          '.' +
          i +
          " but it wasn't found.",
        t
      )
    }
    let o = this.Versioning.None
    ;(this.targetObject = t),
      void 0 !== t.needsUpdate
        ? (o = this.Versioning.NeedsUpdate)
        : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate)
    let a = this.BindingType.Direct
    if (void 0 !== s) {
      if ('morphTargetInfluences' === i) {
        if (!t.geometry)
          return void console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this
          )
        if (!t.geometry.isBufferGeometry)
          return void console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
            this
          )
        if (!t.geometry.morphAttributes)
          return void console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this
          )
        void 0 !== t.morphTargetDictionary[s] && (s = t.morphTargetDictionary[s])
      }
      ;(a = this.BindingType.ArrayElement), (this.resolvedProperty = r), (this.propertyIndex = s)
    } else
      void 0 !== r.fromArray && void 0 !== r.toArray
        ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = r))
        : Array.isArray(r)
          ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = r))
          : (this.propertyName = i)
    ;(this.getValue = this.GetterByBindingType[a]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[a][o])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
;(Ka.Composite = class {
  constructor(t, e, n) {
    const i = n || Ka.parseTrackName(e)
    ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, i))
  }
  getValue(t, e) {
    this.bind()
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n]
    void 0 !== i && i.getValue(t, e)
  }
  setValue(t, e) {
    const n = this._bindings
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(t, e)
  }
  bind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
  }
  unbind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
  }
}),
  (Ka.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
  (Ka.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
  (Ka.prototype.GetterByBindingType = [
    Ka.prototype._getValue_direct,
    Ka.prototype._getValue_array,
    Ka.prototype._getValue_arrayElement,
    Ka.prototype._getValue_toArray
  ]),
  (Ka.prototype.SetterByBindingTypeAndVersioning = [
    [
      Ka.prototype._setValue_direct,
      Ka.prototype._setValue_direct_setNeedsUpdate,
      Ka.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      Ka.prototype._setValue_array,
      Ka.prototype._setValue_array_setNeedsUpdate,
      Ka.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      Ka.prototype._setValue_arrayElement,
      Ka.prototype._setValue_arrayElement_setNeedsUpdate,
      Ka.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      Ka.prototype._setValue_fromArray,
      Ka.prototype._setValue_fromArray_setNeedsUpdate,
      Ka.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ])
class Ja {
  constructor(t, e, n = null, i = e.blendMode) {
    ;(this._mixer = t), (this._clip = e), (this._localRoot = n), (this.blendMode = i)
    const s = e.tracks,
      r = s.length,
      o = new Array(r),
      a = { endingStart: 2400, endingEnd: 2400 }
    for (let t = 0; t !== r; ++t) {
      const e = s[t].createInterpolant(null)
      ;(o[t] = e), (e.settings = a)
    }
    ;(this._interpolantSettings = a),
      (this._interpolants = o),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0)
  }
  play() {
    return this._mixer._activateAction(this), this
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset()
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      0 !== this.timeScale &&
      null === this._startTime &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(t) {
    return (this._startTime = t), this
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this
  }
  setEffectiveWeight(t) {
    return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading()
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1)
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0)
  }
  crossFadeFrom(t, e, n) {
    if ((t.fadeOut(e), this.fadeIn(e), n)) {
      const n = this._clip.duration,
        i = t._clip.duration,
        s = i / n,
        r = n / i
      t.warp(1, s, e), this.warp(r, 1, e)
    }
    return this
  }
  crossFadeTo(t, e, n) {
    return t.crossFadeFrom(this, e, n)
  }
  stopFading() {
    const t = this._weightInterpolant
    return (
      null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
      this
    )
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping()
  }
  syncWith(t) {
    return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t)
  }
  warp(t, e, n) {
    const i = this._mixer,
      s = i.time,
      r = this.timeScale
    let o = this._timeScaleInterpolant
    null === o && ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o))
    const a = o.parameterPositions,
      l = o.sampleValues
    return (a[0] = s), (a[1] = s + n), (l[0] = t / r), (l[1] = e / r), this
  }
  stopWarping() {
    const t = this._timeScaleInterpolant
    return (
      null !== t &&
        ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(t, e, n, i) {
    if (!this.enabled) return void this._updateWeight(t)
    const s = this._startTime
    if (null !== s) {
      const i = (t - s) * n
      if (i < 0 || 0 === n) return
      ;(this._startTime = null), (e = n * i)
    }
    e *= this._updateTimeScale(t)
    const r = this._updateTime(e),
      o = this._updateWeight(t)
    if (o > 0) {
      const t = this._interpolants,
        e = this._propertyBindings
      if (2501 === this.blendMode)
        for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(r), e[n].accumulateAdditive(o)
      else for (let n = 0, s = t.length; n !== s; ++n) t[n].evaluate(r), e[n].accumulate(i, o)
    }
  }
  _updateWeight(t) {
    let e = 0
    if (this.enabled) {
      e = this.weight
      const n = this._weightInterpolant
      if (null !== n) {
        const i = n.evaluate(t)[0]
        ;(e *= i),
          t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
      }
    }
    return (this._effectiveWeight = e), e
  }
  _updateTimeScale(t) {
    let e = 0
    if (!this.paused) {
      e = this.timeScale
      const n = this._timeScaleInterpolant
      if (null !== n) {
        ;(e *= n.evaluate(t)[0]),
          t > n.parameterPositions[1] &&
            (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e))
      }
    }
    return (this._effectiveTimeScale = e), e
  }
  _updateTime(t) {
    const e = this._clip.duration,
      n = this.loop
    let i = this.time + t,
      s = this._loopCount
    const r = 2202 === n
    if (0 === t) return -1 === s ? i : r && 1 == (1 & s) ? e - i : i
    if (2200 === n) {
      ;-1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      t: {
        if (i >= e) i = e
        else {
          if (!(i < 0)) {
            this.time = i
            break t
          }
          i = 0
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t < 0 ? -1 : 1 })
      }
    } else {
      if (
        (-1 === s &&
          (t >= 0
            ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, r))
            : this._setEndings(0 === this.repetitions, !0, r)),
        i >= e || i < 0)
      ) {
        const n = Math.floor(i / e)
        ;(i -= e * n), (s += Math.abs(n))
        const o = this.repetitions - s
        if (o <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = t > 0 ? e : 0),
            (this.time = i),
            this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t > 0 ? 1 : -1 })
        else {
          if (1 === o) {
            const e = t < 0
            this._setEndings(e, !e, r)
          } else this._setEndings(!1, !1, r)
          ;(this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: n })
        }
      } else this.time = i
      if (r && 1 == (1 & s)) return e - i
    }
    return i
  }
  _setEndings(t, e, n) {
    const i = this._interpolantSettings
    n
      ? ((i.endingStart = 2401), (i.endingEnd = 2401))
      : ((i.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
        (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402))
  }
  _scheduleFading(t, e, n) {
    const i = this._mixer,
      s = i.time
    let r = this._weightInterpolant
    null === r && ((r = i._lendControlInterpolant()), (this._weightInterpolant = r))
    const o = r.parameterPositions,
      a = r.sampleValues
    return (o[0] = s), (a[0] = e), (o[1] = s + t), (a[1] = n), this
  }
}
;(class extends a {
  constructor(t) {
    super(),
      (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1)
  }
  _bindAction(t, e) {
    const n = t._localRoot || this._root,
      i = t._clip.tracks,
      s = i.length,
      r = t._propertyBindings,
      o = t._interpolants,
      a = n.uuid,
      l = this._bindingsByRootAndName
    let h = l[a]
    void 0 === h && ((h = {}), (l[a] = h))
    for (let t = 0; t !== s; ++t) {
      const s = i[t],
        l = s.name
      let c = h[l]
      if (void 0 !== c) ++c.referenceCount, (r[t] = c)
      else {
        if (((c = r[t]), void 0 !== c)) {
          null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, a, l))
          continue
        }
        const i = e && e._propertyBindings[t].binding.parsedPath
        ;(c = new Va(Ka.create(n, l, i), s.ValueTypeName, s.getValueSize())),
          ++c.referenceCount,
          this._addInactiveBinding(c, a, l),
          (r[t] = c)
      }
      o[t].resultBuffer = c.buffer
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (null === t._cacheIndex) {
        const e = (t._localRoot || this._root).uuid,
          n = t._clip.uuid,
          i = this._actionsByClip[n]
        this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
      }
      const e = t._propertyBindings
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t]
        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
      }
      this._lendAction(t)
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t]
        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
      }
      this._takeBackAction(t)
    }
  }
  _initMemoryManager() {
    ;(this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0)
    const t = this
    this.stats = {
      actions: {
        get total() {
          return t._actions.length
        },
        get inUse() {
          return t._nActiveActions
        }
      },
      bindings: {
        get total() {
          return t._bindings.length
        },
        get inUse() {
          return t._nActiveBindings
        }
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length
        },
        get inUse() {
          return t._nActiveControlInterpolants
        }
      }
    }
  }
  _isActiveAction(t) {
    const e = t._cacheIndex
    return null !== e && e < this._nActiveActions
  }
  _addInactiveAction(t, e, n) {
    const i = this._actions,
      s = this._actionsByClip
    let r = s[e]
    if (void 0 === r)
      (r = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (s[e] = r)
    else {
      const e = r.knownActions
      ;(t._byClipCacheIndex = e.length), e.push(t)
    }
    ;(t._cacheIndex = i.length), i.push(t), (r.actionByRoot[n] = t)
  }
  _removeInactiveAction(t) {
    const e = this._actions,
      n = e[e.length - 1],
      i = t._cacheIndex
    ;(n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null)
    const s = t._clip.uuid,
      r = this._actionsByClip,
      o = r[s],
      a = o.knownActions,
      l = a[a.length - 1],
      h = t._byClipCacheIndex
    ;(l._byClipCacheIndex = h), (a[h] = l), a.pop(), (t._byClipCacheIndex = null)
    delete o.actionByRoot[(t._localRoot || this._root).uuid],
      0 === a.length && delete r[s],
      this._removeInactiveBindingsForAction(t)
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings
    for (let t = 0, n = e.length; t !== n; ++t) {
      const n = e[t]
      0 == --n.referenceCount && this._removeInactiveBinding(n)
    }
  }
  _lendAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = this._nActiveActions++,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _takeBackAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = --this._nActiveActions,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _addInactiveBinding(t, e, n) {
    const i = this._bindingsByRootAndName,
      s = this._bindings
    let r = i[e]
    void 0 === r && ((r = {}), (i[e] = r)), (r[n] = t), (t._cacheIndex = s.length), s.push(t)
  }
  _removeInactiveBinding(t) {
    const e = this._bindings,
      n = t.binding,
      i = n.rootNode.uuid,
      s = n.path,
      r = this._bindingsByRootAndName,
      o = r[i],
      a = e[e.length - 1],
      l = t._cacheIndex
    ;(a._cacheIndex = l),
      (e[l] = a),
      e.pop(),
      delete o[s],
      0 === Object.keys(o).length && delete r[i]
  }
  _lendBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = this._nActiveBindings++,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _takeBackBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = --this._nActiveBindings,
      s = e[i]
    ;(t._cacheIndex = i), (e[i] = t), (s._cacheIndex = n), (e[n] = s)
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++
    let n = t[e]
    return (
      void 0 === n &&
        ((n = new Jo(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    )
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = e[i]
    ;(t.__cacheIndex = i), (e[i] = t), (s.__cacheIndex = n), (e[n] = s)
  }
  clipAction(t, e, n) {
    const i = e || this._root,
      s = i.uuid
    let r = 'string' == typeof t ? aa.findByName(i, t) : t
    const o = null !== r ? r.uuid : t,
      a = this._actionsByClip[o]
    let l = null
    if ((void 0 === n && (n = null !== r ? r.blendMode : 2500), void 0 !== a)) {
      const t = a.actionByRoot[s]
      if (void 0 !== t && t.blendMode === n) return t
      ;(l = a.knownActions[0]), null === r && (r = l._clip)
    }
    if (null === r) return null
    const h = new Ja(this, r, e, n)
    return this._bindAction(h, l), this._addInactiveAction(h, o, s), h
  }
  existingAction(t, e) {
    const n = e || this._root,
      i = n.uuid,
      s = 'string' == typeof t ? aa.findByName(n, t) : t,
      r = s ? s.uuid : t,
      o = this._actionsByClip[r]
    return (void 0 !== o && o.actionByRoot[i]) || null
  }
  stopAllAction() {
    const t = this._actions
    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop()
    return this
  }
  update(t) {
    t *= this.timeScale
    const e = this._actions,
      n = this._nActiveActions,
      i = (this.time += t),
      s = Math.sign(t),
      r = (this._accuIndex ^= 1)
    for (let o = 0; o !== n; ++o) {
      e[o]._update(i, t, s, r)
    }
    const o = this._bindings,
      a = this._nActiveBindings
    for (let t = 0; t !== a; ++t) o[t].apply(r)
    return this
  }
  setTime(t) {
    this.time = 0
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0
    return this.update(t)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(t) {
    const e = this._actions,
      n = t.uuid,
      i = this._actionsByClip,
      s = i[n]
    if (void 0 !== s) {
      const t = s.knownActions
      for (let n = 0, i = t.length; n !== i; ++n) {
        const i = t[n]
        this._deactivateAction(i)
        const s = i._cacheIndex,
          r = e[e.length - 1]
        ;(i._cacheIndex = null),
          (i._byClipCacheIndex = null),
          (r._cacheIndex = s),
          (e[s] = r),
          e.pop(),
          this._removeInactiveBindingsForAction(i)
      }
      delete i[n]
    }
  }
  uncacheRoot(t) {
    const e = t.uuid,
      n = this._actionsByClip
    for (const t in n) {
      const i = n[t].actionByRoot[e]
      void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
    }
    const i = this._bindingsByRootAndName[e]
    if (void 0 !== i)
      for (const t in i) {
        const e = i[t]
        e.restoreOriginalState(), this._removeInactiveBinding(e)
      }
  }
  uncacheAction(t, e) {
    const n = this.existingAction(t, e)
    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
  }
}).prototype._controlInterpolantsResultBuffer = new Float32Array(1)
;(class extends Fs {
  constructor(t, e, n = 1) {
    super(t, e), (this.meshPerAttribute = n)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  clone(t) {
    const e = super.clone(t)
    return (e.meshPerAttribute = this.meshPerAttribute), e
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e
  }
}).prototype.isInstancedInterleavedBuffer = !0
class Qa {
  constructor(t, e, n = 0, i = 1 / 0) {
    ;(this.ray = new xt(t, e)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Lt()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {}
      })
  }
  set(t, e) {
    this.ray.set(t, e)
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(),
        (this.camera = e))
      : e.isOrthographicCamera
        ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          (this.camera = e))
        : console.error('THREE.Raycaster: Unsupported camera type: ' + e.type)
  }
  intersectObject(t, e = !0, n = []) {
    return tl(t, this, n, e), n.sort($a), n
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, s = t.length; i < s; i++) tl(t[i], this, n, e)
    return n.sort($a), n
  }
}
function $a(t, e) {
  return t.distance - e.distance
}
function tl(t, e, n, i) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
    const i = t.children
    for (let t = 0, s = i.length; t < s; t++) tl(i[t], e, n, !0)
  }
}
class el {
  constructor(t = 1, e = 0, n = 0) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  set(t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  copy(t) {
    return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
  }
  makeSafe() {
    const t = 1e-6
    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z)
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)), (this.phi = Math.acos(p(e / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const nl = new H(),
  il = new H()
class sl {
  constructor(t = new H(), e = new H()) {
    ;(this.start = t), (this.end = e)
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(t) {
    return t.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start)
  }
  closestPointToPointParameter(t, e) {
    nl.subVectors(t, this.start), il.subVectors(this.end, this.start)
    const n = il.dot(il)
    let i = il.dot(nl) / n
    return e && (i = p(i, 0, 1)), i
  }
  closestPointToPoint(t, e, n) {
    const i = this.closestPointToPointParameter(t, e)
    return this.delta(n).multiplyScalar(i).add(this.start)
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const rl = new H(),
  ol = new vt(),
  al = new vt()
function ll(t) {
  const e = []
  !0 === t.isBone && e.push(t)
  for (let n = 0; n < t.children.length; n++) e.push.apply(e, ll(t.children[n]))
  return e
}
const hl = new Uint32Array(512),
  cl = new Uint32Array(512)
for (let t = 0; t < 256; ++t) {
  const e = t - 127
  e < -27
    ? ((hl[t] = 0), (hl[256 | t] = 32768), (cl[t] = 24), (cl[256 | t] = 24))
    : e < -14
      ? ((hl[t] = 1024 >> (-e - 14)),
        (hl[256 | t] = (1024 >> (-e - 14)) | 32768),
        (cl[t] = -e - 1),
        (cl[256 | t] = -e - 1))
      : e <= 15
        ? ((hl[t] = (e + 15) << 10),
          (hl[256 | t] = ((e + 15) << 10) | 32768),
          (cl[t] = 13),
          (cl[256 | t] = 13))
        : e < 128
          ? ((hl[t] = 31744), (hl[256 | t] = 64512), (cl[t] = 24), (cl[256 | t] = 24))
          : ((hl[t] = 31744), (hl[256 | t] = 64512), (cl[t] = 13), (cl[256 | t] = 13))
}
const ul = new Uint32Array(2048),
  dl = new Uint32Array(64),
  pl = new Uint32Array(64)
for (let t = 1; t < 1024; ++t) {
  let e = t << 13,
    n = 0
  for (; 0 == (8388608 & e); ) (e <<= 1), (n -= 8388608)
  ;(e &= -8388609), (n += 947912704), (ul[t] = e | n)
}
for (let t = 1024; t < 2048; ++t) ul[t] = 939524096 + ((t - 1024) << 13)
for (let t = 1; t < 31; ++t) dl[t] = t << 23
;(dl[31] = 1199570944), (dl[32] = 2147483648)
for (let t = 33; t < 63; ++t) dl[t] = 2147483648 + ((t - 32) << 23)
dl[63] = 3347054592
for (let t = 1; t < 64; ++t) 32 !== t && (pl[t] = 1024)
;(Fr.create = function (t, e) {
  return (
    console.log('THREE.Curve.create() has been deprecated'),
    (t.prototype = Object.create(Fr.prototype)),
    (t.prototype.constructor = t),
    (t.prototype.getPoint = e),
    t
  )
}),
  (no.prototype.fromPoints = function (t) {
    return (
      console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'),
      this.setFromPoints(t)
    )
  }),
  (class extends Ar {
    constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
      ;(n = new L(n)), (i = new L(i))
      const s = e / 2,
        r = t / e,
        o = t / 2,
        a = [],
        l = []
      for (let t = 0, h = 0, c = -o; t <= e; t++, c += r) {
        a.push(-o, 0, c, o, 0, c), a.push(c, 0, -o, c, 0, o)
        const e = t === s ? n : i
        e.toArray(l, h),
          (h += 3),
          e.toArray(l, h),
          (h += 3),
          e.toArray(l, h),
          (h += 3),
          e.toArray(l, h),
          (h += 3)
      }
      const h = new xe()
      h.setAttribute('position', new ce(a, 3)), h.setAttribute('color', new ce(l, 3))
      super(h, new yr({ vertexColors: !0, toneMapped: !1 })), (this.type = 'GridHelper')
    }
  }.prototype.setColors = function () {
    console.error(
      'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.'
    )
  }),
  (class extends Ar {
    constructor(t) {
      const e = ll(t),
        n = new xe(),
        i = [],
        s = [],
        r = new L(0, 0, 1),
        o = new L(0, 1, 0)
      for (let t = 0; t < e.length; t++) {
        const n = e[t]
        n.parent &&
          n.parent.isBone &&
          (i.push(0, 0, 0), i.push(0, 0, 0), s.push(r.r, r.g, r.b), s.push(o.r, o.g, o.b))
      }
      n.setAttribute('position', new ce(i, 3)), n.setAttribute('color', new ce(s, 3))
      super(
        n,
        new yr({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })
      ),
        (this.type = 'SkeletonHelper'),
        (this.isSkeletonHelper = !0),
        (this.root = t),
        (this.bones = e),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1)
    }
    updateMatrixWorld(t) {
      const e = this.bones,
        n = this.geometry,
        i = n.getAttribute('position')
      al.copy(this.root.matrixWorld).invert()
      for (let t = 0, n = 0; t < e.length; t++) {
        const s = e[t]
        s.parent &&
          s.parent.isBone &&
          (ol.multiplyMatrices(al, s.matrixWorld),
          rl.setFromMatrixPosition(ol),
          i.setXYZ(n, rl.x, rl.y, rl.z),
          ol.multiplyMatrices(al, s.parent.matrixWorld),
          rl.setFromMatrixPosition(ol),
          i.setXYZ(n + 1, rl.x, rl.y, rl.z),
          (n += 2))
      }
      ;(n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(t)
    }
  }.prototype.update = function () {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.')
  }),
  (ua.prototype.extractUrlBase = function (t) {
    return (
      console.warn(
        'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.'
      ),
      Da.extractUrlBase(t)
    )
  }),
  (ua.Handlers = {
    add: function () {
      console.error(
        'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.'
      )
    },
    get: function () {
      console.error(
        'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.'
      )
    }
  }),
  (Y.prototype.center = function (t) {
    return (
      console.warn('THREE.Box3: .center() has been renamed to .getCenter().'), this.getCenter(t)
    )
  }),
  (Y.prototype.empty = function () {
    return console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'), this.isEmpty()
  }),
  (Y.prototype.isIntersectionBox = function (t) {
    return (
      console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'),
      this.intersectsBox(t)
    )
  }),
  (Y.prototype.isIntersectionSphere = function (t) {
    return (
      console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
      this.intersectsSphere(t)
    )
  }),
  (Y.prototype.size = function (t) {
    return console.warn('THREE.Box3: .size() has been renamed to .getSize().'), this.getSize(t)
  }),
  (Rt.prototype.toVector3 = function () {
    console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead')
  }),
  (ct.prototype.empty = function () {
    return console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().'), this.isEmpty()
  }),
  (tn.prototype.setFromMatrix = function (t) {
    return (
      console.warn(
        'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().'
      ),
      this.setFromProjectionMatrix(t)
    )
  }),
  (sl.prototype.center = function (t) {
    return (
      console.warn('THREE.Line3: .center() has been renamed to .getCenter().'), this.getCenter(t)
    )
  }),
  (w.prototype.flattenToArrayOffset = function (t, e) {
    return (
      console.warn(
        'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
      ),
      this.toArray(t, e)
    )
  }),
  (w.prototype.multiplyVector3 = function (t) {
    return (
      console.warn(
        'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
      ),
      t.applyMatrix3(this)
    )
  }),
  (w.prototype.multiplyVector3Array = function () {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.')
  }),
  (w.prototype.applyToBufferAttribute = function (t) {
    return (
      console.warn(
        'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.'
      ),
      t.applyMatrix3(this)
    )
  }),
  (w.prototype.applyToVector3Array = function () {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.')
  }),
  (w.prototype.getInverse = function (t) {
    return (
      console.warn(
        'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
      ),
      this.copy(t).invert()
    )
  }),
  (vt.prototype.extractPosition = function (t) {
    return (
      console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'),
      this.copyPosition(t)
    )
  }),
  (vt.prototype.flattenToArrayOffset = function (t, e) {
    return (
      console.warn(
        'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
      ),
      this.toArray(t, e)
    )
  }),
  (vt.prototype.getPosition = function () {
    return (
      console.warn(
        'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
      ),
      new H().setFromMatrixColumn(this, 3)
    )
  }),
  (vt.prototype.setRotationFromQuaternion = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
      ),
      this.makeRotationFromQuaternion(t)
    )
  }),
  (vt.prototype.multiplyToArray = function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.')
  }),
  (vt.prototype.multiplyVector3 = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
      ),
      t.applyMatrix4(this)
    )
  }),
  (vt.prototype.multiplyVector4 = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
      ),
      t.applyMatrix4(this)
    )
  }),
  (vt.prototype.multiplyVector3Array = function () {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.')
  }),
  (vt.prototype.rotateAxis = function (t) {
    console.warn(
      'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
    ),
      t.transformDirection(this)
  }),
  (vt.prototype.crossVector = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'
      ),
      t.applyMatrix4(this)
    )
  }),
  (vt.prototype.translate = function () {
    console.error('THREE.Matrix4: .translate() has been removed.')
  }),
  (vt.prototype.rotateX = function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.')
  }),
  (vt.prototype.rotateY = function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.')
  }),
  (vt.prototype.rotateZ = function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.')
  }),
  (vt.prototype.rotateByAxis = function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.')
  }),
  (vt.prototype.applyToBufferAttribute = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.'
      ),
      t.applyMatrix4(this)
    )
  }),
  (vt.prototype.applyToVector3Array = function () {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.')
  }),
  (vt.prototype.makeFrustum = function (t, e, n, i, s, r) {
    return (
      console.warn(
        'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
      ),
      this.makePerspective(t, e, i, n, s, r)
    )
  }),
  (vt.prototype.getInverse = function (t) {
    return (
      console.warn(
        'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.'
      ),
      this.copy(t).invert()
    )
  }),
  (Je.prototype.isIntersectionLine = function (t) {
    return (
      console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'),
      this.intersectsLine(t)
    )
  }),
  (V.prototype.multiplyVector3 = function (t) {
    return (
      console.warn(
        'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
      ),
      t.applyQuaternion(this)
    )
  }),
  (V.prototype.inverse = function () {
    return console.warn('THREE.Quaternion: .inverse() has been renamed to invert().'), this.invert()
  }),
  (xt.prototype.isIntersectionBox = function (t) {
    return (
      console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'),
      this.intersectsBox(t)
    )
  }),
  (xt.prototype.isIntersectionPlane = function (t) {
    return (
      console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'),
      this.intersectsPlane(t)
    )
  }),
  (xt.prototype.isIntersectionSphere = function (t) {
    return (
      console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'),
      this.intersectsSphere(t)
    )
  }),
  (ee.prototype.area = function () {
    return console.warn('THREE.Triangle: .area() has been renamed to .getArea().'), this.getArea()
  }),
  (ee.prototype.barycoordFromPoint = function (t, e) {
    return (
      console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
      this.getBarycoord(t, e)
    )
  }),
  (ee.prototype.midpoint = function (t) {
    return (
      console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'),
      this.getMidpoint(t)
    )
  }),
  (ee.prototypenormal = function (t) {
    return (
      console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'), this.getNormal(t)
    )
  }),
  (ee.prototype.plane = function (t) {
    return (
      console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().'), this.getPlane(t)
    )
  }),
  (ee.barycoordFromPoint = function (t, e, n, i, s) {
    return (
      console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'),
      ee.getBarycoord(t, e, n, i, s)
    )
  }),
  (ee.normal = function (t, e, n, i) {
    return (
      console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
      ee.getNormal(t, e, n, i)
    )
  }),
  (io.prototype.extractAllPoints = function (t) {
    return (
      console.warn(
        'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'
      ),
      this.extractPoints(t)
    )
  }),
  (io.prototype.extrude = function (t) {
    return (
      console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'),
      new Po(this, t)
    )
  }),
  (io.prototype.makeGeometry = function (t) {
    return (
      console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'),
      new Oo(this, t)
    )
  }),
  (_.prototype.fromAttribute = function (t, e, n) {
    return (
      console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'),
      this.fromBufferAttribute(t, e, n)
    )
  }),
  (_.prototype.distanceToManhattan = function (t) {
    return (
      console.warn(
        'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
      ),
      this.manhattanDistanceTo(t)
    )
  }),
  (_.prototype.lengthManhattan = function () {
    return (
      console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'),
      this.manhattanLength()
    )
  }),
  (H.prototype.setEulerFromRotationMatrix = function () {
    console.error(
      'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
    )
  }),
  (H.prototype.setEulerFromQuaternion = function () {
    console.error(
      'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
    )
  }),
  (H.prototype.getPositionFromMatrix = function (t) {
    return (
      console.warn(
        'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'
      ),
      this.setFromMatrixPosition(t)
    )
  }),
  (H.prototype.getScaleFromMatrix = function (t) {
    return (
      console.warn(
        'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'
      ),
      this.setFromMatrixScale(t)
    )
  }),
  (H.prototype.getColumnFromMatrix = function (t, e) {
    return (
      console.warn(
        'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'
      ),
      this.setFromMatrixColumn(e, t)
    )
  }),
  (H.prototype.applyProjection = function (t) {
    return (
      console.warn(
        'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'
      ),
      this.applyMatrix4(t)
    )
  }),
  (H.prototype.fromAttribute = function (t, e, n) {
    return (
      console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'),
      this.fromBufferAttribute(t, e, n)
    )
  }),
  (H.prototype.distanceToManhattan = function (t) {
    return (
      console.warn(
        'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
      ),
      this.manhattanDistanceTo(t)
    )
  }),
  (H.prototype.lengthManhattan = function () {
    return (
      console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'),
      this.manhattanLength()
    )
  }),
  (G.prototype.fromAttribute = function (t, e, n) {
    return (
      console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'),
      this.fromBufferAttribute(t, e, n)
    )
  }),
  (G.prototype.lengthManhattan = function () {
    return (
      console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'),
      this.manhattanLength()
    )
  }),
  (Wt.prototype.getChildByName = function (t) {
    return (
      console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'),
      this.getObjectByName(t)
    )
  }),
  (Wt.prototype.renderDepth = function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.')
  }),
  (Wt.prototype.translate = function (t, e) {
    return (
      console.warn(
        'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
      ),
      this.translateOnAxis(e, t)
    )
  }),
  (Wt.prototype.getWorldRotation = function () {
    console.error(
      'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.'
    )
  }),
  (Wt.prototype.applyMatrix = function (t) {
    return (
      console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().'),
      this.applyMatrix4(t)
    )
  }),
  Object.defineProperties(Wt.prototype, {
    eulerOrder: {
      get: function () {
        return (
          console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'), this.rotation.order
        )
      },
      set: function (t) {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
          (this.rotation.order = t)
      }
    },
    useQuaternion: {
      get: function () {
        console.warn(
          'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
        )
      },
      set: function () {
        console.warn(
          'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
        )
      }
    }
  }),
  (Fe.prototype.setDrawMode = function () {
    console.error(
      'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
    )
  }),
  Object.defineProperties(Fe.prototype, {
    drawMode: {
      get: function () {
        return (
          console.error(
            'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.'
          ),
          0
        )
      },
      set: function () {
        console.error(
          'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.'
        )
      }
    }
  }),
  (or.prototype.initBones = function () {
    console.error('THREE.SkinnedMesh: initBones() has been removed.')
  }),
  (We.prototype.setLens = function (t, e) {
    console.warn(
      'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
    ),
      void 0 !== e && (this.filmGauge = e),
      this.setFocalLength(t)
  }),
  Object.defineProperties(ya.prototype, {
    onlyShadow: {
      set: function () {
        console.warn('THREE.Light: .onlyShadow has been removed.')
      }
    },
    shadowCameraFov: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'),
          (this.shadow.camera.fov = t)
      }
    },
    shadowCameraLeft: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'),
          (this.shadow.camera.left = t)
      }
    },
    shadowCameraRight: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
          (this.shadow.camera.right = t)
      }
    },
    shadowCameraTop: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'),
          (this.shadow.camera.top = t)
      }
    },
    shadowCameraBottom: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
          (this.shadow.camera.bottom = t)
      }
    },
    shadowCameraNear: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'),
          (this.shadow.camera.near = t)
      }
    },
    shadowCameraFar: {
      set: function (t) {
        console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'),
          (this.shadow.camera.far = t)
      }
    },
    shadowCameraVisible: {
      set: function () {
        console.warn(
          'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
        )
      }
    },
    shadowBias: {
      set: function (t) {
        console.warn('THREE.Light: .shadowBias is now .shadow.bias.'), (this.shadow.bias = t)
      }
    },
    shadowDarkness: {
      set: function () {
        console.warn('THREE.Light: .shadowDarkness has been removed.')
      }
    },
    shadowMapWidth: {
      set: function (t) {
        console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'),
          (this.shadow.mapSize.width = t)
      }
    },
    shadowMapHeight: {
      set: function (t) {
        console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
          (this.shadow.mapSize.height = t)
      }
    }
  }),
  Object.defineProperties(ae.prototype, {
    length: {
      get: function () {
        return (
          console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.'),
          this.array.length
        )
      }
    },
    dynamic: {
      get: function () {
        return (
          console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'),
          35048 === this.usage
        )
      },
      set: function () {
        console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.'),
          this.setUsage(35048)
      }
    }
  }),
  (ae.prototype.setDynamic = function (t) {
    return (
      console.warn(
        'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.'
      ),
      this.setUsage(!0 === t ? 35048 : 35044),
      this
    )
  }),
  (ae.prototype.copyIndicesArray = function () {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.')
  }),
  (ae.prototype.setArray = function () {
    console.error(
      'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
    )
  }),
  (xe.prototype.addIndex = function (t) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'),
      this.setIndex(t)
  }),
  (xe.prototype.addAttribute = function (t, e) {
    return (
      console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().'),
      (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
        ? 'index' === t
          ? (console.warn(
              'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'
            ),
            this.setIndex(e),
            this)
          : this.setAttribute(t, e)
        : (console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'),
          this.setAttribute(t, new ae(arguments[1], arguments[2])))
    )
  }),
  (xe.prototype.addDrawCall = function (t, e, n) {
    void 0 !== n &&
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'),
      console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
      this.addGroup(t, e)
  }),
  (xe.prototype.clearDrawCalls = function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'),
      this.clearGroups()
  }),
  (xe.prototype.computeOffsets = function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.')
  }),
  (xe.prototype.removeAttribute = function (t) {
    return (
      console.warn(
        'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().'
      ),
      this.deleteAttribute(t)
    )
  }),
  (xe.prototype.applyMatrix = function (t) {
    return (
      console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().'),
      this.applyMatrix4(t)
    )
  }),
  Object.defineProperties(xe.prototype, {
    drawcalls: {
      get: function () {
        return (
          console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.'),
          this.groups
        )
      }
    },
    offsets: {
      get: function () {
        return (
          console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'), this.groups
        )
      }
    }
  }),
  (Fs.prototype.setDynamic = function (t) {
    return (
      console.warn(
        'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.'
      ),
      this.setUsage(!0 === t ? 35048 : 35044),
      this
    )
  }),
  (Fs.prototype.setArray = function () {
    console.error(
      'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers'
    )
  }),
  (Po.prototype.getArrays = function () {
    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.')
  }),
  (Po.prototype.addShapeList = function () {
    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.')
  }),
  (Po.prototype.addShape = function () {
    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.')
  }),
  (Os.prototype.dispose = function () {
    console.error('THREE.Scene: .dispose() has been removed.')
  }),
  Object.defineProperties(ie.prototype, {
    wrapAround: {
      get: function () {
        console.warn('THREE.Material: .wrapAround has been removed.')
      },
      set: function () {
        console.warn('THREE.Material: .wrapAround has been removed.')
      }
    },
    overdraw: {
      get: function () {
        console.warn('THREE.Material: .overdraw has been removed.')
      },
      set: function () {
        console.warn('THREE.Material: .overdraw has been removed.')
      }
    },
    wrapRGB: {
      get: function () {
        return console.warn('THREE.Material: .wrapRGB has been removed.'), new L()
      }
    },
    shading: {
      get: function () {
        console.error(
          'THREE.' +
            this.type +
            ': .shading has been removed. Use the boolean .flatShading instead.'
        )
      },
      set: function (t) {
        console.warn(
          'THREE.' +
            this.type +
            ': .shading has been removed. Use the boolean .flatShading instead.'
        ),
          (this.flatShading = 1 === t)
      }
    },
    stencilMask: {
      get: function () {
        return (
          console.warn(
            'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.'
          ),
          this.stencilFuncMask
        )
      },
      set: function (t) {
        console.warn(
          'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.'
        ),
          (this.stencilFuncMask = t)
      }
    },
    vertexTangents: {
      get: function () {
        console.warn('THREE.' + this.type + ': .vertexTangents has been removed.')
      },
      set: function () {
        console.warn('THREE.' + this.type + ': .vertexTangents has been removed.')
      }
    }
  }),
  Object.defineProperties(He.prototype, {
    derivatives: {
      get: function () {
        return (
          console.warn(
            'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
          ),
          this.extensions.derivatives
        )
      },
      set: function (t) {
        console.warn(
          'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
        ),
          (this.extensions.derivatives = t)
      }
    }
  }),
  (Ds.prototype.clearTarget = function (t, e, n, i) {
    console.warn(
      'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.'
    ),
      this.setRenderTarget(t),
      this.clear(e, n, i)
  }),
  (Ds.prototype.animate = function (t) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'),
      this.setAnimationLoop(t)
  }),
  (Ds.prototype.getCurrentRenderTarget = function () {
    return (
      console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'),
      this.getRenderTarget()
    )
  }),
  (Ds.prototype.getMaxAnisotropy = function () {
    return (
      console.warn(
        'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'
      ),
      this.capabilities.getMaxAnisotropy()
    )
  }),
  (Ds.prototype.getPrecision = function () {
    return (
      console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'),
      this.capabilities.precision
    )
  }),
  (Ds.prototype.resetGLState = function () {
    return (
      console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'),
      this.state.reset()
    )
  }),
  (Ds.prototype.supportsFloatTextures = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
      ),
      this.extensions.get('OES_texture_float')
    )
  }),
  (Ds.prototype.supportsHalfFloatTextures = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
      ),
      this.extensions.get('OES_texture_half_float')
    )
  }),
  (Ds.prototype.supportsStandardDerivatives = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
      ),
      this.extensions.get('OES_standard_derivatives')
    )
  }),
  (Ds.prototype.supportsCompressedTextureS3TC = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
      ),
      this.extensions.get('WEBGL_compressed_texture_s3tc')
    )
  }),
  (Ds.prototype.supportsCompressedTexturePVRTC = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
      ),
      this.extensions.get('WEBGL_compressed_texture_pvrtc')
    )
  }),
  (Ds.prototype.supportsBlendMinMax = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
      ),
      this.extensions.get('EXT_blend_minmax')
    )
  }),
  (Ds.prototype.supportsVertexTextures = function () {
    return (
      console.warn(
        'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'
      ),
      this.capabilities.vertexTextures
    )
  }),
  (Ds.prototype.supportsInstancedArrays = function () {
    return (
      console.warn(
        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
      ),
      this.extensions.get('ANGLE_instanced_arrays')
    )
  }),
  (Ds.prototype.enableScissorTest = function (t) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'),
      this.setScissorTest(t)
  }),
  (Ds.prototype.initMaterial = function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.')
  }),
  (Ds.prototype.addPrePlugin = function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.')
  }),
  (Ds.prototype.addPostPlugin = function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.')
  }),
  (Ds.prototype.updateShadowMap = function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.')
  }),
  (Ds.prototype.setFaceCulling = function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.')
  }),
  (Ds.prototype.allocTextureUnit = function () {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.')
  }),
  (Ds.prototype.setTexture = function () {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.')
  }),
  (Ds.prototype.setTexture2D = function () {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.')
  }),
  (Ds.prototype.setTextureCube = function () {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.')
  }),
  (Ds.prototype.getActiveMipMapLevel = function () {
    return (
      console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().'),
      this.getActiveMipmapLevel()
    )
  }),
  Object.defineProperties(Ds.prototype, {
    shadowMapEnabled: {
      get: function () {
        return this.shadowMap.enabled
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'),
          (this.shadowMap.enabled = t)
      }
    },
    shadowMapType: {
      get: function () {
        return this.shadowMap.type
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'),
          (this.shadowMap.type = t)
      }
    },
    shadowMapCullFace: {
      get: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
        )
      },
      set: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
        )
      }
    },
    context: {
      get: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.'
          ),
          this.getContext()
        )
      }
    },
    vr: {
      get: function () {
        return console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr'), this.xr
      }
    },
    gammaInput: {
      get: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
          ),
          !1
        )
      },
      set: function () {
        console.warn(
          'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.'
        )
      }
    },
    gammaOutput: {
      get: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
          ),
          !1
        )
      },
      set: function (t) {
        console.warn(
          'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.'
        ),
          (this.outputEncoding = !0 === t ? 3001 : 3e3)
      }
    },
    toneMappingWhitePoint: {
      get: function () {
        return console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.'), 1
      },
      set: function () {
        console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.')
      }
    },
    gammaFactor: {
      get: function () {
        return console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.'), 2
      },
      set: function () {
        console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.')
      }
    }
  }),
  Object.defineProperties(bs.prototype, {
    cullFace: {
      get: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
        )
      },
      set: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
        )
      }
    },
    renderReverseSided: {
      get: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
        )
      },
      set: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
        )
      }
    },
    renderSingleSided: {
      get: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
        )
      },
      set: function () {
        console.warn(
          'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
        )
      }
    }
  }),
  Object.defineProperties(z.prototype, {
    wrapS: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'), this.texture.wrapS
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
          (this.texture.wrapS = t)
      }
    },
    wrapT: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'), this.texture.wrapT
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
          (this.texture.wrapT = t)
      }
    },
    magFilter: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
          this.texture.magFilter
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
          (this.texture.magFilter = t)
      }
    },
    minFilter: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
          this.texture.minFilter
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
          (this.texture.minFilter = t)
      }
    },
    anisotropy: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
          this.texture.anisotropy
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'),
          (this.texture.anisotropy = t)
      }
    },
    offset: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
          this.texture.offset
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
          (this.texture.offset = t)
      }
    },
    repeat: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
          this.texture.repeat
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
          (this.texture.repeat = t)
      }
    },
    format: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
          this.texture.format
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
          (this.texture.format = t)
      }
    },
    type: {
      get: function () {
        return (
          console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'), this.texture.type
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
          (this.texture.type = t)
      }
    },
    generateMipmaps: {
      get: function () {
        return (
          console.warn(
            'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
          ),
          this.texture.generateMipmaps
        )
      },
      set: function (t) {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'),
          (this.texture.generateMipmaps = t)
      }
    }
  }),
  (class extends Wt {
    constructor(t) {
      super(),
        (this.type = 'Audio'),
        (this.listener = t),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.detune = 0),
        (this.loop = !1),
        (this.loopStart = 0),
        (this.loopEnd = 0),
        (this.offset = 0),
        (this.duration = void 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.source = null),
        (this.sourceType = 'empty'),
        (this._startedAt = 0),
        (this._progress = 0),
        (this._connected = !1),
        (this.filters = [])
    }
    getOutput() {
      return this.gain
    }
    setNodeSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = 'audioNode'),
        (this.source = t),
        this.connect(),
        this
      )
    }
    setMediaElementSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = 'mediaNode'),
        (this.source = this.context.createMediaElementSource(t)),
        this.connect(),
        this
      )
    }
    setMediaStreamSource(t) {
      return (
        (this.hasPlaybackControl = !1),
        (this.sourceType = 'mediaStreamNode'),
        (this.source = this.context.createMediaStreamSource(t)),
        this.connect(),
        this
      )
    }
    setBuffer(t) {
      return (this.buffer = t), (this.sourceType = 'buffer'), this.autoplay && this.play(), this
    }
    play(t = 0) {
      if (!0 === this.isPlaying) return void console.warn('THREE.Audio: Audio is already playing.')
      if (!1 === this.hasPlaybackControl)
        return void console.warn('THREE.Audio: this Audio has no playback control.')
      this._startedAt = this.context.currentTime + t
      const e = this.context.createBufferSource()
      return (
        (e.buffer = this.buffer),
        (e.loop = this.loop),
        (e.loopStart = this.loopStart),
        (e.loopEnd = this.loopEnd),
        (e.onended = this.onEnded.bind(this)),
        e.start(this._startedAt, this._progress + this.offset, this.duration),
        (this.isPlaying = !0),
        (this.source = e),
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
      )
    }
    pause() {
      if (!1 !== this.hasPlaybackControl)
        return (
          !0 === this.isPlaying &&
            ((this._progress +=
              Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
            !0 === this.loop &&
              (this._progress = this._progress % (this.duration || this.buffer.duration)),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1)),
          this
        )
      console.warn('THREE.Audio: this Audio has no playback control.')
    }
    stop() {
      if (!1 !== this.hasPlaybackControl)
        return (
          (this._progress = 0),
          this.source.stop(),
          (this.source.onended = null),
          (this.isPlaying = !1),
          this
        )
      console.warn('THREE.Audio: this Audio has no playback control.')
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0])
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].connect(this.filters[t])
        this.filters[this.filters.length - 1].connect(this.getOutput())
      } else this.source.connect(this.getOutput())
      return (this._connected = !0), this
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0])
        for (let t = 1, e = this.filters.length; t < e; t++)
          this.filters[t - 1].disconnect(this.filters[t])
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput())
      return (this._connected = !1), this
    }
    getFilters() {
      return this.filters
    }
    setFilters(t) {
      return (
        t || (t = []),
        !0 === this._connected
          ? (this.disconnect(), (this.filters = t.slice()), this.connect())
          : (this.filters = t.slice()),
        this
      )
    }
    setDetune(t) {
      if (((this.detune = t), void 0 !== this.source.detune))
        return (
          !0 === this.isPlaying &&
            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
          this
        )
    }
    getDetune() {
      return this.detune
    }
    getFilter() {
      return this.getFilters()[0]
    }
    setFilter(t) {
      return this.setFilters(t ? [t] : [])
    }
    setPlaybackRate(t) {
      if (!1 !== this.hasPlaybackControl)
        return (
          (this.playbackRate = t),
          !0 === this.isPlaying &&
            this.source.playbackRate.setTargetAtTime(
              this.playbackRate,
              this.context.currentTime,
              0.01
            ),
          this
        )
      console.warn('THREE.Audio: this Audio has no playback control.')
    }
    getPlaybackRate() {
      return this.playbackRate
    }
    onEnded() {
      this.isPlaying = !1
    }
    getLoop() {
      return !1 === this.hasPlaybackControl
        ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
        : this.loop
    }
    setLoop(t) {
      if (!1 !== this.hasPlaybackControl)
        return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this
      console.warn('THREE.Audio: this Audio has no playback control.')
    }
    setLoopStart(t) {
      return (this.loopStart = t), this
    }
    setLoopEnd(t) {
      return (this.loopEnd = t), this
    }
    getVolume() {
      return this.gain.gain.value
    }
    setVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    }
  }.prototype.load = function (t) {
    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.')
    const e = this
    return (
      new za().load(t, function (t) {
        e.setBuffer(t)
      }),
      this
    )
  }),
  (Ye.prototype.updateCubeMap = function (t, e) {
    return console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'), this.update(t, e)
  }),
  (Ye.prototype.clear = function (t, e, n, i) {
    return (
      console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().'),
      this.renderTarget.clear(t, e, n, i)
    )
  }),
  (N.crossOrigin = void 0),
  (N.loadTexture = function (t, e, n, i) {
    console.warn(
      'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.'
    )
    const s = new ma()
    s.setCrossOrigin(this.crossOrigin)
    const r = s.load(t, n, void 0, i)
    return e && (r.mapping = e), r
  }),
  (N.loadTextureCube = function (t, e, n, i) {
    console.warn(
      'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.'
    )
    const s = new fa()
    s.setCrossOrigin(this.crossOrigin)
    const r = s.load(t, n, void 0, i)
    return e && (r.mapping = e), r
  }),
  (N.loadCompressedTexture = function () {
    console.error(
      'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.'
    )
  }),
  (N.loadCompressedTextureCube = function () {
    console.error(
      'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.'
    )
  }),
  'undefined' != typeof __THREE_DEVTOOLS__ &&
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent('register', { detail: { revision: '139dev' } })
    ),
  'undefined' != typeof window &&
    (window.__THREE__
      ? console.warn('WARNING: Multiple instances of Three.js being imported.')
      : (window.__THREE__ = '139dev'))
class gl extends ua {
  constructor(t) {
    super(t),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new vl(t)
      }),
      this.register(function (t) {
        return new Sl(t)
      }),
      this.register(function (t) {
        return new Al(t)
      }),
      this.register(function (t) {
        return new _l(t)
      }),
      this.register(function (t) {
        return new wl(t)
      }),
      this.register(function (t) {
        return new El(t)
      }),
      this.register(function (t) {
        return new bl(t)
      }),
      this.register(function (t) {
        return new Ml(t)
      }),
      this.register(function (t) {
        return new yl(t)
      }),
      this.register(function (t) {
        return new Tl(t)
      })
  }
  load(t, e, n, i) {
    const s = this
    let r
    ;(r =
      '' !== this.resourcePath
        ? this.resourcePath
        : '' !== this.path
          ? this.path
          : Da.extractUrlBase(t)),
      this.manager.itemStart(t)
    const o = function (e) {
        i ? i(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t)
      },
      a = new pa(this.manager)
    a.setPath(this.path),
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        t,
        function (n) {
          try {
            s.parse(
              n,
              r,
              function (n) {
                e(n), s.manager.itemEnd(t)
              },
              o
            )
          } catch (t) {
            o(t)
          }
        },
        n,
        o
      )
  }
  setDRACOLoader(t) {
    return (this.dracoLoader = t), this
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    )
  }
  setKTX2Loader(t) {
    return (this.ktx2Loader = t), this
  }
  setMeshoptDecoder(t) {
    return (this.meshoptDecoder = t), this
  }
  register(t) {
    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
  }
  unregister(t) {
    return (
      -1 !== this.pluginCallbacks.indexOf(t) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
      this
    )
  }
  parse(t, e, n, i) {
    let s
    const r = {},
      o = {}
    if ('string' == typeof t) s = t
    else {
      if (Da.decodeText(new Uint8Array(t, 0, 4)) === Il) {
        try {
          r[ml.KHR_BINARY_GLTF] = new Cl(t)
        } catch (t) {
          return void (i && i(t))
        }
        s = r[ml.KHR_BINARY_GLTF].content
      } else s = Da.decodeText(new Uint8Array(t))
    }
    const a = JSON.parse(s)
    if (void 0 === a.asset || a.asset.version[0] < 2)
      return void (
        i && i(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))
      )
    const l = new hh(a, {
      path: e || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    })
    l.fileLoader.setRequestHeader(this.requestHeader)
    for (let t = 0; t < this.pluginCallbacks.length; t++) {
      const e = this.pluginCallbacks[t](l)
      ;(o[e.name] = e), (r[e.name] = !0)
    }
    if (a.extensionsUsed)
      for (let t = 0; t < a.extensionsUsed.length; ++t) {
        const e = a.extensionsUsed[t],
          n = a.extensionsRequired || []
        switch (e) {
          case ml.KHR_MATERIALS_UNLIT:
            r[e] = new xl()
            break
          case ml.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            r[e] = new Ol()
            break
          case ml.KHR_DRACO_MESH_COMPRESSION:
            r[e] = new Nl(a, this.dracoLoader)
            break
          case ml.KHR_TEXTURE_TRANSFORM:
            r[e] = new Pl()
            break
          case ml.KHR_MESH_QUANTIZATION:
            r[e] = new Fl()
            break
          default:
            n.indexOf(e) >= 0 &&
              void 0 === o[e] &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
        }
      }
    l.setExtensions(r), l.setPlugins(o), l.parse(n, i)
  }
  parseAsync(t, e) {
    const n = this
    return new Promise(function (i, s) {
      n.parse(t, e, i, s)
    })
  }
}
function fl() {
  let t = {}
  return {
    get: function (e) {
      return t[e]
    },
    add: function (e, n) {
      t[e] = n
    },
    remove: function (e) {
      delete t[e]
    },
    removeAll: function () {
      t = {}
    }
  }
}
const ml = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
}
class yl {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} })
  }
  _markDefs() {
    const t = this.parser,
      e = this.parser.json.nodes || []
    for (let n = 0, i = e.length; n < i; n++) {
      const i = e[n]
      i.extensions &&
        i.extensions[this.name] &&
        void 0 !== i.extensions[this.name].light &&
        t._addNodeRef(this.cache, i.extensions[this.name].light)
    }
  }
  _loadLight(t) {
    const e = this.parser,
      n = 'light:' + t
    let i = e.cache.get(n)
    if (i) return i
    const s = e.json,
      r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t]
    let o
    const a = new L(16777215)
    void 0 !== r.color && a.fromArray(r.color)
    const l = void 0 !== r.range ? r.range : 0
    switch (r.type) {
      case 'directional':
        ;(o = new La(a)), o.target.position.set(0, 0, -1), o.add(o.target)
        break
      case 'point':
        ;(o = new Ia(a)), (o.distance = l)
        break
      case 'spot':
        ;(o = new ba(a)),
          (o.distance = l),
          (r.spot = r.spot || {}),
          (r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
          (r.spot.outerConeAngle =
            void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4),
          (o.angle = r.spot.outerConeAngle),
          (o.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
          o.target.position.set(0, 0, -1),
          o.add(o.target)
        break
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + r.type)
    }
    return (
      o.position.set(0, 0, 0),
      (o.decay = 2),
      void 0 !== r.intensity && (o.intensity = r.intensity),
      (o.name = e.createUniqueName(r.name || 'light_' + t)),
      (i = Promise.resolve(o)),
      e.cache.add(n, i),
      i
    )
  }
  createNodeAttachment(t) {
    const e = this,
      n = this.parser,
      i = n.json.nodes[t],
      s = ((i.extensions && i.extensions[this.name]) || {}).light
    return void 0 === s
      ? null
      : this._loadLight(s).then(function (t) {
          return n._getNodeRef(e.cache, s, t)
        })
  }
}
class xl {
  constructor() {
    this.name = ml.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return se
  }
  extendParams(t, e, n) {
    const i = []
    ;(t.color = new L(1, 1, 1)), (t.opacity = 1)
    const s = e.pbrMetallicRoughness
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const e = s.baseColorFactor
        t.color.fromArray(e), (t.opacity = e[3])
      }
      void 0 !== s.baseColorTexture && i.push(n.assignTexture(t, 'map', s.baseColorTexture, 3001))
    }
    return Promise.all(i)
  }
}
class vl {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_CLEARCOAT)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    if (
      (void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor),
      void 0 !== r.clearcoatTexture &&
        s.push(n.assignTexture(e, 'clearcoatMap', r.clearcoatTexture)),
      void 0 !== r.clearcoatRoughnessFactor && (e.clearcoatRoughness = r.clearcoatRoughnessFactor),
      void 0 !== r.clearcoatRoughnessTexture &&
        s.push(n.assignTexture(e, 'clearcoatRoughnessMap', r.clearcoatRoughnessTexture)),
      void 0 !== r.clearcoatNormalTexture &&
        (s.push(n.assignTexture(e, 'clearcoatNormalMap', r.clearcoatNormalTexture)),
        void 0 !== r.clearcoatNormalTexture.scale))
    ) {
      const t = r.clearcoatNormalTexture.scale
      e.clearcoatNormalScale = new _(t, t)
    }
    return Promise.all(s)
  }
}
class _l {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_SHEEN)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = []
    ;(e.sheenColor = new L(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1)
    const r = i.extensions[this.name]
    return (
      void 0 !== r.sheenColorFactor && e.sheenColor.fromArray(r.sheenColorFactor),
      void 0 !== r.sheenRoughnessFactor && (e.sheenRoughness = r.sheenRoughnessFactor),
      void 0 !== r.sheenColorTexture &&
        s.push(n.assignTexture(e, 'sheenColorMap', r.sheenColorTexture, 3001)),
      void 0 !== r.sheenRoughnessTexture &&
        s.push(n.assignTexture(e, 'sheenRoughnessMap', r.sheenRoughnessTexture)),
      Promise.all(s)
    )
  }
}
class wl {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_TRANSMISSION)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    return (
      void 0 !== r.transmissionFactor && (e.transmission = r.transmissionFactor),
      void 0 !== r.transmissionTexture &&
        s.push(n.assignTexture(e, 'transmissionMap', r.transmissionTexture)),
      Promise.all(s)
    )
  }
}
class El {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_VOLUME)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    ;(e.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
      void 0 !== r.thicknessTexture &&
        s.push(n.assignTexture(e, 'thicknessMap', r.thicknessTexture)),
      (e.attenuationDistance = r.attenuationDistance || 0)
    const o = r.attenuationColor || [1, 1, 1]
    return (e.attenuationColor = new L(o[0], o[1], o[2])), Promise.all(s)
  }
}
class bl {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_IOR)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t]
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve()
    const i = n.extensions[this.name]
    return (e.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve()
  }
}
class Ml {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_MATERIALS_SPECULAR)
  }
  getMaterialType(t) {
    const e = this.parser.json.materials[t]
    return e.extensions && e.extensions[this.name] ? Uo : null
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const s = [],
      r = i.extensions[this.name]
    ;(e.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
      void 0 !== r.specularTexture &&
        s.push(n.assignTexture(e, 'specularIntensityMap', r.specularTexture))
    const o = r.specularColorFactor || [1, 1, 1]
    return (
      (e.specularColor = new L(o[0], o[1], o[2])),
      void 0 !== r.specularColorTexture &&
        s.push(n.assignTexture(e, 'specularColorMap', r.specularColorTexture, 3001)),
      Promise.all(s)
    )
  }
}
class Sl {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.KHR_TEXTURE_BASISU)
  }
  loadTexture(t) {
    const e = this.parser,
      n = e.json,
      i = n.textures[t]
    if (!i.extensions || !i.extensions[this.name]) return null
    const s = i.extensions[this.name],
      r = e.options.ktx2Loader
    if (!r) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures'
        )
      return null
    }
    return e.loadTextureImage(t, s.source, r)
  }
}
class Al {
  constructor(t) {
    ;(this.parser = t), (this.name = ml.EXT_TEXTURE_WEBP), (this.isSupported = null)
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[t]
    if (!s.extensions || !s.extensions[e]) return null
    const r = s.extensions[e],
      o = i.images[r.source]
    let a = n.textureLoader
    if (o.uri) {
      const t = n.options.manager.getHandler(o.uri)
      null !== t && (a = t)
    }
    return this.detectSupport().then(function (s) {
      if (s) return n.loadTextureImage(t, o, a)
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
      return n.loadTexture(t)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image()
          ;(e.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (e.onload = e.onerror =
              function () {
                t(1 === e.height)
              })
        })),
      this.isSupported
    )
  }
}
class Tl {
  constructor(t) {
    ;(this.name = ml.EXT_MESHOPT_COMPRESSION), (this.parser = t)
  }
  loadBufferView(t) {
    const e = this.parser.json,
      n = e.bufferViews[t]
    if (n.extensions && n.extensions[this.name]) {
      const t = n.extensions[this.name],
        i = this.parser.getDependency('buffer', t.buffer),
        s = this.parser.options.meshoptDecoder
      if (!s || !s.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files'
          )
        return null
      }
      return Promise.all([i, s.ready]).then(function (e) {
        const n = t.byteOffset || 0,
          i = t.byteLength || 0,
          r = t.count,
          o = t.byteStride,
          a = new ArrayBuffer(r * o),
          l = new Uint8Array(e[0], n, i)
        return s.decodeGltfBuffer(new Uint8Array(a), r, o, l, t.mode, t.filter), a
      })
    }
    return null
  }
}
const Il = 'glTF',
  Rl = 1313821514,
  Ll = 5130562
class Cl {
  constructor(t) {
    ;(this.name = ml.KHR_BINARY_GLTF), (this.content = null), (this.body = null)
    const e = new DataView(t, 0, 12)
    if (
      ((this.header = {
        magic: Da.decodeText(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, !0),
        length: e.getUint32(8, !0)
      }),
      this.header.magic !== Il)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
    if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
    const n = this.header.length - 12,
      i = new DataView(t, 12)
    let s = 0
    for (; s < n; ) {
      const e = i.getUint32(s, !0)
      s += 4
      const n = i.getUint32(s, !0)
      if (((s += 4), n === Rl)) {
        const n = new Uint8Array(t, 12 + s, e)
        this.content = Da.decodeText(n)
      } else if (n === Ll) {
        const n = 12 + s
        this.body = t.slice(n, n + e)
      }
      s += e
    }
    if (null === this.content) throw new Error('THREE.GLTFLoader: JSON content not found.')
  }
}
class Nl {
  constructor(t, e) {
    if (!e) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
    ;(this.name = ml.KHR_DRACO_MESH_COMPRESSION),
      (this.json = t),
      (this.dracoLoader = e),
      this.dracoLoader.preload()
  }
  decodePrimitive(t, e) {
    const n = this.json,
      i = this.dracoLoader,
      s = t.extensions[this.name].bufferView,
      r = t.extensions[this.name].attributes,
      o = {},
      a = {},
      l = {}
    for (const t in r) {
      const e = Jl[t] || t.toLowerCase()
      o[e] = r[t]
    }
    for (const e in t.attributes) {
      const i = Jl[e] || e.toLowerCase()
      if (void 0 !== r[e]) {
        const s = n.accessors[t.attributes[e]],
          r = ql[s.componentType]
        ;(l[i] = r), (a[i] = !0 === s.normalized)
      }
    }
    return e.getDependency('bufferView', s).then(function (t) {
      return new Promise(function (e) {
        i.decodeDracoFile(
          t,
          function (t) {
            for (const e in t.attributes) {
              const n = t.attributes[e],
                i = a[e]
              void 0 !== i && (n.normalized = i)
            }
            e(t)
          },
          o,
          l
        )
      })
    })
  }
}
class Pl {
  constructor() {
    this.name = ml.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(t, e) {
    return (
      void 0 !== e.texCoord &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'
        ),
      (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) ||
        ((t = t.clone()),
        void 0 !== e.offset && t.offset.fromArray(e.offset),
        void 0 !== e.rotation && (t.rotation = e.rotation),
        void 0 !== e.scale && t.repeat.fromArray(e.scale),
        (t.needsUpdate = !0)),
      t
    )
  }
}
class Dl extends Bo {
  constructor(t) {
    super(), (this.isGLTFSpecularGlossinessMaterial = !0)
    const e = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\n'),
      n = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\n'),
      i = [
        'vec3 specularFactor = specular;',
        '#ifdef USE_SPECULARMAP',
        '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
        '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
        '\tspecularFactor *= texelSpecular.rgb;',
        '#endif'
      ].join('\n'),
      s = [
        'float glossinessFactor = glossiness;',
        '#ifdef USE_GLOSSINESSMAP',
        '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
        '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
        '\tglossinessFactor *= texelGlossiness.a;',
        '#endif'
      ].join('\n'),
      r = [
        'PhysicalMaterial material;',
        'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
        'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
        'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
        'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
        'material.roughness += geometryRoughness;',
        'material.roughness = min( material.roughness, 1.0 );',
        'material.specularColor = specularFactor;'
      ].join('\n'),
      o = {
        specular: { value: new L().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null }
      }
    ;(this._extraUniforms = o),
      (this.onBeforeCompile = function (t) {
        for (const e in o) t.uniforms[e] = o[e]
        t.fragmentShader = t.fragmentShader
          .replace('uniform float roughness;', 'uniform vec3 specular;')
          .replace('uniform float metalness;', 'uniform float glossiness;')
          .replace('#include <roughnessmap_pars_fragment>', e)
          .replace('#include <metalnessmap_pars_fragment>', n)
          .replace('#include <roughnessmap_fragment>', i)
          .replace('#include <metalnessmap_fragment>', s)
          .replace('#include <lights_physical_fragment>', r)
      }),
      Object.defineProperties(this, {
        specular: {
          get: function () {
            return o.specular.value
          },
          set: function (t) {
            o.specular.value = t
          }
        },
        specularMap: {
          get: function () {
            return o.specularMap.value
          },
          set: function (t) {
            ;(o.specularMap.value = t),
              t ? (this.defines.USE_SPECULARMAP = '') : delete this.defines.USE_SPECULARMAP
          }
        },
        glossiness: {
          get: function () {
            return o.glossiness.value
          },
          set: function (t) {
            o.glossiness.value = t
          }
        },
        glossinessMap: {
          get: function () {
            return o.glossinessMap.value
          },
          set: function (t) {
            ;(o.glossinessMap.value = t),
              t
                ? ((this.defines.USE_GLOSSINESSMAP = ''), (this.defines.USE_UV = ''))
                : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
          }
        }
      }),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.specularMap = t.specularMap),
      this.specular.copy(t.specular),
      (this.glossinessMap = t.glossinessMap),
      (this.glossiness = t.glossiness),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this
    )
  }
}
class Ol {
  constructor() {
    ;(this.name = ml.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
      (this.specularGlossinessParams = [
        'color',
        'map',
        'lightMap',
        'lightMapIntensity',
        'aoMap',
        'aoMapIntensity',
        'emissive',
        'emissiveIntensity',
        'emissiveMap',
        'bumpMap',
        'bumpScale',
        'normalMap',
        'normalMapType',
        'displacementMap',
        'displacementScale',
        'displacementBias',
        'specularMap',
        'specular',
        'glossinessMap',
        'glossiness',
        'alphaMap',
        'envMap',
        'envMapIntensity',
        'refractionRatio'
      ])
  }
  getMaterialType() {
    return Dl
  }
  extendParams(t, e, n) {
    const i = e.extensions[this.name]
    ;(t.color = new L(1, 1, 1)), (t.opacity = 1)
    const s = []
    if (Array.isArray(i.diffuseFactor)) {
      const e = i.diffuseFactor
      t.color.fromArray(e), (t.opacity = e[3])
    }
    if (
      (void 0 !== i.diffuseTexture && s.push(n.assignTexture(t, 'map', i.diffuseTexture, 3001)),
      (t.emissive = new L(0, 0, 0)),
      (t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
      (t.specular = new L(1, 1, 1)),
      Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor),
      void 0 !== i.specularGlossinessTexture)
    ) {
      const e = i.specularGlossinessTexture
      s.push(n.assignTexture(t, 'glossinessMap', e)),
        s.push(n.assignTexture(t, 'specularMap', e, 3001))
    }
    return Promise.all(s)
  }
  createMaterial(t) {
    const e = new Dl(t)
    return (
      (e.fog = !0),
      (e.color = t.color),
      (e.map = void 0 === t.map ? null : t.map),
      (e.lightMap = null),
      (e.lightMapIntensity = 1),
      (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
      (e.aoMapIntensity = 1),
      (e.emissive = t.emissive),
      (e.emissiveIntensity = 1),
      (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
      (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
      (e.bumpScale = 1),
      (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
      (e.normalMapType = 0),
      t.normalScale && (e.normalScale = t.normalScale),
      (e.displacementMap = null),
      (e.displacementScale = 1),
      (e.displacementBias = 0),
      (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
      (e.specular = t.specular),
      (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap),
      (e.glossiness = t.glossiness),
      (e.alphaMap = null),
      (e.envMap = void 0 === t.envMap ? null : t.envMap),
      (e.envMapIntensity = 1),
      (e.refractionRatio = 0.98),
      e
    )
  }
}
class Fl {
  constructor() {
    this.name = ml.KHR_MESH_QUANTIZATION
  }
}
class Gl extends Xo {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = t * i * 3 + i
    for (let t = 0; t !== i; t++) e[t] = n[s + t]
    return e
  }
}
;(Gl.prototype.beforeStart_ = Gl.prototype.copySampleValue_),
  (Gl.prototype.afterEnd_ = Gl.prototype.copySampleValue_),
  (Gl.prototype.interpolate_ = function (t, e, n, i) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      o = this.valueSize,
      a = 2 * o,
      l = 3 * o,
      h = i - e,
      c = (n - e) / h,
      u = c * c,
      d = u * c,
      p = t * l,
      g = p - l,
      f = -2 * d + 3 * u,
      m = d - u,
      y = 1 - f,
      x = m - u + c
    for (let t = 0; t !== o; t++) {
      const e = r[g + t + o],
        n = r[g + t + a] * h,
        i = r[p + t + o],
        l = r[p + t] * h
      s[t] = y * e + x * n + f * i + m * l
    }
    return s
  })
const zl = new V()
class Bl extends Gl {
  interpolate_(t, e, n, i) {
    const s = super.interpolate_(t, e, n, i)
    return zl.fromArray(s).normalize().toArray(s), s
  }
}
const Ul = 0,
  Vl = 1,
  Hl = 2,
  kl = 3,
  Wl = 4,
  Yl = 5,
  jl = 6,
  ql = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  },
  Zl = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 },
  Xl = { 33071: 1001, 33648: 1002, 10497: 1e3 },
  Kl = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Jl = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv2',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  },
  Ql = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  },
  $l = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 },
  th = 'OPAQUE',
  eh = 'MASK',
  nh = 'BLEND'
function ih(t, e, n) {
  for (const i in n.extensions)
    void 0 === t[i] &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = n.extensions[i]))
}
function sh(t, e) {
  void 0 !== e.extras &&
    ('object' == typeof e.extras
      ? Object.assign(t.userData, e.extras)
      : console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras))
}
function rh(t, e) {
  if ((t.updateMorphTargets(), void 0 !== e.weights))
    for (let n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n]
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const n = e.extras.targetNames
    if (t.morphTargetInfluences.length === n.length) {
      t.morphTargetDictionary = {}
      for (let e = 0, i = n.length; e < i; e++) t.morphTargetDictionary[n[e]] = e
    } else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')
  }
}
function oh(t) {
  const e = t.extensions && t.extensions[ml.KHR_DRACO_MESH_COMPRESSION]
  let n
  return (
    (n = e
      ? 'draco:' + e.bufferView + ':' + e.indices + ':' + ah(e.attributes)
      : t.indices + ':' + ah(t.attributes) + ':' + t.mode),
    n
  )
}
function ah(t) {
  let e = ''
  const n = Object.keys(t).sort()
  for (let i = 0, s = n.length; i < s; i++) e += n[i] + ':' + t[n[i]] + ';'
  return e
}
function lh(t) {
  switch (t) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')
  }
}
class hh {
  constructor(t = {}, e = {}) {
    ;(this.json = t),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = e),
      (this.cache = new fl()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}),
      'undefined' != typeof createImageBitmap &&
      !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        ? (this.textureLoader = new Oa(this.options.manager))
        : (this.textureLoader = new ma(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new pa(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      'use-credentials' === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
  }
  setExtensions(t) {
    this.extensions = t
  }
  setPlugins(t) {
    this.plugins = t
  }
  parse(t, e) {
    const n = this,
      i = this.json,
      s = this.extensions
    this.cache.removeAll(),
      this._invokeAll(function (t) {
        return t._markDefs && t._markDefs()
      }),
      Promise.all(
        this._invokeAll(function (t) {
          return t.beforeRoot && t.beforeRoot()
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies('scene'),
            n.getDependencies('animation'),
            n.getDependencies('camera')
          ])
        })
        .then(function (e) {
          const r = {
            scene: e[0][i.scene || 0],
            scenes: e[0],
            animations: e[1],
            cameras: e[2],
            asset: i.asset,
            parser: n,
            userData: {}
          }
          ih(s, r, i),
            sh(r, i),
            Promise.all(
              n._invokeAll(function (t) {
                return t.afterRoot && t.afterRoot(r)
              })
            ).then(function () {
              t(r)
            })
        })
        .catch(e)
  }
  _markDefs() {
    const t = this.json.nodes || [],
      e = this.json.skins || [],
      n = this.json.meshes || []
    for (let n = 0, i = e.length; n < i; n++) {
      const i = e[n].joints
      for (let e = 0, n = i.length; e < n; e++) t[i[e]].isBone = !0
    }
    for (let e = 0, i = t.length; e < i; e++) {
      const i = t[e]
      void 0 !== i.mesh &&
        (this._addNodeRef(this.meshCache, i.mesh),
        void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
        void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
    }
  }
  _addNodeRef(t, e) {
    void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
  }
  _getNodeRef(t, e, n) {
    if (t.refs[e] <= 1) return n
    const i = n.clone(),
      s = (t, e) => {
        const n = this.associations.get(t)
        null != n && this.associations.set(e, n)
        for (const [n, i] of t.children.entries()) s(i, e.children[n])
      }
    return s(n, i), (i.name += '_instance_' + t.uses[e]++), i
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins)
    e.push(this)
    for (let n = 0; n < e.length; n++) {
      const i = t(e[n])
      if (i) return i
    }
    return null
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins)
    e.unshift(this)
    const n = []
    for (let i = 0; i < e.length; i++) {
      const s = t(e[i])
      s && n.push(s)
    }
    return n
  }
  getDependency(t, e) {
    const n = t + ':' + e
    let i = this.cache.get(n)
    if (!i) {
      switch (t) {
        case 'scene':
          i = this.loadScene(e)
          break
        case 'node':
          i = this.loadNode(e)
          break
        case 'mesh':
          i = this._invokeOne(function (t) {
            return t.loadMesh && t.loadMesh(e)
          })
          break
        case 'accessor':
          i = this.loadAccessor(e)
          break
        case 'bufferView':
          i = this._invokeOne(function (t) {
            return t.loadBufferView && t.loadBufferView(e)
          })
          break
        case 'buffer':
          i = this.loadBuffer(e)
          break
        case 'material':
          i = this._invokeOne(function (t) {
            return t.loadMaterial && t.loadMaterial(e)
          })
          break
        case 'texture':
          i = this._invokeOne(function (t) {
            return t.loadTexture && t.loadTexture(e)
          })
          break
        case 'skin':
          i = this.loadSkin(e)
          break
        case 'animation':
          i = this.loadAnimation(e)
          break
        case 'camera':
          i = this.loadCamera(e)
          break
        default:
          throw new Error('Unknown type: ' + t)
      }
      this.cache.add(n, i)
    }
    return i
  }
  getDependencies(t) {
    let e = this.cache.get(t)
    if (!e) {
      const n = this,
        i = this.json[t + ('mesh' === t ? 'es' : 's')] || []
      ;(e = Promise.all(
        i.map(function (e, i) {
          return n.getDependency(t, i)
        })
      )),
        this.cache.add(t, e)
    }
    return e
  }
  loadBuffer(t) {
    const e = this.json.buffers[t],
      n = this.fileLoader
    if (e.type && 'arraybuffer' !== e.type)
      throw new Error('THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.')
    if (void 0 === e.uri && 0 === t)
      return Promise.resolve(this.extensions[ml.KHR_BINARY_GLTF].body)
    const i = this.options
    return new Promise(function (t, s) {
      n.load(Da.resolveURL(e.uri, i.path), t, void 0, function () {
        s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
      })
    })
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t]
    return this.getDependency('buffer', e.buffer).then(function (t) {
      const n = e.byteLength || 0,
        i = e.byteOffset || 0
      return t.slice(i, i + n)
    })
  }
  loadAccessor(t) {
    const e = this,
      n = this.json,
      i = this.json.accessors[t]
    if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null)
    const s = []
    return (
      void 0 !== i.bufferView
        ? s.push(this.getDependency('bufferView', i.bufferView))
        : s.push(null),
      void 0 !== i.sparse &&
        (s.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
        s.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
      Promise.all(s).then(function (t) {
        const s = t[0],
          r = Kl[i.type],
          o = ql[i.componentType],
          a = o.BYTES_PER_ELEMENT,
          l = a * r,
          h = i.byteOffset || 0,
          c = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
          u = !0 === i.normalized
        let d, p
        if (c && c !== l) {
          const t = Math.floor(h / c),
            n =
              'InterleavedBuffer:' + i.bufferView + ':' + i.componentType + ':' + t + ':' + i.count
          let l = e.cache.get(n)
          l ||
            ((d = new o(s, t * c, (i.count * c) / a)), (l = new Fs(d, c / a)), e.cache.add(n, l)),
            (p = new zs(l, r, (h % c) / a, u))
        } else
          (d = null === s ? new o(i.count * r) : new o(s, h, i.count * r)), (p = new ae(d, r, u))
        if (void 0 !== i.sparse) {
          const e = Kl.SCALAR,
            n = ql[i.sparse.indices.componentType],
            a = i.sparse.indices.byteOffset || 0,
            l = i.sparse.values.byteOffset || 0,
            h = new n(t[1], a, i.sparse.count * e),
            c = new o(t[2], l, i.sparse.count * r)
          null !== s && (p = new ae(p.array.slice(), p.itemSize, p.normalized))
          for (let t = 0, e = h.length; t < e; t++) {
            const e = h[t]
            if (
              (p.setX(e, c[t * r]),
              r >= 2 && p.setY(e, c[t * r + 1]),
              r >= 3 && p.setZ(e, c[t * r + 2]),
              r >= 4 && p.setW(e, c[t * r + 3]),
              r >= 5)
            )
              throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
          }
        }
        return p
      })
    )
  }
  loadTexture(t) {
    const e = this.json,
      n = this.options,
      i = e.textures[t].source,
      s = e.images[i]
    let r = this.textureLoader
    if (s.uri) {
      const t = n.manager.getHandler(s.uri)
      null !== t && (r = t)
    }
    return this.loadTextureImage(t, i, r)
  }
  loadTextureImage(t, e, n) {
    const i = this,
      s = this.json,
      r = s.textures[t],
      o = s.images[e],
      a = (o.uri || o.bufferView) + ':' + r.sampler
    if (this.textureCache[a]) return this.textureCache[a]
    const l = this.loadImageSource(e, n)
      .then(function (e) {
        ;(e.flipY = !1), r.name && (e.name = r.name)
        const n = (s.samplers || {})[r.sampler] || {}
        return (
          (e.magFilter = Zl[n.magFilter] || 1006),
          (e.minFilter = Zl[n.minFilter] || 1008),
          (e.wrapS = Xl[n.wrapS] || 1e3),
          (e.wrapT = Xl[n.wrapT] || 1e3),
          i.associations.set(e, { textures: t }),
          e
        )
      })
      .catch(function () {
        return null
      })
    return (this.textureCache[a] = l), l
  }
  loadImageSource(t, e) {
    const n = this,
      i = this.json,
      s = this.options
    if (void 0 !== this.sourceCache[t]) return this.sourceCache[t].then((t) => t.clone())
    const r = i.images[t],
      o = self.URL || self.webkitURL
    let a = r.uri || '',
      l = !1
    if (void 0 !== r.bufferView)
      a = n.getDependency('bufferView', r.bufferView).then(function (t) {
        l = !0
        const e = new Blob([t], { type: r.mimeType })
        return (a = o.createObjectURL(e)), a
      })
    else if (void 0 === r.uri)
      throw new Error('THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView')
    const h = Promise.resolve(a)
      .then(function (t) {
        return new Promise(function (n, i) {
          let r = n
          !0 === e.isImageBitmapLoader &&
            (r = function (t) {
              const e = new F(t)
              ;(e.needsUpdate = !0), n(e)
            }),
            e.load(Da.resolveURL(t, s.path), r, void 0, i)
        })
      })
      .then(function (t) {
        var e
        return (
          !0 === l && o.revokeObjectURL(a),
          (t.userData.mimeType =
            r.mimeType ||
            ((e = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/)
              ? 'image/jpeg'
              : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/)
                ? 'image/webp'
                : 'image/png')),
          t
        )
      })
      .catch(function (t) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", a), t)
      })
    return (this.sourceCache[t] = h), h
  }
  assignTexture(t, e, n, i) {
    const s = this
    return this.getDependency('texture', n.index).then(function (r) {
      if (
        (void 0 === n.texCoord ||
          0 == n.texCoord ||
          ('aoMap' === e && 1 == n.texCoord) ||
          console.warn(
            'THREE.GLTFLoader: Custom UV set ' +
              n.texCoord +
              ' for texture ' +
              e +
              ' not yet supported.'
          ),
        s.extensions[ml.KHR_TEXTURE_TRANSFORM])
      ) {
        const t = void 0 !== n.extensions ? n.extensions[ml.KHR_TEXTURE_TRANSFORM] : void 0
        if (t) {
          const e = s.associations.get(r)
          ;(r = s.extensions[ml.KHR_TEXTURE_TRANSFORM].extendTexture(r, t)),
            s.associations.set(r, e)
        }
      }
      return void 0 !== i && (r.encoding = i), (t[e] = r), r
    })
  }
  assignFinalMaterial(t) {
    const e = t.geometry
    let n = t.material
    const i = void 0 === e.attributes.tangent,
      s = void 0 !== e.attributes.color,
      r = void 0 === e.attributes.normal
    if (t.isPoints) {
      const t = 'PointsMaterial:' + n.uuid
      let e = this.cache.get(t)
      e ||
        ((e = new Ir()),
        ie.prototype.copy.call(e, n),
        e.color.copy(n.color),
        (e.map = n.map),
        (e.sizeAttenuation = !1),
        this.cache.add(t, e)),
        (n = e)
    } else if (t.isLine) {
      const t = 'LineBasicMaterial:' + n.uuid
      let e = this.cache.get(t)
      e ||
        ((e = new yr()), ie.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)),
        (n = e)
    }
    if (i || s || r) {
      let t = 'ClonedMaterial:' + n.uuid + ':'
      n.isGLTFSpecularGlossinessMaterial && (t += 'specular-glossiness:'),
        i && (t += 'derivative-tangents:'),
        s && (t += 'vertex-colors:'),
        r && (t += 'flat-shading:')
      let e = this.cache.get(t)
      e ||
        ((e = n.clone()),
        s && (e.vertexColors = !0),
        r && (e.flatShading = !0),
        i &&
          (e.normalScale && (e.normalScale.y *= -1),
          e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
        this.cache.add(t, e),
        this.associations.set(e, this.associations.get(n))),
        (n = e)
    }
    n.aoMap &&
      void 0 === e.attributes.uv2 &&
      void 0 !== e.attributes.uv &&
      e.setAttribute('uv2', e.attributes.uv),
      (t.material = n)
  }
  getMaterialType() {
    return Bo
  }
  loadMaterial(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[t]
    let r
    const o = {},
      a = s.extensions || {},
      l = []
    if (a[ml.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const t = i[ml.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
      ;(r = t.getMaterialType()), l.push(t.extendParams(o, s, e))
    } else if (a[ml.KHR_MATERIALS_UNLIT]) {
      const t = i[ml.KHR_MATERIALS_UNLIT]
      ;(r = t.getMaterialType()), l.push(t.extendParams(o, s, e))
    } else {
      const n = s.pbrMetallicRoughness || {}
      if (((o.color = new L(1, 1, 1)), (o.opacity = 1), Array.isArray(n.baseColorFactor))) {
        const t = n.baseColorFactor
        o.color.fromArray(t), (o.opacity = t[3])
      }
      void 0 !== n.baseColorTexture && l.push(e.assignTexture(o, 'map', n.baseColorTexture, 3001)),
        (o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1),
        (o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
        void 0 !== n.metallicRoughnessTexture &&
          (l.push(e.assignTexture(o, 'metalnessMap', n.metallicRoughnessTexture)),
          l.push(e.assignTexture(o, 'roughnessMap', n.metallicRoughnessTexture))),
        (r = this._invokeOne(function (e) {
          return e.getMaterialType && e.getMaterialType(t)
        })),
        l.push(
          Promise.all(
            this._invokeAll(function (e) {
              return e.extendMaterialParams && e.extendMaterialParams(t, o)
            })
          )
        )
    }
    !0 === s.doubleSided && (o.side = 2)
    const h = s.alphaMode || th
    if (
      (h === nh
        ? ((o.transparent = !0), (o.depthWrite = !1))
        : ((o.transparent = !1),
          h === eh && (o.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
      void 0 !== s.normalTexture &&
        r !== se &&
        (l.push(e.assignTexture(o, 'normalMap', s.normalTexture)),
        (o.normalScale = new _(1, 1)),
        void 0 !== s.normalTexture.scale))
    ) {
      const t = s.normalTexture.scale
      o.normalScale.set(t, t)
    }
    return (
      void 0 !== s.occlusionTexture &&
        r !== se &&
        (l.push(e.assignTexture(o, 'aoMap', s.occlusionTexture)),
        void 0 !== s.occlusionTexture.strength && (o.aoMapIntensity = s.occlusionTexture.strength)),
      void 0 !== s.emissiveFactor && r !== se && (o.emissive = new L().fromArray(s.emissiveFactor)),
      void 0 !== s.emissiveTexture &&
        r !== se &&
        l.push(e.assignTexture(o, 'emissiveMap', s.emissiveTexture, 3001)),
      Promise.all(l).then(function () {
        let n
        return (
          (n = r === Dl ? i[ml.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new r(o)),
          s.name && (n.name = s.name),
          sh(n, s),
          e.associations.set(n, { materials: t }),
          s.extensions && ih(i, n, s),
          n
        )
      })
    )
  }
  createUniqueName(t) {
    const e = Ka.sanitizeNodeName(t || '')
    let n = e
    for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + '_' + t
    return (this.nodeNamesUsed[n] = !0), n
  }
  loadGeometries(t) {
    const e = this,
      n = this.extensions,
      i = this.primitiveCache
    function s(t) {
      return n[ml.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) {
        return uh(n, t, e)
      })
    }
    const r = []
    for (let n = 0, o = t.length; n < o; n++) {
      const o = t[n],
        a = oh(o),
        l = i[a]
      if (l) r.push(l.promise)
      else {
        let t
        ;(t =
          o.extensions && o.extensions[ml.KHR_DRACO_MESH_COMPRESSION] ? s(o) : uh(new xe(), o, e)),
          (i[a] = { primitive: o, promise: t }),
          r.push(t)
      }
    }
    return Promise.all(r)
  }
  loadMesh(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[t],
      r = s.primitives,
      o = []
    for (let t = 0, e = r.length; t < e; t++) {
      const e =
        void 0 === r[t].material
          ? (void 0 === (a = this.cache).DefaultMaterial &&
              (a.DefaultMaterial = new Bo({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0
              })),
            a.DefaultMaterial)
          : this.getDependency('material', r[t].material)
      o.push(e)
    }
    var a
    return (
      o.push(e.loadGeometries(r)),
      Promise.all(o).then(function (n) {
        const o = n.slice(0, n.length - 1),
          a = n[n.length - 1],
          l = []
        for (let n = 0, h = a.length; n < h; n++) {
          const h = a[n],
            c = r[n]
          let u
          const d = o[n]
          if (c.mode === Wl || c.mode === Yl || c.mode === jl || void 0 === c.mode)
            (u = !0 === s.isSkinnedMesh ? new or(h, d) : new Fe(h, d)),
              !0 !== u.isSkinnedMesh ||
                u.geometry.attributes.skinWeight.normalized ||
                u.normalizeSkinWeights(),
              c.mode === Yl
                ? (u.geometry = dh(u.geometry, 1))
                : c.mode === jl && (u.geometry = dh(u.geometry, 2))
          else if (c.mode === Vl) u = new Ar(h, d)
          else if (c.mode === kl) u = new br(h, d)
          else if (c.mode === Hl) u = new Tr(h, d)
          else {
            if (c.mode !== Ul)
              throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + c.mode)
            u = new Pr(h, d)
          }
          Object.keys(u.geometry.morphAttributes).length > 0 && rh(u, s),
            (u.name = e.createUniqueName(s.name || 'mesh_' + t)),
            sh(u, s),
            c.extensions && ih(i, u, c),
            e.assignFinalMaterial(u),
            l.push(u)
        }
        for (let n = 0, i = l.length; n < i; n++)
          e.associations.set(l[n], { meshes: t, primitives: n })
        if (1 === l.length) return l[0]
        const h = new Is()
        e.associations.set(h, { meshes: t })
        for (let t = 0, e = l.length; t < e; t++) h.add(l[t])
        return h
      })
    )
  }
  loadCamera(t) {
    let e
    const n = this.json.cameras[t],
      i = n[n.type]
    if (i)
      return (
        'perspective' === n.type
          ? (e = new We(v.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6))
          : 'orthographic' === n.type &&
            (e = new gn(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
        n.name && (e.name = this.createUniqueName(n.name)),
        sh(e, n),
        Promise.resolve(e)
      )
    console.warn('THREE.GLTFLoader: Missing camera parameters.')
  }
  loadSkin(t) {
    const e = this.json.skins[t],
      n = { joints: e.joints }
    return void 0 === e.inverseBindMatrices
      ? Promise.resolve(n)
      : this.getDependency('accessor', e.inverseBindMatrices).then(function (t) {
          return (n.inverseBindMatrices = t), n
        })
  }
  loadAnimation(t) {
    const e = this.json.animations[t],
      n = [],
      i = [],
      s = [],
      r = [],
      o = []
    for (let t = 0, a = e.channels.length; t < a; t++) {
      const a = e.channels[t],
        l = e.samplers[a.sampler],
        h = a.target,
        c = void 0 !== h.node ? h.node : h.id,
        u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
        d = void 0 !== e.parameters ? e.parameters[l.output] : l.output
      n.push(this.getDependency('node', c)),
        i.push(this.getDependency('accessor', u)),
        s.push(this.getDependency('accessor', d)),
        r.push(l),
        o.push(h)
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(i),
      Promise.all(s),
      Promise.all(r),
      Promise.all(o)
    ]).then(function (n) {
      const i = n[0],
        s = n[1],
        r = n[2],
        o = n[3],
        a = n[4],
        l = []
      for (let t = 0, e = i.length; t < e; t++) {
        const e = i[t],
          n = s[t],
          h = r[t],
          c = o[t],
          u = a[t]
        if (void 0 === e) continue
        let d
        switch ((e.updateMatrix(), (e.matrixAutoUpdate = !0), Ql[u.path])) {
          case Ql.weights:
            d = na
            break
          case Ql.rotation:
            d = sa
            break
          default:
            d = oa
        }
        const p = e.name ? e.name : e.uuid,
          g = void 0 !== c.interpolation ? $l[c.interpolation] : 2301,
          f = []
        Ql[u.path] === Ql.weights
          ? e.traverse(function (t) {
              t.morphTargetInfluences && f.push(t.name ? t.name : t.uuid)
            })
          : f.push(p)
        let m = h.array
        if (h.normalized) {
          const t = lh(m.constructor),
            e = new Float32Array(m.length)
          for (let n = 0, i = m.length; n < i; n++) e[n] = m[n] * t
          m = e
        }
        for (let t = 0, e = f.length; t < e; t++) {
          const e = new d(f[t] + '.' + Ql[u.path], n.array, m, g)
          'CUBICSPLINE' === c.interpolation &&
            ((e.createInterpolant = function (t) {
              return new (this instanceof sa ? Bl : Gl)(
                this.times,
                this.values,
                this.getValueSize() / 3,
                t
              )
            }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
            l.push(e)
        }
      }
      const h = e.name ? e.name : 'animation_' + t
      return new aa(h, void 0, l)
    })
  }
  createNodeMesh(t) {
    const e = this.json,
      n = this,
      i = e.nodes[t]
    return void 0 === i.mesh
      ? null
      : n.getDependency('mesh', i.mesh).then(function (t) {
          const e = n._getNodeRef(n.meshCache, i.mesh, t)
          return (
            void 0 !== i.weights &&
              e.traverse(function (t) {
                if (t.isMesh)
                  for (let e = 0, n = i.weights.length; e < n; e++)
                    t.morphTargetInfluences[e] = i.weights[e]
              }),
            e
          )
        })
  }
  loadNode(t) {
    const e = this.json,
      n = this.extensions,
      i = this,
      s = e.nodes[t],
      r = s.name ? i.createUniqueName(s.name) : ''
    return (function () {
      const e = [],
        n = i._invokeOne(function (e) {
          return e.createNodeMesh && e.createNodeMesh(t)
        })
      return (
        n && e.push(n),
        void 0 !== s.camera &&
          e.push(
            i.getDependency('camera', s.camera).then(function (t) {
              return i._getNodeRef(i.cameraCache, s.camera, t)
            })
          ),
        i
          ._invokeAll(function (e) {
            return e.createNodeAttachment && e.createNodeAttachment(t)
          })
          .forEach(function (t) {
            e.push(t)
          }),
        Promise.all(e)
      )
    })().then(function (e) {
      let o
      if (
        ((o =
          !0 === s.isBone ? new ar() : e.length > 1 ? new Is() : 1 === e.length ? e[0] : new Wt()),
        o !== e[0])
      )
        for (let t = 0, n = e.length; t < n; t++) o.add(e[t])
      if (
        (s.name && ((o.userData.name = s.name), (o.name = r)),
        sh(o, s),
        s.extensions && ih(n, o, s),
        void 0 !== s.matrix)
      ) {
        const t = new vt()
        t.fromArray(s.matrix), o.applyMatrix4(t)
      } else
        void 0 !== s.translation && o.position.fromArray(s.translation),
          void 0 !== s.rotation && o.quaternion.fromArray(s.rotation),
          void 0 !== s.scale && o.scale.fromArray(s.scale)
      return (
        i.associations.has(o) || i.associations.set(o, {}), (i.associations.get(o).nodes = t), o
      )
    })
  }
  loadScene(t) {
    const e = this.json,
      n = this.extensions,
      i = this.json.scenes[t],
      s = this,
      r = new Is()
    i.name && (r.name = s.createUniqueName(i.name)), sh(r, i), i.extensions && ih(n, r, i)
    const o = i.nodes || [],
      a = []
    for (let t = 0, n = o.length; t < n; t++) a.push(ch(o[t], r, e, s))
    return Promise.all(a).then(function () {
      return (
        (s.associations = ((t) => {
          const e = new Map()
          for (const [t, n] of s.associations) (t instanceof ie || t instanceof F) && e.set(t, n)
          return (
            t.traverse((t) => {
              const n = s.associations.get(t)
              null != n && e.set(t, n)
            }),
            e
          )
        })(r)),
        r
      )
    })
  }
}
function ch(t, e, n, i) {
  const s = n.nodes[t]
  return i
    .getDependency('node', t)
    .then(function (t) {
      if (void 0 === s.skin) return t
      let e
      return i
        .getDependency('skin', s.skin)
        .then(function (t) {
          e = t
          const n = []
          for (let t = 0, s = e.joints.length; t < s; t++)
            n.push(i.getDependency('node', e.joints[t]))
          return Promise.all(n)
        })
        .then(function (n) {
          return (
            t.traverse(function (t) {
              if (!t.isMesh) return
              const i = [],
                s = []
              for (let t = 0, r = n.length; t < r; t++) {
                const r = n[t]
                if (r) {
                  i.push(r)
                  const n = new vt()
                  void 0 !== e.inverseBindMatrices &&
                    n.fromArray(e.inverseBindMatrices.array, 16 * t),
                    s.push(n)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
              }
              t.bind(new ur(i, s), t.matrixWorld)
            }),
            t
          )
        })
    })
    .then(function (t) {
      e.add(t)
      const r = []
      if (s.children) {
        const e = s.children
        for (let s = 0, o = e.length; s < o; s++) {
          const o = e[s]
          r.push(ch(o, t, n, i))
        }
      }
      return Promise.all(r)
    })
}
function uh(t, e, n) {
  const i = e.attributes,
    s = []
  function r(e, i) {
    return n.getDependency('accessor', e).then(function (e) {
      t.setAttribute(i, e)
    })
  }
  for (const e in i) {
    const n = Jl[e] || e.toLowerCase()
    n in t.attributes || s.push(r(i[e], n))
  }
  if (void 0 !== e.indices && !t.index) {
    const i = n.getDependency('accessor', e.indices).then(function (e) {
      t.setIndex(e)
    })
    s.push(i)
  }
  return (
    sh(t, e),
    (function (t, e, n) {
      const i = e.attributes,
        s = new Y()
      if (void 0 === i.POSITION) return
      {
        const t = n.json.accessors[i.POSITION],
          e = t.min,
          r = t.max
        if (void 0 === e || void 0 === r)
          return void console.warn(
            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.'
          )
        if ((s.set(new H(e[0], e[1], e[2]), new H(r[0], r[1], r[2])), t.normalized)) {
          const e = lh(ql[t.componentType])
          s.min.multiplyScalar(e), s.max.multiplyScalar(e)
        }
      }
      const r = e.targets
      if (void 0 !== r) {
        const t = new H(),
          e = new H()
        for (let i = 0, s = r.length; i < s; i++) {
          const s = r[i]
          if (void 0 !== s.POSITION) {
            const i = n.json.accessors[s.POSITION],
              r = i.min,
              o = i.max
            if (void 0 !== r && void 0 !== o) {
              if (
                (e.setX(Math.max(Math.abs(r[0]), Math.abs(o[0]))),
                e.setY(Math.max(Math.abs(r[1]), Math.abs(o[1]))),
                e.setZ(Math.max(Math.abs(r[2]), Math.abs(o[2]))),
                i.normalized)
              ) {
                const t = lh(ql[i.componentType])
                e.multiplyScalar(t)
              }
              t.max(e)
            } else
              console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
          }
        }
        s.expandByVector(t)
      }
      t.boundingBox = s
      const o = new ct()
      s.getCenter(o.center), (o.radius = s.min.distanceTo(s.max) / 2), (t.boundingSphere = o)
    })(t, e, n),
    Promise.all(s).then(function () {
      return void 0 !== e.targets
        ? (function (t, e, n) {
            let i = !1,
              s = !1,
              r = !1
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t]
              if (
                (void 0 !== n.POSITION && (i = !0),
                void 0 !== n.NORMAL && (s = !0),
                void 0 !== n.COLOR_0 && (r = !0),
                i && s && r)
              )
                break
            }
            if (!i && !s && !r) return Promise.resolve(t)
            const o = [],
              a = [],
              l = []
            for (let h = 0, c = e.length; h < c; h++) {
              const c = e[h]
              if (i) {
                const e =
                  void 0 !== c.POSITION
                    ? n.getDependency('accessor', c.POSITION)
                    : t.attributes.position
                o.push(e)
              }
              if (s) {
                const e =
                  void 0 !== c.NORMAL ? n.getDependency('accessor', c.NORMAL) : t.attributes.normal
                a.push(e)
              }
              if (r) {
                const e =
                  void 0 !== c.COLOR_0 ? n.getDependency('accessor', c.COLOR_0) : t.attributes.color
                l.push(e)
              }
            }
            return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (e) {
              const n = e[0],
                o = e[1],
                a = e[2]
              return (
                i && (t.morphAttributes.position = n),
                s && (t.morphAttributes.normal = o),
                r && (t.morphAttributes.color = a),
                (t.morphTargetsRelative = !0),
                t
              )
            })
          })(t, e.targets, n)
        : t
    })
  )
}
function dh(t, e) {
  let n = t.getIndex()
  if (null === n) {
    const e = [],
      i = t.getAttribute('position')
    if (void 0 === i)
      return (
        console.error(
          'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
        ),
        t
      )
    for (let t = 0; t < i.count; t++) e.push(t)
    t.setIndex(e), (n = t.getIndex())
  }
  const i = n.count - 2,
    s = []
  if (2 === e)
    for (let t = 1; t <= i; t++) s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1))
  else
    for (let t = 0; t < i; t++)
      t % 2 == 0
        ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2)))
        : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)))
  s.length / 3 !== i &&
    console.error(
      'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.'
    )
  const r = t.clone()
  return r.setIndex(s), r
}
const ph = { type: 'change' },
  gh = { type: 'start' },
  fh = { type: 'end' }
class mh extends a {
  constructor(a, l) {
    super(),
      (this.minPan = new H(-0.3, -0.3, -0.3)),
      (this.maxPan = new H(0.6, 0.6, 0.6)),
      void 0 === l &&
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
      l === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.object = a),
      (this.domElement = l),
      (this.domElement.style.touchAction = 'none'),
      (this.enabled = !0),
      (this.target = new H()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }),
      (this.mouseButtons = { LEFT: t, MIDDLE: e, RIGHT: n }),
      (this.touches = { ONE: i, TWO: r }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return p.phi
      }),
      (this.getAzimuthalAngle = function () {
        return p.theta
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target)
      }),
      (this.listenToKeyEvents = function (t) {
        t.addEventListener('keydown', $), (this._domElementKeyEvents = t)
      }),
      (this.saveState = function () {
        h.target0.copy(h.target), h.position0.copy(h.object.position), (h.zoom0 = h.object.zoom)
      }),
      (this.reset = function () {
        h.target.copy(h.target0),
          h.object.position.copy(h.position0),
          (h.object.zoom = h.zoom0),
          h.object.updateProjectionMatrix(),
          h.dispatchEvent(ph),
          h.update(),
          (u = c.NONE)
      }),
      (this.update = (function () {
        const t = new H(),
          e = new V().setFromUnitVectors(a.up, new H(0, 1, 0)),
          n = e.clone().invert(),
          i = new H(),
          s = new V(),
          r = 2 * Math.PI
        return function () {
          const o = h.object.position
          t.copy(o).sub(h.target),
            t.applyQuaternion(e),
            p.setFromVector3(t),
            h.autoRotate && u === c.NONE && C(((2 * Math.PI) / 60 / 60) * h.autoRotateSpeed),
            h.enableDamping
              ? ((p.theta += g.theta * h.dampingFactor), (p.phi += g.phi * h.dampingFactor))
              : ((p.theta += g.theta), (p.phi += g.phi))
          let a = h.minAzimuthAngle,
            l = h.maxAzimuthAngle
          return (
            isFinite(a) &&
              isFinite(l) &&
              (a < -Math.PI ? (a += r) : a > Math.PI && (a -= r),
              l < -Math.PI ? (l += r) : l > Math.PI && (l -= r),
              (p.theta =
                a <= l
                  ? Math.max(a, Math.min(l, p.theta))
                  : p.theta > (a + l) / 2
                    ? Math.max(a, p.theta)
                    : Math.min(l, p.theta))),
            (p.phi = Math.max(h.minPolarAngle, Math.min(h.maxPolarAngle, p.phi))),
            p.makeSafe(),
            (p.radius *= f),
            (p.radius = Math.max(h.minDistance, Math.min(h.maxDistance, p.radius))),
            !0 === h.enableDamping ? h.target.addScaledVector(m, h.dampingFactor) : h.target.add(m),
            h.target.clamp(this.minPan, this.maxPan),
            t.setFromSpherical(p),
            t.applyQuaternion(n),
            o.copy(h.target).add(t),
            h.object.lookAt(h.target),
            !0 === h.enableDamping
              ? ((g.theta *= 1 - h.dampingFactor),
                (g.phi *= 1 - h.dampingFactor),
                m.multiplyScalar(1 - h.dampingFactor))
              : (g.set(0, 0, 0), m.set(0, 0, 0)),
            (f = 1),
            !!(
              y ||
              i.distanceToSquared(h.object.position) > d ||
              8 * (1 - s.dot(h.object.quaternion)) > d
            ) &&
              (h.dispatchEvent(ph),
              i.copy(h.object.position),
              s.copy(h.object.quaternion),
              (y = !1),
              !0)
          )
        }
      })()),
      (this.dispose = function () {
        h.domElement.removeEventListener('contextmenu', tt),
          h.domElement.removeEventListener('pointerdown', Z),
          h.domElement.removeEventListener('pointercancel', J),
          h.domElement.removeEventListener('wheel', Q),
          h.domElement.removeEventListener('pointermove', X),
          h.domElement.removeEventListener('pointerup', K),
          null !== h._domElementKeyEvents &&
            h._domElementKeyEvents.removeEventListener('keydown', $)
      })
    const h = this,
      c = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }
    let u = c.NONE
    const d = 1e-6,
      p = new el(),
      g = new el()
    let f = 1
    const m = new H()
    let y = !1
    const x = new _(),
      v = new _(),
      w = new _(),
      E = new _(),
      b = new _(),
      M = new _(),
      S = new _(),
      A = new _(),
      T = new _(),
      I = [],
      R = {}
    function L() {
      return Math.pow(0.95, h.zoomSpeed)
    }
    function C(t) {
      g.theta -= t
    }
    function N(t) {
      g.phi -= t
    }
    const P = (function () {
        const t = new H()
        return function (e, n) {
          t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), m.add(t)
        }
      })(),
      D = (function () {
        const t = new H()
        return function (e, n) {
          !0 === h.screenSpacePanning
            ? t.setFromMatrixColumn(n, 1)
            : (t.setFromMatrixColumn(n, 0), t.crossVectors(h.object.up, t)),
            t.multiplyScalar(e),
            m.add(t)
        }
      })(),
      O = (function () {
        const t = new H()
        return function (e, n) {
          const i = h.domElement
          if (h.object.isPerspectiveCamera) {
            const s = h.object.position
            t.copy(s).sub(h.target)
            let r = t.length()
            ;(r *= Math.tan(((h.object.fov / 2) * Math.PI) / 180)),
              P((2 * e * r) / i.clientHeight, h.object.matrix),
              D((2 * n * r) / i.clientHeight, h.object.matrix)
          } else
            h.object.isOrthographicCamera
              ? (P(
                  (e * (h.object.right - h.object.left)) / h.object.zoom / i.clientWidth,
                  h.object.matrix
                ),
                D(
                  (n * (h.object.top - h.object.bottom)) / h.object.zoom / i.clientHeight,
                  h.object.matrix
                ))
              : (console.warn(
                  'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
                ),
                (h.enablePan = !1))
        }
      })()
    function F(t) {
      h.object.isPerspectiveCamera
        ? (f /= t)
        : h.object.isOrthographicCamera
          ? ((h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom * t))),
            h.object.updateProjectionMatrix(),
            (y = !0))
          : (console.warn(
              'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
            ),
            (h.enableZoom = !1))
    }
    function G(t) {
      h.object.isPerspectiveCamera
        ? (f *= t)
        : h.object.isOrthographicCamera
          ? ((h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom / t))),
            h.object.updateProjectionMatrix(),
            (y = !0))
          : (console.warn(
              'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
            ),
            (h.enableZoom = !1))
    }
    function z(t) {
      x.set(t.clientX, t.clientY)
    }
    function B(t) {
      E.set(t.clientX, t.clientY)
    }
    function U() {
      if (1 === I.length) x.set(I[0].pageX, I[0].pageY)
      else {
        const t = 0.5 * (I[0].pageX + I[1].pageX),
          e = 0.5 * (I[0].pageY + I[1].pageY)
        x.set(t, e)
      }
    }
    function k() {
      if (1 === I.length) E.set(I[0].pageX, I[0].pageY)
      else {
        const t = 0.5 * (I[0].pageX + I[1].pageX),
          e = 0.5 * (I[0].pageY + I[1].pageY)
        E.set(t, e)
      }
    }
    function W() {
      const t = I[0].pageX - I[1].pageX,
        e = I[0].pageY - I[1].pageY,
        n = Math.sqrt(t * t + e * e)
      S.set(0, n)
    }
    function Y(t) {
      if (1 == I.length) v.set(t.pageX, t.pageY)
      else {
        const e = it(t),
          n = 0.5 * (t.pageX + e.x),
          i = 0.5 * (t.pageY + e.y)
        v.set(n, i)
      }
      w.subVectors(v, x).multiplyScalar(h.rotateSpeed)
      const e = h.domElement
      C((2 * Math.PI * w.x) / e.clientHeight), N((2 * Math.PI * w.y) / e.clientHeight), x.copy(v)
    }
    function j(t) {
      if (1 === I.length) b.set(t.pageX, t.pageY)
      else {
        const e = it(t),
          n = 0.5 * (t.pageX + e.x),
          i = 0.5 * (t.pageY + e.y)
        b.set(n, i)
      }
      M.subVectors(b, E).multiplyScalar(h.panSpeed), O(M.x, M.y), E.copy(b)
    }
    function q(t) {
      const e = it(t),
        n = t.pageX - e.x,
        i = t.pageY - e.y,
        s = Math.sqrt(n * n + i * i)
      A.set(0, s), T.set(0, Math.pow(A.y / S.y, h.zoomSpeed)), F(T.y), S.copy(A)
    }
    function Z(a) {
      !1 !== h.enabled &&
        (0 === I.length &&
          (h.domElement.setPointerCapture(a.pointerId),
          h.domElement.addEventListener('pointermove', X),
          h.domElement.addEventListener('pointerup', K)),
        (function (t) {
          I.push(t)
        })(a),
        'touch' === a.pointerType
          ? (function (t) {
              switch ((nt(t), I.length)) {
                case 1:
                  switch (h.touches.ONE) {
                    case i:
                      if (!1 === h.enableRotate) return
                      U(), (u = c.TOUCH_ROTATE)
                      break
                    case s:
                      if (!1 === h.enablePan) return
                      k(), (u = c.TOUCH_PAN)
                      break
                    default:
                      u = c.NONE
                  }
                  break
                case 2:
                  switch (h.touches.TWO) {
                    case r:
                      if (!1 === h.enableZoom && !1 === h.enablePan) return
                      h.enableZoom && W(), h.enablePan && k(), (u = c.TOUCH_DOLLY_PAN)
                      break
                    case o:
                      if (!1 === h.enableZoom && !1 === h.enableRotate) return
                      h.enableZoom && W(), h.enableRotate && U(), (u = c.TOUCH_DOLLY_ROTATE)
                      break
                    default:
                      u = c.NONE
                  }
                  break
                default:
                  u = c.NONE
              }
              u !== c.NONE && h.dispatchEvent(gh)
            })(a)
          : (function (i) {
              let s
              switch (i.button) {
                case 0:
                  s = h.mouseButtons.LEFT
                  break
                case 1:
                  s = h.mouseButtons.MIDDLE
                  break
                case 2:
                  s = h.mouseButtons.RIGHT
                  break
                default:
                  s = -1
              }
              switch (s) {
                case e:
                  if (!1 === h.enableZoom) return
                  !(function (t) {
                    S.set(t.clientX, t.clientY)
                  })(i),
                    (u = c.DOLLY)
                  break
                case t:
                  if (i.ctrlKey || i.metaKey || i.shiftKey) {
                    if (!1 === h.enablePan) return
                    B(i), (u = c.PAN)
                  } else {
                    if (!1 === h.enableRotate) return
                    z(i), (u = c.ROTATE)
                  }
                  break
                case n:
                  if (i.ctrlKey || i.metaKey || i.shiftKey) {
                    if (!1 === h.enableRotate) return
                    z(i), (u = c.ROTATE)
                  } else {
                    if (!1 === h.enablePan) return
                    B(i), (u = c.PAN)
                  }
                  break
                default:
                  u = c.NONE
              }
              u !== c.NONE && h.dispatchEvent(gh)
            })(a))
    }
    function X(t) {
      !1 !== h.enabled &&
        ('touch' === t.pointerType
          ? (function (t) {
              switch ((nt(t), u)) {
                case c.TOUCH_ROTATE:
                  if (!1 === h.enableRotate) return
                  Y(t), h.update()
                  break
                case c.TOUCH_PAN:
                  if (!1 === h.enablePan) return
                  j(t), h.update()
                  break
                case c.TOUCH_DOLLY_PAN:
                  if (!1 === h.enableZoom && !1 === h.enablePan) return
                  !(function (t) {
                    h.enableZoom && q(t), h.enablePan && j(t)
                  })(t),
                    h.update()
                  break
                case c.TOUCH_DOLLY_ROTATE:
                  if (!1 === h.enableZoom && !1 === h.enableRotate) return
                  !(function (t) {
                    h.enableZoom && q(t), h.enableRotate && Y(t)
                  })(t),
                    h.update()
                  break
                default:
                  u = c.NONE
              }
            })(t)
          : (function (t) {
              if (!1 === h.enabled) return
              switch (u) {
                case c.ROTATE:
                  if (!1 === h.enableRotate) return
                  !(function (t) {
                    v.set(t.clientX, t.clientY), w.subVectors(v, x).multiplyScalar(h.rotateSpeed)
                    const e = h.domElement
                    C((2 * Math.PI * w.x) / e.clientHeight),
                      N((2 * Math.PI * w.y) / e.clientHeight),
                      x.copy(v),
                      h.update()
                  })(t)
                  break
                case c.DOLLY:
                  if (!1 === h.enableZoom) return
                  !(function (t) {
                    A.set(t.clientX, t.clientY),
                      T.subVectors(A, S),
                      T.y > 0 ? F(L()) : T.y < 0 && G(L()),
                      S.copy(A),
                      h.update()
                  })(t)
                  break
                case c.PAN:
                  if (!1 === h.enablePan) return
                  !(function (t) {
                    b.set(t.clientX, t.clientY),
                      M.subVectors(b, E).multiplyScalar(h.panSpeed),
                      O(M.x, M.y),
                      E.copy(b),
                      h.update()
                  })(t)
              }
            })(t))
    }
    function K(t) {
      et(t),
        0 === I.length &&
          (h.domElement.releasePointerCapture(t.pointerId),
          h.domElement.removeEventListener('pointermove', X),
          h.domElement.removeEventListener('pointerup', K)),
        h.dispatchEvent(fh),
        (u = c.NONE)
    }
    function J(t) {
      et(t)
    }
    function Q(t) {
      !1 !== h.enabled &&
        !1 !== h.enableZoom &&
        u === c.NONE &&
        (t.preventDefault(),
        h.dispatchEvent(gh),
        (function (t) {
          t.deltaY < 0 ? G(L()) : t.deltaY > 0 && F(L()), h.update()
        })(t),
        h.dispatchEvent(fh))
    }
    function $(t) {
      !1 !== h.enabled &&
        !1 !== h.enablePan &&
        (function (t) {
          let e = !1
          switch (t.code) {
            case h.keys.UP:
              O(0, h.keyPanSpeed), (e = !0)
              break
            case h.keys.BOTTOM:
              O(0, -h.keyPanSpeed), (e = !0)
              break
            case h.keys.LEFT:
              O(h.keyPanSpeed, 0), (e = !0)
              break
            case h.keys.RIGHT:
              O(-h.keyPanSpeed, 0), (e = !0)
          }
          e && (t.preventDefault(), h.update())
        })(t)
    }
    function tt(t) {
      !1 !== h.enabled && t.preventDefault()
    }
    function et(t) {
      delete R[t.pointerId]
      for (let e = 0; e < I.length; e++)
        if (I[e].pointerId == t.pointerId) return void I.splice(e, 1)
    }
    function nt(t) {
      let e = R[t.pointerId]
      void 0 === e && ((e = new _()), (R[t.pointerId] = e)), e.set(t.pageX, t.pageY)
    }
    function it(t) {
      const e = t.pointerId === I[0].pointerId ? I[1] : I[0]
      return R[e.pointerId]
    }
    h.domElement.addEventListener('contextmenu', tt),
      h.domElement.addEventListener('pointerdown', Z),
      h.domElement.addEventListener('pointercancel', J),
      h.domElement.addEventListener('wheel', Q, { passive: !1 }),
      this.update()
  }
}
let yh = {
  container_id: 'container',
  isMobile: !1,
  showCompass: !1,
  compassInitValue: 0,
  path_show_all_path: !0,
  camera: { x: 1.5, y: 1.5, z: 1.5 }
}
let xh = {}
class vh {
  static devGltfs = {}
  constructor(t, e) {
    ;(this.rootApp = t),
      (this.loader = t.loader),
      (this.pointer = new _()),
      (this.floorApp = e),
      (this.selectObj = null),
      this._init()
  }
  async getDevGroup(t) {
    let e = xh.wholeJson.devModelUrlPrefix
    t.code && console.log(content)
    const n = new Set()
    for (let i of t.devs) {
      let t = i.url
      vh.devGltfs[e + t] || n.add(e + t)
    }
    let i = Array.from(n)
    await this._getDevGltf(i)
    let s = this._setDevGltf(t)
    return (s.visible = !1), s
  }
  _setDevGltf(t) {
    let e = xh.wholeJson.devModelUrlPrefix,
      n = new Is(),
      i = new Uo({
        map: null,
        color: 8947814,
        metalness: 0,
        roughness: 0,
        opacity: 0.8,
        side: 2,
        transparent: !0,
        envMapIntensity: 10,
        premultipliedAlpha: !0,
        emissive: 8947763,
        depthWrite: !0
      })
    new Uo({
      map: null,
      color: 3355443,
      opacity: 1,
      side: 2,
      transparent: !0,
      emissive: 3355443,
      depthWrite: !0,
      depthTest: !1
    })
    let s = new Bo({ side: 2, color: 4217486, depthWrite: !0, depthTest: !0 })
    for (let r of t.devs) {
      let t = vh.devGltfs[e + r.url].clone()
      n.add(t),
        t.translateX(r.px),
        t.translateY(r.py),
        t.translateZ(r.pz),
        (t.name = r.name),
        r.rx && t.rotateX(r.rx),
        r.ry && t.rotateY(r.ry),
        r.rz && t.rotateZ(r.rz),
        r.sx && r.sy && r.sz && t.scale.set(r.sx, r.sy, r.sz),
        (t.material.depthWrite = !0),
        (t.material.depthTest = !1),
        (t.userData.devInfo = r)
      let o = r.url
      o.endsWith('180.gltf') && (t.material = i),
        o.endsWith('LouTi.gltf') && ((t.material = s), (t.frustumCulled = !1), (t.renderOrder = 2))
    }
    return n
  }
  async _getDevGltf(t) {
    let e = []
    for (let n of t) e.push(this.loader.loadAsync(n))
    let n = await Promise.all(e),
      i = []
    for (let t of n) {
      let e = t.scene || t.scenes[0]
      i.push(e.children[0])
    }
    for (let e in t) {
      let n = t[e],
        s = i[e]
      s.traverse((t) => {
        t.frustumCulled = !1
      }),
        (vh.devGltfs[n] = s)
    }
  }
  _init() {
    this.rootApp.addEventListener('onPostFloorOpen', (t) => {
      let e = 'group_floor_' + t.floor
      this.rootApp.curBuildingApp.buildingGroup.traverse((t) => {
        t && t.name && t.name.startsWith('group_dev') && t.parent.name === e && (t.visible = !0)
      })
    }),
      this.rootApp.addEventListener('onPostFloorOpen', (t) => {
        let e = 'group_floor_' + t.floor
        this.rootApp.curBuildingApp.buildingGroup.traverse((t) => {
          t && t.name && t.name.startsWith('group_dev') && t.parent.name === e && (t.visible = !0)
        })
      }),
      this.rootApp.addEventListener('onPostFloorClose', (t) => {
        this.rootApp.curBuildingApp.buildingGroup.traverse((t) => {
          t && t.name && t.name.startsWith('group_dev') && (t.visible = !1)
        })
      }),
      this.rootApp.renderer.domElement.addEventListener('pointermove', (t) => {
        if (
          this.floorApp.builidingApp === this.rootApp.curBuildingApp &&
          'dev' === this.rootApp.eventApp.curEvent
        ) {
          const e = this.rootApp.renderer.domElement.getBoundingClientRect()
          ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
            (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
            this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
          let n = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
            i = this.rootApp.curBuildingApp.floorApp.floorGltfs[n]
          if (i) {
            let t = i.getObjectByName('group_dev')
            const e = this.rootApp.raycaster.intersectObjects(t.children, !0)
            if (e.length > 0) {
              const t = e[0].object
              if (t.name.startsWith('roomtip')) return
              if (this.selectObj) return
              let n = 2,
                i = t.userData.devInfo
              if (i.url.endsWith('LouTi.gltf')) return
              i.sx && i.sy && i.sz
                ? t.scale.set(n * i.sx, n * i.sy, n * i.sz)
                : t.scale.set(n, n, n),
                (this.selectObj = t)
            } else if (this.selectObj) {
              this.selectObj.scale.set(1, 1, 1)
              let t = this.selectObj.userData.devInfo
              t.sx && t.sy && t.sz
                ? this.selectObj.scale.set(t.sx, t.sy, t.sz)
                : this.selectObj.scale.set(1, 1, 1),
                (this.selectObj = null)
            }
          }
        }
      }),
      this.rootApp.renderer.domElement.addEventListener('pointerdown', (t) => {}),
      this.rootApp.renderer.domElement.addEventListener('pointerup', (t) => {
        if (
          this.floorApp.builidingApp === this.rootApp.curBuildingApp &&
          'dev' === this.rootApp.eventApp.curEvent
        ) {
          const e = this.rootApp.renderer.domElement.getBoundingClientRect()
          ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
            (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
            this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
          let n = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
            i = this.rootApp.curBuildingApp.floorApp.floorGltfs[n].getObjectByName('group_dev')
          const s = this.rootApp.raycaster.intersectObjects(i.children, !0)
          if (s.length > 0) {
            const e = s[0].object
            e.name.startsWith('roomtip')
              ? this.rootApp.dispatchEvent({
                  type: 'onClickRoomTip',
                  onclickEvent: t,
                  roomNameTip: e.name,
                  roomName: e.userData.roomName,
                  roomtip: e
                })
              : this.rootApp.dispatchEvent({
                  type: 'onClickDev',
                  onclickEvent: t,
                  devName: e.name,
                  dev: e
                })
          }
        }
      })
  }
  setDevColor(t, e) {
    'string' == typeof t && (t = [t])
    for (let n of t) {
      let t = this.rootApp.scene.getObjectByName(n)
      if (t) {
        t.userData.material || (t.userData.material = t.material),
          console.log('=======obj======', t)
        let n = t.material.clone()
        n.color.set(e), (t.material = n)
      } else console.info(n, ' not found')
    }
    this.rootApp.render()
  }
  resetDevColor(t) {
    'string' == typeof t && (t = [t])
    for (let e of t) {
      let t = this.rootApp.scene.getObjectByName(e)
      t
        ? t.userData.material &&
          t.userData.material.type.includes('Material') &&
          (t.material = t.userData.material)
        : console.info(e, ' not found')
    }
    this.rootApp.render()
  }
  visibleDev(t, e) {
    'string' == typeof t && (t = [t])
    for (let n of t) {
      let t = this.rootApp.scene.getObjectByName(n)
      t ? (t.visible = e) : console.info(n, ' not found')
    }
  }
  resetAllDevColor() {
    try {
      let t = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
        e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t].getObjectByName('group_dev')
      for (let t of e.children)
        t.userData.material && (t.userData.material.metadata || (t.material = t.userData.material))
    } catch (t) {
      console.error(t)
    }
  }
  setAllDevColor(t) {
    let e = new Bo({ color: t, opacity: 0.8, transparent: !0, side: 2 }),
      n = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
      i = this.rootApp.curBuildingApp.floorApp.floorGltfs[n].getObjectByName('group_dev')
    try {
      for (let t of i.children)
        t &&
          (t.userData.material || (t.userData.material = t.material),
          console.log('=======obj======', t),
          (t.material = e))
    } catch (t) {
      console.error(t)
    }
  }
}
class _h {
  constructor(t, e) {
    ;(this.rootApp = t), (this.floorApp = e), (this.pointer = new _()), this._init()
  }
  _init() {}
  async getRoomName(t, e) {
    this.curRoomJson = t
    for (let n of t.rooms) {
      let t = e.getObjectByName(n.roomId)
      void 0 !== t && (t.userData.roomInfo = n)
    }
  }
  setRoomColor(t, e) {
    'string' == typeof t && (t = [t])
    for (let n of t) {
      let t = this.rootApp.scene.getObjectByName(n)
      if (t) {
        t.userData.material || (t.userData.material = t.material)
        let n = t.material.clone()
        n.color.set(e), (t.material = n), (t.material.visible = !0)
      } else console.info(n, ' not found')
    }
    this.rootApp.render()
  }
  resetRoomColor(t) {
    'string' == typeof t && (t = [t])
    for (let e of t) {
      let t = this.rootApp.scene.getObjectByName(e)
      t
        ? t.userData.material &&
          t.userData.material.type.includes('Material') &&
          ((t.material = t.userData.material),
          delete t.userData.material,
          (t.material.visible = !1))
        : console.info(e, ' not found')
    }
  }
  resetAllRoomColor() {
    try {
      for (let t in this.rootApp.curBuildingApp.floorApp.floorGltfs) {
        let e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t].getObjectByName('group_room')
        for (let t of e.children)
          t.userData.material &&
            (t.userData.material.metadata ||
              ((t.material = t.userData.material),
              delete t.userData.material,
              (t.material.visible = !1)))
      }
    } catch (t) {
      console.error(t)
    }
  }
  delAllRoomTip() {
    for (let t in this.rootApp.curBuildingApp.floorApp.floorGltfs) {
      let e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t].getObjectByName('group_dev'),
        n = []
      for (let t of e.children) t.isSprite && n.push(t)
      for (let t of n) t.removeFromParent()
    }
  }
  showAllRoomTip() {
    let t = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
      e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t].getObjectByName('group_room')
    for (let t of e.children) this.showRoomTip(t)
  }
  showRoomTipByRoomId(t) {
    'string' == typeof t && (t = [t])
    for (let e of t) {
      let t = this.rootApp.scene.getObjectByName(e)
      t && this.showRoomTip(t)
    }
  }
  delRoomTipByRoomId(t) {
    'string' == typeof t && (t = [t])
    for (let e of t) {
      let t = this.rootApp.scene.getObjectByName('roomtip_' + e)
      t && t.removeFromParent()
    }
  }
  showRoomTip(t) {
    let e = t.userData.roomInfo
    if (void 0 === e) return
    let n = e.roomName
    if (n.length < 1) return
    const i = (function (t, e) {
      let n = 0.015,
        i = '#000040',
        s = 24,
        r = '#ffffff',
        o = 4,
        a = '#ffffff'
      e &&
        (e.scale && (n = e.scale),
        e.backColor && (i = e.backColor),
        e.font && (s = e.font),
        e.fontColor && (r = e.fontColor),
        e.egeColor && (a = e.egeColor),
        e.egeSize && (o = e.egeSize))
      let l = t.length
      if (l < 1) return
      l = (function (t) {
        let e = 0
        for (let n = 0; n < t.length; n++)
          t.charCodeAt(n) > 127 || 94 == t.charCodeAt(n) ? (e += 2) : e++
        return (e + 1) / 2
      })(t)
      let h = 40,
        c = 40 + l * s
      const u = document.createElement('canvas')
      let d = u.getContext('2d')
      ;(u.width = o + c), (u.height = o + h)
      let p = u.height / 2
      d.beginPath(),
        d.moveTo(p, 0),
        d.lineTo(u.width - p, 0),
        d.arcTo(u.width, 0, u.width, p, p),
        d.lineTo(u.width, u.height - p),
        d.arcTo(u.width, u.height, u.width - p, u.height, p),
        d.lineTo(p, u.height),
        d.arcTo(0, u.height, 0, u.height - p, p),
        d.lineTo(0, p),
        d.arcTo(0, 0, p, 0, p),
        d.closePath(),
        (d.fillStyle = a),
        d.fill(),
        d.translate(o / 2, o / 2),
        (p = 20),
        d.beginPath(),
        d.moveTo(p, 0),
        d.lineTo(c - p, 0),
        d.arcTo(c, 0, c, p, p),
        d.lineTo(c, h - p),
        d.arcTo(c, h, c - p, h, p),
        d.lineTo(p, h),
        d.arcTo(0, h, 0, h - p, p),
        d.lineTo(0, p),
        d.arcTo(0, 0, p, 0, p),
        d.closePath(),
        (d.fillStyle = i),
        d.fill(),
        (d.font = s + 'px "Microsoft Yahei","",Tahoma,Arial'),
        (d.fillStyle = r),
        (d.textAlign = 'center'),
        (d.textBaseline = 'middle'),
        d.fillText(t, u.width / 2, u.height / 2)
      let g = new Or(u),
        f = new Bs({ map: g, sizeAttenuation: !1, depthTest: !1 })
      const m = new $s(f)
      return m.scale.set((n * u.width) / u.height, n, 1), (m.renderOrder = 10), m
    })(n, { backColor: e.roomTipColor })
    let s = new H(1 / this.rootApp.scaleWhole, 1 / this.rootApp.scaleWhole, 1)
    i.scale.multiply(s),
      i.position.set(e.px, e.py + 1e3, e.pz),
      (i.name = 'roomtip_' + t.name),
      (i.userData.roomName = t.name),
      t.parent.parent.getObjectByName('group_dev').add(i)
  }
}
class wh {
  constructor(t, e) {
    ;(this.rootApp = t),
      (this.builidingApp = e),
      (this.loader = this.rootApp.loader),
      (this.floorGltfs = {}),
      (this.devApp = new vh(t, this)),
      (this.roomApp = new _h(t, this)),
      (this.showOut = null)
  }
  createFloorModel(t, e) {
    if (this.showOut) {
      if (0 !== t) {
        let e = this.floorGltfs[t]
        this.builidingApp.buildingGroup.remove(e),
          (this.builidingApp.floorAnimationApp.allFloorDic[t].visible = !0)
      }
      if (0 !== e) {
        let t = this.floorGltfs[e]
        this.builidingApp.buildingGroup.add(t)
        let n = this.builidingApp.floorAnimationApp.allFloorDic[e]
        t.position.copy(n.position), (n.visible = !1)
      }
    }
  }
  setGltf(t) {
    for (let e of t) this.floorGltfs[e.floor] = e.model
    t = t.sort((t, e) => t.floor - e.floor)
    let e = 0
    for (let n = 0; n < t.length; n++) {
      let i = t[n].floor,
        s = t[n].model
      ;(s.floor = i), s.translateY(e)
      let r = s.userData.wallHeigth
      e += r || 3e3
    }
  }
}
new Y(),
  new H(),
  (on.line = {
    worldUnits: { value: 1 },
    linewidth: { value: 1 },
    resolution: { value: new _(1, 1) },
    dashOffset: { value: 0 },
    dashScale: { value: 1 },
    dashSize: { value: 1 },
    gapSize: { value: 1 }
  }),
  (an.line = {
    uniforms: Ve.merge([on.common, on.fog, on.line]),
    vertexShader:
      "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
    fragmentShader:
      '\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t'
  }),
  new H(),
  new H(),
  new G(),
  new G(),
  new G(),
  new H(),
  new vt(),
  new sl(),
  new H(),
  new Y(),
  new ct(),
  new G()
class Eh {
  constructor(t, e, n) {
    ;(this.rootApp = t),
      (this.buildingName = n),
      (this.setJson = e),
      (this.solidMaterial = new Uo({
        metalness: 0.4,
        color: 16711680,
        opacity: 0.2,
        transparent: !0,
        roughness: 0.4,
        transmission: 0.45,
        refractionRatio: 0.2,
        reflectivity: 0,
        polygonOffset: !0,
        polygonOffsetUnits: 1,
        polygonOffsetFactor: 1
      })),
      (this.selectedMater = this.solidMaterial.clone()),
      this.selectedMater.color.set(8947848),
      (this.params = {
        solidLine: !0,
        solidLineColor: '#c2d9ff',
        solidMesh: !0,
        solidMeshColor: '#324058',
        solidMeshOpacity: 0.607,
        railLine: !0,
        railLineColor: '#c2d9ff',
        railMesh: !0,
        railMeshColor: '#88aa88',
        railMeshOpacity: 0.607,
        doorLine: !0,
        doorLineColor: '#c2d9ff',
        doorPlane: !1,
        doorPlaneColor: '#0bcdfe',
        doorPlaneOpacity: 0.644,
        windowsLine: !0,
        windowsLineColor: '#c2d9ff',
        windowsPlane: !0,
        windowsPlaneColor: '#c2d9ff',
        windowsPlaneOpacity: 0.951,
        roomMesh: !1,
        roomMeshColor: '#141414',
        roomMeshOpacity: 0.1,
        safeexitMesh: !0,
        safeexitMeshColor: '#00ff00',
        safeexitMeshOpacity: 0.8,
        groundMesh: !0,
        groundMeshColor: '#268686',
        groundMeshOpacity: 0.226
      }),
      (this.redParams = {
        solidLine: !0,
        solidLineColor: '#ff0000',
        solidMesh: !0,
        solidMeshColor: '#ff0000',
        solidMeshOpacity: 0.607,
        doorLine: !0,
        doorLineColor: '#ff0000',
        doorPlane: !1,
        doorPlaneColor: '#ff0000',
        doorPlaneOpacity: 0.644,
        windowsLine: !0,
        windowsLineColor: '#ff0000',
        windowsPlane: !0,
        windowsPlaneColor: '#ff0000',
        windowsPlaneOpacity: 0.951,
        roomMesh: !1,
        roomMeshColor: '#ff0000',
        roomMeshOpacity: 0.226,
        safeexitMesh: !0,
        safeexitMeshColor: '#00ff00',
        safeexitMeshOpacity: 0.8
      }),
      this.setParams()
  }
  setParams() {
    if (this.setJson)
      for (let t in this.setJson)
        (this.params[t] = this.setJson[t]),
          t.endsWith('Color') || (this.redParams[t] = this.setJson[t])
  }
  getColorParams(t) {
    let e = {}
    for (let n in this.params) n.endsWith('Color') ? (e[n] = t) : (e[n] = this.params[n])
    return e
  }
  _setLineMaterial(t, e, n) {
    let i = t.getObjectByName(e)
    if (i && i.children.length > 0) {
      let t = i.children[0]
      n.visible
        ? (t.material.color.setStyle(n.color),
          (t.material.visible = !0),
          (t.material.depthWrite = !0))
        : (t.material.visible = !1)
    }
  }
  _setMeshMaterial(t, e, n) {
    let i = t.getObjectByName(e)
    if (i && i.children.length > 0) {
      let t = i.children[0]
      n.visible
        ? (t.material.color.setStyle(n.color),
          (t.material.opacity = n.opacity),
          (t.material.visible = !0),
          (t.material.polygonOffset = !0),
          (t.material.polygonOffsetUnits = 1),
          (t.material.polygonOffsetFactor = 1),
          (t.material.depthWrite = !0))
        : (t.material.visible = !1),
        ('group_solid_mesh' !== e && 'group_out_solid_mesh' !== e) ||
          t.userData.initMaterial ||
          (t.userData.initMaterial = t.material.clone())
    }
  }
  _setFloorMeshMaterial(t, e, n) {
    let i = t.getObjectByName(e)
    if (i && i.children.length > 0) {
      let t = i.children[0]
      n.visible
        ? (t.material.color.setStyle(n.color),
          t.material.emissive.setStyle(n.color),
          (t.material.opacity = n.opacity),
          (t.material.visible = !0),
          (t.material.polygonOffset = !0),
          (t.material.polygonOffsetUnits = 1),
          (t.material.polygonOffsetFactor = 1),
          (t.material.depthWrite = !0),
          t.translateY(-10))
        : (t.material.visible = !1)
    }
  }
  _setSolidMeshMaterial(t, e, n) {
    let i = t.getObjectByName(e)
    if (i && i.children.length > 0) {
      let t = i.children[0]
      ;(t.material = this.solidMaterial),
        n.visible
          ? (this.solidMaterial.color.setStyle(n.color),
            (this.solidMaterial.opacity = n.opacity),
            (this.solidMaterial.visible = !0),
            (this.solidMaterial.depthWrite = !0))
          : (t.material.visible = !1),
        ('group_solid_mesh' !== e && 'group_out_solid_mesh' !== e) ||
          t.userData.initMaterial ||
          (t.userData.initMaterial = t.material.clone())
    }
  }
  setFloorMaterial(t, e = this.params) {
    let n = { visible: e.solidLine, color: e.solidLineColor }
    this._setLineMaterial(t, 'group_solid_line', n),
      (n = { visible: e.solidMesh, color: e.solidMeshColor, opacity: e.solidMeshOpacity }),
      this._setMeshMaterial(t, 'group_solid_mesh', n),
      (n = { visible: e.railLine, color: e.railLineColor }),
      this._setLineMaterial(t, 'group_rail_line', n),
      (n = { visible: e.railMesh, color: e.railMeshColor, opacity: e.railMeshOpacity }),
      this._setMeshMaterial(t, 'group_rail_mesh', n),
      (n = { visible: e.doorLine, color: e.doorLineColor }),
      this._setLineMaterial(t, 'group_door_line', n),
      (n = { visible: e.doorPlane, color: e.doorPlaneColor, opacity: e.doorPlaneOpacity }),
      this._setMeshMaterial(t, 'group_door_mesh', n),
      (n = { visible: e.windowsLine, color: e.windowsLineColor }),
      this._setLineMaterial(t, 'group_windows_line', n),
      (n = { visible: e.windowsPlane, color: e.windowsPlaneColor, opacity: e.windowsPlaneOpacity }),
      this._setMeshMaterial(t, 'group_windows_mesh', n),
      (n = { visible: e.roomMesh, color: e.roomMeshColor, opacity: e.roomMeshOpacity }),
      this._setMeshMaterial(t, 'group_room', n),
      (n = { visible: e.groundMesh, color: e.groundMeshColor, opacity: e.groundMeshOpacity }),
      this._setFloorMeshMaterial(t, 'group_ground_mesh', n),
      (n = { visible: e.safeexitMesh, color: e.safeexitMeshColor, opacity: e.safeexitMeshOpacity }),
      this._setMeshMaterial(t, 'group_safeexit', n)
  }
  setOutMaterial(t, e = this.params) {
    let n
    ;(n = { visible: e.solidLine, color: e.solidLineColor }),
      this._setLineMaterial(t, 'group_out_solid_line', n),
      (n = { visible: e.solidMesh, color: e.solidMeshColor, opacity: e.solidMeshOpacity }),
      this._setSolidMeshMaterial(t, 'group_out_solid_mesh', n),
      (n = { visible: e.doorLine, color: e.doorLineColor }),
      this._setLineMaterial(t, 'group_out_door_line', n),
      (n = { visible: e.doorPlane, color: e.doorPlaneColor, opacity: e.doorPlaneOpacity }),
      this._setMeshMaterial(t, 'group_out_door_plane', n),
      (n = { visible: e.windowsLine, color: e.windowsLineColor }),
      this._setLineMaterial(t, 'group_out_windows_line', n),
      (n = { visible: e.windowsPlane, color: e.windowsPlaneColor, opacity: e.windowsPlaneOpacity }),
      this._setMeshMaterial(t, 'group_out_windows_plane', n)
  }
  setFloorColorMaterial(t, e) {
    let n = this.getColorParams(e)
    this.setFloorMaterial(t, n)
  }
  setOutColorMaterial(t, e) {
    let n = this.getColorParams(e)
    this.setOutMaterial(t, n)
  }
}
var bh,
  Mh = Object.freeze({
    Linear: Object.freeze({
      None: function (t) {
        return t
      },
      In: function (t) {
        return this.None(t)
      },
      Out: function (t) {
        return this.None(t)
      },
      InOut: function (t) {
        return this.None(t)
      }
    }),
    Quadratic: Object.freeze({
      In: function (t) {
        return t * t
      },
      Out: function (t) {
        return t * (2 - t)
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1)
      }
    }),
    Cubic: Object.freeze({
      In: function (t) {
        return t * t * t
      },
      Out: function (t) {
        return --t * t * t + 1
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2)
      }
    }),
    Quartic: Object.freeze({
      In: function (t) {
        return t * t * t * t
      },
      Out: function (t) {
        return 1 - --t * t * t * t
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2)
      }
    }),
    Quintic: Object.freeze({
      In: function (t) {
        return t * t * t * t * t
      },
      Out: function (t) {
        return --t * t * t * t * t + 1
      },
      InOut: function (t) {
        return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2)
      }
    }),
    Sinusoidal: Object.freeze({
      In: function (t) {
        return 1 - Math.sin(((1 - t) * Math.PI) / 2)
      },
      Out: function (t) {
        return Math.sin((t * Math.PI) / 2)
      },
      InOut: function (t) {
        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - t)))
      }
    }),
    Exponential: Object.freeze({
      In: function (t) {
        return 0 === t ? 0 : Math.pow(1024, t - 1)
      },
      Out: function (t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
      },
      InOut: function (t) {
        return 0 === t
          ? 0
          : 1 === t
            ? 1
            : (t *= 2) < 1
              ? 0.5 * Math.pow(1024, t - 1)
              : 0.5 * (2 - Math.pow(2, -10 * (t - 1)))
      }
    }),
    Circular: Object.freeze({
      In: function (t) {
        return 1 - Math.sqrt(1 - t * t)
      },
      Out: function (t) {
        return Math.sqrt(1 - --t * t)
      },
      InOut: function (t) {
        return (t *= 2) < 1
          ? -0.5 * (Math.sqrt(1 - t * t) - 1)
          : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
      }
    }),
    Elastic: Object.freeze({
      In: function (t) {
        return 0 === t
          ? 0
          : 1 === t
            ? 1
            : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
      },
      Out: function (t) {
        return 0 === t
          ? 0
          : 1 === t
            ? 1
            : Math.pow(2, -10 * t) * Math.sin(5 * (t - 0.1) * Math.PI) + 1
      },
      InOut: function (t) {
        return 0 === t
          ? 0
          : 1 === t
            ? 1
            : (t *= 2) < 1
              ? -0.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI)
              : 0.5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1
      }
    }),
    Back: Object.freeze({
      In: function (t) {
        var e = 1.70158
        return 1 === t ? 1 : t * t * ((e + 1) * t - e)
      },
      Out: function (t) {
        var e = 1.70158
        return 0 === t ? 0 : --t * t * ((e + 1) * t + e) + 1
      },
      InOut: function (t) {
        var e = 2.5949095
        return (t *= 2) < 1
          ? t * t * ((e + 1) * t - e) * 0.5
          : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
      }
    }),
    Bounce: Object.freeze({
      In: function (t) {
        return 1 - Mh.Bounce.Out(1 - t)
      },
      Out: function (t) {
        return t < 1 / 2.75
          ? 7.5625 * t * t
          : t < 2 / 2.75
            ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
            : t < 2.5 / 2.75
              ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
              : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
      },
      InOut: function (t) {
        return t < 0.5 ? 0.5 * Mh.Bounce.In(2 * t) : 0.5 * Mh.Bounce.Out(2 * t - 1) + 0.5
      }
    }),
    generatePow: function (t) {
      return (
        void 0 === t && (t = 4),
        (t = (t = t < Number.EPSILON ? Number.EPSILON : t) > 1e4 ? 1e4 : t),
        {
          In: function (e) {
            return Math.pow(e, t)
          },
          Out: function (e) {
            return 1 - Math.pow(1 - e, t)
          },
          InOut: function (e) {
            return e < 0.5 ? Math.pow(2 * e, t) / 2 : (1 - Math.pow(2 - 2 * e, t)) / 2 + 0.5
          }
        }
      )
    }
  }),
  Sh = function () {
    return performance.now()
  },
  Ah = (function () {
    function t() {
      ;(this._tweens = {}), (this._tweensAddedDuringUpdate = {})
    }
    return (
      (t.prototype.getAll = function () {
        var t = this
        return Object.keys(this._tweens).map(function (e) {
          return t._tweens[e]
        })
      }),
      (t.prototype.removeAll = function () {
        this._tweens = {}
      }),
      (t.prototype.add = function (t) {
        ;(this._tweens[t.getId()] = t), (this._tweensAddedDuringUpdate[t.getId()] = t)
      }),
      (t.prototype.remove = function (t) {
        delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()]
      }),
      (t.prototype.update = function (t, e) {
        void 0 === t && (t = Sh()), void 0 === e && (e = !1)
        var n = Object.keys(this._tweens)
        if (0 === n.length) return !1
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {}
          for (var i = 0; i < n.length; i++) {
            var s = this._tweens[n[i]],
              r = !e
            s && !1 === s.update(t, r) && !e && delete this._tweens[n[i]]
          }
          n = Object.keys(this._tweensAddedDuringUpdate)
        }
        return !0
      }),
      t
    )
  })(),
  Th = {
    Linear: function (t, e) {
      var n = t.length - 1,
        i = n * e,
        s = Math.floor(i),
        r = Th.Utils.Linear
      return e < 0
        ? r(t[0], t[1], i)
        : e > 1
          ? r(t[n], t[n - 1], n - i)
          : r(t[s], t[s + 1 > n ? n : s + 1], i - s)
    },
    Bezier: function (t, e) {
      for (var n = 0, i = t.length - 1, s = Math.pow, r = Th.Utils.Bernstein, o = 0; o <= i; o++)
        n += s(1 - e, i - o) * s(e, o) * t[o] * r(i, o)
      return n
    },
    CatmullRom: function (t, e) {
      var n = t.length - 1,
        i = n * e,
        s = Math.floor(i),
        r = Th.Utils.CatmullRom
      return t[0] === t[n]
        ? (e < 0 && (s = Math.floor((i = n * (1 + e)))),
          r(t[(s - 1 + n) % n], t[s], t[(s + 1) % n], t[(s + 2) % n], i - s))
        : e < 0
          ? t[0] - (r(t[0], t[0], t[1], t[1], -i) - t[0])
          : e > 1
            ? t[n] - (r(t[n], t[n], t[n - 1], t[n - 1], i - n) - t[n])
            : r(t[s ? s - 1 : 0], t[s], t[n < s + 1 ? n : s + 1], t[n < s + 2 ? n : s + 2], i - s)
    },
    Utils: {
      Linear: function (t, e, n) {
        return (e - t) * n + t
      },
      Bernstein: function (t, e) {
        var n = Th.Utils.Factorial
        return n(t) / n(e) / n(t - e)
      },
      Factorial:
        ((bh = [1]),
        function (t) {
          var e = 1
          if (bh[t]) return bh[t]
          for (var n = t; n > 1; n--) e *= n
          return (bh[t] = e), e
        }),
      CatmullRom: function (t, e, n, i, s) {
        var r = 0.5 * (n - t),
          o = 0.5 * (i - e),
          a = s * s
        return (2 * e - 2 * n + r + o) * (s * a) + (-3 * e + 3 * n - 2 * r - o) * a + r * s + e
      }
    }
  },
  Ih = (function () {
    function t() {}
    return (
      (t.nextId = function () {
        return t._nextId++
      }),
      (t._nextId = 0),
      t
    )
  })(),
  Rh = new Ah(),
  Lh = (function () {
    function t(t, e) {
      void 0 === e && (e = Rh),
        (this._object = t),
        (this._group = e),
        (this._isPaused = !1),
        (this._pauseStart = 0),
        (this._valuesStart = {}),
        (this._valuesEnd = {}),
        (this._valuesStartRepeat = {}),
        (this._duration = 1e3),
        (this._isDynamic = !1),
        (this._initialRepeat = 0),
        (this._repeat = 0),
        (this._yoyo = !1),
        (this._isPlaying = !1),
        (this._reversed = !1),
        (this._delayTime = 0),
        (this._startTime = 0),
        (this._easingFunction = Mh.Linear.None),
        (this._interpolationFunction = Th.Linear),
        (this._chainedTweens = []),
        (this._onStartCallbackFired = !1),
        (this._onEveryStartCallbackFired = !1),
        (this._id = Ih.nextId()),
        (this._isChainStopped = !1),
        (this._propertiesAreSetUp = !1),
        (this._goToEnd = !1)
    }
    return (
      (t.prototype.getId = function () {
        return this._id
      }),
      (t.prototype.isPlaying = function () {
        return this._isPlaying
      }),
      (t.prototype.isPaused = function () {
        return this._isPaused
      }),
      (t.prototype.to = function (t, e) {
        if ((void 0 === e && (e = 1e3), this._isPlaying))
          throw new Error(
            'Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.'
          )
        return (this._valuesEnd = t), (this._propertiesAreSetUp = !1), (this._duration = e), this
      }),
      (t.prototype.duration = function (t) {
        return void 0 === t && (t = 1e3), (this._duration = t), this
      }),
      (t.prototype.dynamic = function (t) {
        return void 0 === t && (t = !1), (this._isDynamic = t), this
      }),
      (t.prototype.start = function (t, e) {
        if ((void 0 === t && (t = Sh()), void 0 === e && (e = !1), this._isPlaying)) return this
        if (
          (this._group && this._group.add(this),
          (this._repeat = this._initialRepeat),
          this._reversed)
        )
          for (var n in ((this._reversed = !1), this._valuesStartRepeat))
            this._swapEndStartRepeatValues(n), (this._valuesStart[n] = this._valuesStartRepeat[n])
        if (
          ((this._isPlaying = !0),
          (this._isPaused = !1),
          (this._onStartCallbackFired = !1),
          (this._onEveryStartCallbackFired = !1),
          (this._isChainStopped = !1),
          (this._startTime = t),
          (this._startTime += this._delayTime),
          !this._propertiesAreSetUp || e)
        ) {
          if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
            var i = {}
            for (var s in this._valuesEnd) i[s] = this._valuesEnd[s]
            this._valuesEnd = i
          }
          this._setupProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            this._valuesStartRepeat,
            e
          )
        }
        return this
      }),
      (t.prototype.startFromCurrentValues = function (t) {
        return this.start(t, !0)
      }),
      (t.prototype._setupProperties = function (t, e, n, i, s) {
        for (var r in n) {
          var o = t[r],
            a = Array.isArray(o),
            l = a ? 'array' : typeof o,
            h = !a && Array.isArray(n[r])
          if ('undefined' !== l && 'function' !== l) {
            if (h) {
              if (0 === (m = n[r]).length) continue
              for (var c = [o], u = 0, d = m.length; u < d; u += 1) {
                var p = this._handleRelativeValue(o, m[u])
                if (isNaN(p)) {
                  ;(h = !1), console.warn('Found invalid interpolation list. Skipping.')
                  break
                }
                c.push(p)
              }
              h && (n[r] = c)
            }
            if (('object' !== l && !a) || !o || h)
              (void 0 === e[r] || s) && (e[r] = o),
                a || (e[r] *= 1),
                (i[r] = h ? n[r].slice().reverse() : e[r] || 0)
            else {
              e[r] = a ? [] : {}
              var g = o
              for (var f in g) e[r][f] = g[f]
              i[r] = a ? [] : {}
              var m = n[r]
              if (!this._isDynamic) {
                var y = {}
                for (var f in m) y[f] = m[f]
                n[r] = m = y
              }
              this._setupProperties(g, e[r], m, i[r], s)
            }
          }
        }
      }),
      (t.prototype.stop = function () {
        return (
          this._isChainStopped || ((this._isChainStopped = !0), this.stopChainedTweens()),
          this._isPlaying
            ? (this._group && this._group.remove(this),
              (this._isPlaying = !1),
              (this._isPaused = !1),
              this._onStopCallback && this._onStopCallback(this._object),
              this)
            : this
        )
      }),
      (t.prototype.end = function () {
        return (this._goToEnd = !0), this.update(1 / 0), this
      }),
      (t.prototype.pause = function (t) {
        return (
          void 0 === t && (t = Sh()),
          this._isPaused ||
            !this._isPlaying ||
            ((this._isPaused = !0),
            (this._pauseStart = t),
            this._group && this._group.remove(this)),
          this
        )
      }),
      (t.prototype.resume = function (t) {
        return (
          void 0 === t && (t = Sh()),
          this._isPaused && this._isPlaying
            ? ((this._isPaused = !1),
              (this._startTime += t - this._pauseStart),
              (this._pauseStart = 0),
              this._group && this._group.add(this),
              this)
            : this
        )
      }),
      (t.prototype.stopChainedTweens = function () {
        for (var t = 0, e = this._chainedTweens.length; t < e; t++) this._chainedTweens[t].stop()
        return this
      }),
      (t.prototype.group = function (t) {
        return void 0 === t && (t = Rh), (this._group = t), this
      }),
      (t.prototype.delay = function (t) {
        return void 0 === t && (t = 0), (this._delayTime = t), this
      }),
      (t.prototype.repeat = function (t) {
        return void 0 === t && (t = 0), (this._initialRepeat = t), (this._repeat = t), this
      }),
      (t.prototype.repeatDelay = function (t) {
        return (this._repeatDelayTime = t), this
      }),
      (t.prototype.yoyo = function (t) {
        return void 0 === t && (t = !1), (this._yoyo = t), this
      }),
      (t.prototype.easing = function (t) {
        return void 0 === t && (t = Mh.Linear.None), (this._easingFunction = t), this
      }),
      (t.prototype.interpolation = function (t) {
        return void 0 === t && (t = Th.Linear), (this._interpolationFunction = t), this
      }),
      (t.prototype.chain = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
        return (this._chainedTweens = t), this
      }),
      (t.prototype.onStart = function (t) {
        return (this._onStartCallback = t), this
      }),
      (t.prototype.onEveryStart = function (t) {
        return (this._onEveryStartCallback = t), this
      }),
      (t.prototype.onUpdate = function (t) {
        return (this._onUpdateCallback = t), this
      }),
      (t.prototype.onRepeat = function (t) {
        return (this._onRepeatCallback = t), this
      }),
      (t.prototype.onComplete = function (t) {
        return (this._onCompleteCallback = t), this
      }),
      (t.prototype.onStop = function (t) {
        return (this._onStopCallback = t), this
      }),
      (t.prototype.update = function (t, e) {
        if ((void 0 === t && (t = Sh()), void 0 === e && (e = !0), this._isPaused)) return !0
        var n,
          i,
          s = this._startTime + this._duration
        if (!this._goToEnd && !this._isPlaying) {
          if (t > s) return !1
          e && this.start(t, !0)
        }
        if (((this._goToEnd = !1), t < this._startTime)) return !0
        !1 === this._onStartCallbackFired &&
          (this._onStartCallback && this._onStartCallback(this._object),
          (this._onStartCallbackFired = !0)),
          !1 === this._onEveryStartCallbackFired &&
            (this._onEveryStartCallback && this._onEveryStartCallback(this._object),
            (this._onEveryStartCallbackFired = !0)),
          (i = (t - this._startTime) / this._duration),
          (i = 0 === this._duration || i > 1 ? 1 : i)
        var r = this._easingFunction(i)
        if (
          (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, r),
          this._onUpdateCallback && this._onUpdateCallback(this._object, i),
          1 === i)
        ) {
          if (this._repeat > 0) {
            for (n in (isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat))
              this._yoyo ||
                'string' != typeof this._valuesEnd[n] ||
                (this._valuesStartRepeat[n] =
                  this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])),
                this._yoyo && this._swapEndStartRepeatValues(n),
                (this._valuesStart[n] = this._valuesStartRepeat[n])
            return (
              this._yoyo && (this._reversed = !this._reversed),
              void 0 !== this._repeatDelayTime
                ? (this._startTime = t + this._repeatDelayTime)
                : (this._startTime = t + this._delayTime),
              this._onRepeatCallback && this._onRepeatCallback(this._object),
              (this._onEveryStartCallbackFired = !1),
              !0
            )
          }
          this._onCompleteCallback && this._onCompleteCallback(this._object)
          for (var o = 0, a = this._chainedTweens.length; o < a; o++)
            this._chainedTweens[o].start(this._startTime + this._duration, !1)
          return (this._isPlaying = !1), !1
        }
        return !0
      }),
      (t.prototype._updateProperties = function (t, e, n, i) {
        for (var s in n)
          if (void 0 !== e[s]) {
            var r = e[s] || 0,
              o = n[s],
              a = Array.isArray(t[s]),
              l = Array.isArray(o)
            !a && l
              ? (t[s] = this._interpolationFunction(o, i))
              : 'object' == typeof o && o
                ? this._updateProperties(t[s], r, o, i)
                : 'number' == typeof (o = this._handleRelativeValue(r, o)) &&
                  (t[s] = r + (o - r) * i)
          }
      }),
      (t.prototype._handleRelativeValue = function (t, e) {
        return 'string' != typeof e
          ? e
          : '+' === e.charAt(0) || '-' === e.charAt(0)
            ? t + parseFloat(e)
            : parseFloat(e)
      }),
      (t.prototype._swapEndStartRepeatValues = function (t) {
        var e = this._valuesStartRepeat[t],
          n = this._valuesEnd[t]
        ;(this._valuesStartRepeat[t] =
          'string' == typeof n ? this._valuesStartRepeat[t] + parseFloat(n) : this._valuesEnd[t]),
          (this._valuesEnd[t] = e)
      }),
      t
    )
  })()
Ih.nextId
var Ch = Rh
Ch.getAll.bind(Ch), Ch.removeAll.bind(Ch), Ch.add.bind(Ch), Ch.remove.bind(Ch), Ch.update.bind(Ch)
class Nh {
  constructor(t, e) {
    ;(this.rootApp = t),
      (this.builidingApp = e),
      (this.group = e.buildingGroup),
      (this.allFloorDic = {}),
      (this.floorkeys = null),
      (this.floornum = 0),
      (this.oldFloorNum = 0),
      (this.openDistanc = 1e4),
      (this.openTime = 1e3),
      (this.cameraFloorTime = 1e3),
      (this.cameraResetTime = 500),
      (this.openFlag = !1),
      (this.flagRun = !1),
      (this.flagAnimate = !1),
      (this.groupUp = new Is()),
      (this.groupDw = new Is()),
      (this.curFloorModel = null),
      (this.tweenGroupFloor = new Ah()),
      this.rootApp.addEventListener('onAnimate', (t) => {
        this.floorAnimate(t.delta)
      }),
      this.rootApp.addEventListener('showAllBuilding', (t) => {
        this.floorOpen(0)
      })
  }
  floorAnimate(t) {
    this.flagAnimate &&
      this.rootApp.curBuildingApp === this.builidingApp &&
      this.tweenGroupFloor.update()
  }
  floorOpen(t) {
    ;(-1 === this.floorkeys.indexOf(t) && 0 !== t) ||
      ((0 !== t || this.openFlag) &&
        (this.flagRun ||
          ((this.flagRun = !0),
          (this.oldFloorNum = this.floornum),
          (this.floornum = t),
          this.openFlag
            ? 0 === t
              ? this._tweenAnimateClose(t)
              : this._tweenAnimateSwitch(t)
            : this._tweenAnimateOpen(t))))
  }
  _onPreFloorOpen(t) {
    ;(this.curFloorModel = this.builidingApp.floorApp.floorGltfs[t]),
      (this.curFloorModel.userData.initPosition = this.curFloorModel.position.clone())
    let e = this.floorkeys.indexOf(t)
    if (-1 === e) return
    let n = this.floorkeys.slice(0, e),
      i = this.floorkeys.slice(e + 1)
    for (let t in n) {
      let e = n[t]
      this.groupDw.add(this.allFloorDic[e])
    }
    for (let t in i) {
      let e = i[t]
      this.groupUp.add(this.allFloorDic[e])
    }
    this.group.add(this.groupUp),
      this.group.add(this.groupDw),
      this.builidingApp.camerFloorPosition
        ? (this.curFloorModel.userData.floorCameraPosition = this.builidingApp.camerFloorPosition)
        : (this.curFloorModel.userData.floorCameraPosition = { x: 0, y: 1, z: 0 }),
      this.builidingApp.floorApp.createFloorModel(this.oldFloorNum, this.floornum),
      (this.flagAnimate = !0),
      (this.flagRun = !0)
  }
  _onPostFloorOpen() {
    ;(this.flagAnimate = !1),
      (this.openFlag = !0),
      (this.flagRun = !1),
      (this.groupDw.visible = !1),
      (this.groupUp.visible = !1),
      this.rootApp.curBuildingApp === this.builidingApp &&
        setTimeout(() => {
          this.rootApp.dispatchEvent({
            type: 'onPostFloorOpen',
            floor: this.floornum,
            buildingName: this.builidingApp.name
          })
        }, 10)
  }
  _onPostFloorClose() {
    for (
      this.flagAnimate = !1, this.group.remove(this.groupDw), this.group.remove(this.groupUp);
      this.groupUp.children.length > 0;

    )
      this.group.add(this.groupUp.children[0])
    for (; this.groupDw.children.length > 0; ) this.group.add(this.groupDw.children[0])
    ;(this.openFlag = !1),
      (this.flagRun = !1),
      this.builidingApp.floorApp.createFloorModel(this.oldFloorNum, this.floornum),
      this.rootApp.curBuildingApp === this.builidingApp &&
        this.rootApp.dispatchEvent({
          type: 'onPostFloorClose',
          floor: this.floornum,
          buildingName: this.builidingApp.name
        })
  }
  _onPreFloorClose() {
    this.openFlag &&
      (this.rootApp.curBuildingApp === this.builidingApp &&
        this.rootApp.dispatchEvent({
          type: 'onPreFloorClose',
          oldFloorNum: this.oldFloorNum,
          buildingName: this.builidingApp.name
        }),
      (this.flagAnimate = !0))
  }
  _tweenAnimateOpen(t) {
    this._onPreFloorOpen(t)
    let e = this.builidingApp.camerPosition,
      n = new Lh(this.rootApp.camera.position, this.tweenGroupFloor).to(e, this.cameraResetTime),
      i = new Lh(this.groupUp.position, this.tweenGroupFloor).to(
        { y: '+' + this.openDistanc },
        this.openTime
      ),
      s = new Lh(this.groupDw.position, this.tweenGroupFloor).to(
        { y: '-' + this.openDistanc },
        this.openTime
      ),
      r = new Lh(this, this.tweenGroupFloor).to({}, this.openTime).onComplete(() => {
        ;(this.groupDw.visible = !1), (this.groupUp.visible = !1)
      }),
      o = this.curFloorModel.worldToLocal(new H(0, 0, 0))
    console.log('=====this.curFloorModel.position======', this.curFloorModel.position.clone(), o)
    let a = new Lh(this.rootApp.camera.position, this.tweenGroupFloor).to(
        this.curFloorModel.userData.floorCameraPosition,
        this.cameraFloorTime
      ),
      l = new Lh(this.curFloorModel.position, this.tweenGroupFloor).to(
        { y: 3800, x: 0, z: 0 },
        this.cameraFloorTime
      ),
      h = new Lh(this, this.tweenGroupFloor).to({}, this.cameraFloorTime).onComplete(() => {
        this._onPostFloorOpen()
      })
    parseInt(t) > 0 ? r.chain(a, h) : r.chain(a, l, h), n.chain(i, s, r), n.start()
  }
  _tweenAnimateClose(t) {
    this._onPreFloorClose()
    let e = { x: yh.camera.x, y: yh.camera.y, z: yh.camera.z }
    new Lh(this.rootApp.camera.position, this.tweenGroupFloor).to(e, this.cameraResetTime).start()
    let n = new Lh(this.curFloorModel.position, this.tweenGroupFloor)
        .to(this.curFloorModel.userData.initPosition, this.cameraResetTime)
        .onComplete(() => {
          ;(this.groupDw.visible = !0), (this.groupUp.visible = !0)
        }),
      i = new Lh(this.groupUp.position, this.tweenGroupFloor).to(
        { y: '-' + this.openDistanc },
        this.openTime
      ),
      s = new Lh(this.groupDw.position, this.tweenGroupFloor).to(
        { y: '+' + this.openDistanc },
        this.openTime
      ),
      r = new Lh(this, this.tweenGroupFloor).to({}, this.openTime).onComplete(() => {
        this._onPostFloorClose()
      })
    n.chain(i, s, r), n.start()
  }
  _tweenAnimateSwitch(t) {
    this._onPreFloorClose()
    let e = { x: yh.camera.x, y: yh.camera.y, z: yh.camera.z }
    new Lh(this.rootApp.camera.position, this.tweenGroupFloor).to(e, this.cameraResetTime).start()
    let n = new Lh(this.curFloorModel.position, this.tweenGroupFloor)
        .to(this.curFloorModel.userData.initPosition, this.cameraResetTime)
        .onComplete(() => {
          ;(this.groupDw.visible = !0), (this.groupUp.visible = !0)
        }),
      i = new Lh(this.groupUp.position, this.tweenGroupFloor).to(
        { y: '-' + this.openDistanc },
        this.openTime
      ),
      s = new Lh(this.groupDw.position, this.tweenGroupFloor).to(
        { y: '+' + this.openDistanc },
        this.openTime
      ),
      r = new Lh(this, this.tweenGroupFloor).to({}, this.openTime + 200).onComplete(() => {
        this._onPostFloorClose(), this._onPreFloorOpen(t)
        let e = new Lh(this.groupUp.position, this.tweenGroupFloor).to(
            { y: '+' + this.openDistanc },
            this.openTime
          ),
          n = new Lh(this.groupDw.position, this.tweenGroupFloor).to(
            { y: '-' + this.openDistanc },
            this.openTime
          ),
          i = new Lh(this, this.tweenGroupFloor).to({}, this.openTime).onComplete(() => {
            ;(this.groupDw.visible = !1), (this.groupUp.visible = !1)
          }),
          s = new Lh(this.rootApp.camera.position, this.tweenGroupFloor)
            .to(this.curFloorModel.userData.floorCameraPosition, this.cameraFloorTime)
            .dynamic(!0),
          r = new Lh(this.curFloorModel.position, this.tweenGroupFloor)
            .to({ y: 3800 }, this.cameraFloorTime)
            .dynamic(!0),
          o = new Lh(this, this.tweenGroupFloor).to({}, this.cameraFloorTime).onComplete(() => {
            this._onPostFloorOpen()
          })
        i.chain(s, r, o), e.start(), n.start(), i.start()
      })
    n.chain(i, s, r), n.start()
  }
}
class Ph {
  constructor(t, e) {
    ;(this.rootApp = t),
      (this.wholeApp = e),
      (this.loader = t.loader),
      (this.buildingGroup = new Is()),
      (this.floorAnimationApp = new Nh(t, this)),
      (this.floorApp = new wh(this.rootApp, this)),
      (this.name = null),
      (this.buildingId = null),
      this._init(),
      (this.pointer = new _()),
      (this.showOut = null),
      (this.isSandbox = null),
      (this.sandBoxApp = null),
      (this.displayEffect = null),
      (this.allFloorDic = null),
      (this.buildingTip = ''),
      (this.showBuildingTip = !1),
      (this.tip = null),
      (this.tmpSelectedFloor = null),
      (this.camerPosition = null),
      (this.camerFloorPosition = null)
  }
  async createBuildModel(t, e) {
    let n = {},
      i = []
    ;(this.showOut = t.showOut), (this.floorApp.showOut = t.showOut)
    let s,
      r = t.modelUrls
    if (
      ((this.name = t.buildingName),
      (this.buildingId = t.buildingId),
      t.buildingCamerPosition && (this.camerPosition = t.buildingCamerPosition),
      t.buildingFloorCamerPosition && (this.camerFloorPosition = t.buildingFloorCamerPosition),
      t.displayEffect.renderOrder && (this.buildingGroup.renderOrder = t.displayEffect.renderOrder),
      void 0 !== t.buildingTip && (this.buildingTip = t.buildingTip),
      void 0 !== t.buildingTip && (this.showBuildingTip = t.showBuildingTip),
      (this.displayEffect = new Eh(this.rootApp, t.displayEffect, this.name)),
      this.showOut)
    ) {
      s = await this._getAsyncDataOut(r, e)
      let t = await this._getAsyncDataFloor(r, e)
      this.floorApp.setGltf(t)
    } else s = await this._getAsyncDataFloor(r, e)
    s = s.sort((t, e) => t.floor - e.floor)
    let o = 0
    for (let t = 0; t < s.length; t++) {
      let e = s[t].floor,
        r = s[t].model
      ;(r.floor = e), i.push(e), (n[e] = r), r.translateY(o)
      let a = r.userData.wallHeigth
      ;(o += a || 3e3), this.buildingGroup.add(r)
    }
    let a = e.buildingDevUrl
    if (a) {
      let t = await this.floorApp.devApp.getDevGroup(a)
      ;(t.visible = !0), this.buildingGroup.add(t)
    }
    ;(this.tip = this.createBuildingTip(this.buildingTip)),
      this.tip &&
        ((this.tip.name = 'buildingTip_' + this.name),
        this.tip.translateY(o + 7e3),
        (this.tip.visible = this.showBuildingTip),
        this.buildingGroup.add(this.tip)),
      this.wholeApp.wholeGroup.add(this.buildingGroup)
    let l = t.buildingSet.scale,
      h = t.buildingSet
    return (
      this.buildingGroup.scale.set(l, l, l),
      this.buildingGroup.translateX(parseInt(h.px)),
      this.buildingGroup.translateY(parseInt(h.py)),
      this.buildingGroup.translateZ(parseInt(h.pz)),
      this.buildingGroup.rotateY(h.ry),
      (this.buildingGroup.name = t.buildingName),
      (this.buildingGroup.objtype = 'builingGroup'),
      (this.buildingGroup.isSandbox = t.isSandbox),
      (this.floorAnimationApp.floorkeys = i),
      (this.floorAnimationApp.allFloorDic = n),
      (this.allFloorDic = n),
      this
    )
  }
  async _getAsyncDataOut(t, e) {
    let n = []
    for (let t of e.floors) {
      let e = t.outgltf
      e.traverse((t) => {
        t.frustumCulled = !1
      })
      let i = {}
      ;(i.floor = parseInt(t.floor)),
        (i.floorName = t.floorName),
        (i.model = e),
        this.displayEffect.setOutMaterial(e)
      let s = this.createBuildingTip(i.floorName)
      ;(s.name = 'floorTip_' + i.floor), (s.visible = !1), e.add(s), n.push(i)
    }
    return n
  }
  async _getAsyncDataFloor(t, e) {
    let n = []
    for (let t of e.floors) {
      let e = t.gltf
      e.traverse((t) => {
        t.frustumCulled = !1
      })
      let i = {}
      ;(i.floor = parseInt(t.floor)),
        (i.floorName = t.floorName),
        (i.model = e),
        (this.floorApp.floorGltfs[parseInt(t.floor)] = e)
      let s = t.devjson,
        r = await this.floorApp.devApp.getDevGroup(s)
      e.add(r),
        r.position.set(0, 0, 0),
        (r.name = 'group_dev'),
        this.displayEffect.setFloorMaterial(e)
      let o = t.roomjson
      void 0 !== o && (await this.floorApp.roomApp.getRoomName(o, e))
      let a = this.createBuildingTip(i.floorName)
      ;(a.name = 'floorTip_' + i.floor), (a.visible = !1), e.add(a), n.push(i)
    }
    return n
  }
  _init() {
    this.rootApp.addEventListener('onPostFloorOpen', (t) => {
      this.closeSelectedFloor()
    }),
      this.rootApp.renderer.domElement.addEventListener('dblclick', (t) => {
        if (
          !yh.isMobile &&
          (this.tmpSelectedFloor &&
            (this.tmpSelectedFloor.material = this.tmpSelectedFloor.userData.initMaterial),
          'floor' === this.rootApp.eventApp.curEvent)
        ) {
          const e = this.rootApp.renderer.domElement.getBoundingClientRect()
          ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
            (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
            this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
          let n = this.buildingGroup
          const i = this.rootApp.raycaster.intersectObjects(n.children, !0)
          if (i.length > 0) {
            i[0].object.traverseAncestors((t) => {
              t.floor &&
                (t.parent.isSandbox ||
                  (this.floorAnimationApp.floorOpen(t.floor), this.closeSelectedFloor()))
            })
          }
        }
      }),
      this.rootApp.renderer.domElement.addEventListener('pointermove', (t) => {
        if (
          !yh.isMobile &&
          'floor' === this.rootApp.eventApp.curEvent &&
          !this.floorAnimationApp.flagRun
        ) {
          const e = this.rootApp.renderer.domElement.getBoundingClientRect()
          ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
            (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
            this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
          let n = this.buildingGroup
          const i = this.rootApp.raycaster.intersectObjects(n.children, !0)
          if (i.length > 0) {
            i[0].object.traverseAncestors((t) => {
              if (t.floor && !t.parent.isSandbox) {
                let e = (
                  t.getObjectByName('group_out_solid_mesh') || t.getObjectByName('group_solid_mesh')
                ).children[0]
                if (this.tmpSelectedFloor === e) return
                this.closeSelectedFloor(),
                  (this.tmpSelectedFloor = e),
                  (e.material = this.displayEffect.selectedMater),
                  (t.getObjectByName('floorTip_' + t.floor).visible = !0)
              }
            })
          } else this.closeSelectedFloor()
        }
      })
  }
  closeSelectedFloor() {
    this.tmpSelectedFloor &&
      (this.tmpSelectedFloor.material = this.tmpSelectedFloor.userData.initMaterial),
      this.buildingGroup.traverse((t) => {
        t && t.name && t.name.startsWith('floorTip_') && (t.visible = !1)
      })
  }
  setfloorTipScale() {
    const t = new Y().setFromObject(this.buildingGroup),
      e = new H()
    t.getSize(e)
    let n = Math.max(e.x, e.y, e.z),
      i = new H(n, n, 1)
    this.buildingGroup.traverse((t) => {
      t && t.name && t.name.startsWith('floorTip_') && t.scale.multiply(i)
    })
  }
  createBuildingTip(t) {
    let e = t.length
    if (e < 1) return void console.log('tip is null')
    const n = document.createElement('canvas')
    let i = n.getContext('2d')
    ;(n.width = 48 + 26 * e), (n.height = 68)
    let s = n.height / 2
    i.beginPath(),
      i.moveTo(s, 0),
      i.lineTo(n.width - s, 0),
      i.arcTo(n.width, 0, n.width, s, s),
      i.lineTo(n.width, n.height - s),
      i.arcTo(n.width, n.height, n.width - s, n.height, s),
      i.lineTo(s, n.height),
      i.arcTo(0, n.height, 0, n.height - s, s),
      i.lineTo(0, s),
      i.arcTo(0, 0, s, 0, s),
      i.closePath(),
      (i.fillStyle = 'rgba(255,255,255,1)'),
      i.fill(),
      i.translate(4, 4)
    let r = 40 + 26 * e,
      o = 60
    ;(s = 30),
      i.beginPath(),
      i.moveTo(s, 0),
      i.lineTo(r - s, 0),
      i.arcTo(r, 0, r, s, s),
      i.lineTo(r, o - s),
      i.arcTo(r, o, r - s, o, s),
      i.lineTo(s, o),
      i.arcTo(0, o, 0, o - s, s),
      i.lineTo(0, s),
      i.arcTo(0, 0, s, 0, s),
      i.closePath(),
      (i.fillStyle = 'rgba(0,0,64,1)'),
      i.fill(),
      (i.font = '26px "Microsoft Yahei","",Tahoma,Arial'),
      (i.fillStyle = 'white'),
      (i.textAlign = 'center'),
      (i.textBaseline = 'middle'),
      i.fillText(t, n.width / 2, n.height / 2)
    let a = new Or(n),
      l = new Bs({ map: a, sizeAttenuation: !1, depthTest: !1 })
    const h = new $s(l)
    return h.scale.set((0.03 * n.width) / n.height, 0.03, 1), (h.renderOrder = 10), h
  }
}
async function Dh(t) {
  let e = await fetch(t),
    n = await e.text()
  return JSON.parse(n)
}
class Oh {
  constructor(t) {
    ;(this.rootApp = t),
      (this.buildingApps = []),
      (this.wholeGroup = new Is()),
      (this.visibleGroup = new Is()),
      (this.curBuildingApp = null),
      (this.pointer = new _()),
      (this.devGltfs = {}),
      (this.textureDic = {}),
      (this.loader = t.loader),
      (this.flagAnimateIng = !1),
      (this.tweenGroupFloor = new Ah()),
      this._init()
  }
  async createWhole(t) {
    this.textureDic = await (async function (t) {
      const e = new ma()
      let n = [],
        i = {}
      t.textures && (i = t.textures),
        i.ground ||
          (yh.isMobile
            ? (i.ground =
                'https://timcloud.oss-cn-shanghai.aliyuncs.com/3dmodel/texture/ground.jpg')
            : (i.ground =
                'https://timcloud.oss-cn-shanghai.aliyuncs.com/3dmodel/texture/ground_app.jpg')),
        i.elecLine ||
          (i.elecLine =
            'https://timcloud.oss-cn-shanghai.aliyuncs.com/3dmodel/texture/elecLine.jpg'),
        i.sphereBack ||
          (i.sphereBack =
            'https://timcloud.oss-cn-shanghai.aliyuncs.com/3dmodel/texture/sphereBack.jpg'),
        n.push(e.loadAsync(i.ground)),
        n.push(e.loadAsync(i.elecLine)),
        n.push(e.loadAsync(i.sphereBack))
      let s = await Promise.all(n),
        r = {}
      return (
        (r.ground = s[0]),
        (r.elecLine = s[1]),
        (r.sphereBack = s[2]),
        (r.ground.name = 'texture_ground'),
        (r.elecLine.name = 'texture_elecLine'),
        (r.sphereBack.name = 'texture_sphereBack'),
        console.log('textureDic==', r),
        r
      )
    })(t)
    let e = await (async function (t) {
      let e = new gl(),
        n = t.devUrlPrefix,
        i = t.roomUrlPrefix,
        s = t.modelUrlPrefix,
        r = [],
        o = [],
        a = [],
        l = []
      for (let h of t.buildings) {
        let t = [],
          c = [],
          u = [],
          d = [],
          p = [],
          g = []
        o.push(h.buildingName)
        for (let r of h.modelUrls) {
          t.push(r.floor),
            c.push(r.floorName ? r.floorName : r.floor + 'F'),
            d.push(Dh(n + r.devUrl)),
            p.push(Dh(i + r.roomUrl))
          let o = Math.floor(1e4 * Math.random())
          u.push(e.loadAsync(s + r.floorUrl + '?rnd=' + o)),
            h.showOut && g.push(e.loadAsync(s + r.outUrl + '?rnd=' + o))
        }
        a.push(t), l.push(c)
        let f = h.buildingDevUrl
        f = f ? [Dh(n + f)] : []
        let m = [Promise.all(d), Promise.all(p), Promise.all(u), Promise.all(g), Promise.all(f)]
        r.push(m)
      }
      let h = await Promise.all(r),
        c = {}
      for (let t in o) {
        let e = o[t],
          n = await h[t][0],
          i = await h[t][1],
          s = await h[t][2],
          r = await h[t][3],
          u = await h[t][4],
          d = a[t],
          p = l[t],
          g = [],
          f = {}
        for (let t in d) {
          let e = {}
          ;(e.devjson = n[t]),
            (e.roomjson = i[t]),
            (e.floor = d[t]),
            (e.floorName = p[t]),
            (e.gltf = s[t].scenes[0].children[0]),
            r.length > 0 && (e.outgltf = r[t].scenes[0].children[0]),
            g.push(e)
        }
        ;(f.floors = g), u.length > 0 && (f.buildingDevUrl = u[0]), (c[e] = f)
      }
      return console.log(c), c
    })(t)
    console.log('==allDataJson==', e)
    let n = []
    for (let i of t.buildings) {
      let t = new Ph(this.rootApp, this),
        s = e[i.buildingName]
      n.push(t.createBuildModel(i, s))
    }
    return (
      (this.buildingApps = await Promise.all(n)),
      1 === this.buildingApps.length &&
        ((this.curBuildingApp = this.buildingApps[0]),
        (this.rootApp.curBuildingApp = this.curBuildingApp),
        (this.curBuildingApp.camerPosition = { x: yh.camera.x, y: yh.camera.y, z: yh.camera.z }),
        this.rootApp.dispatchEvent({
          type: 'showOneBuilding',
          name: this.curBuildingApp.name,
          buildingId: this.curBuildingApp.buildingId
        })),
      (this.wholeGroup.name = 'wholeGroup'),
      this.wholeGroup
    )
  }
  _getBuildingAppByname(t) {
    for (let e of this.buildingApps) if (e.name === t) return e
  }
  _getSelectBuilding(t) {
    ;(this.curBuildingApp = this._getBuildingAppByname(t)),
      (this.rootApp.curBuildingApp = this.curBuildingApp)
    let e = []
    for (let n of this.wholeGroup.children) n.name !== t && e.push(n)
    for (let t of e) this.visibleGroup.add(t)
    return this.curBuildingApp.buildingGroup
  }
  showAllBuilding() {
    this.flagAnimateIng
      ? console.log('  Animate is run........')
      : ((this.flagAnimateIng = !0),
        this.rootApp.curBuildingApp.floorAnimationApp.openFlag &&
          this.rootApp.curBuildingApp.floorAnimationApp.floorOpen(0),
        this._startTweenShowAllBuilding())
  }
  showOneBuilding(t) {
    if ((console.log('=====showOneBuilding====', t), this.flagAnimateIng))
      console.log('  Animate is run........')
    else if (this.rootApp.curBuildingApp && t === this.rootApp.curBuildingApp.name)
      console.log('  this is curBuilding........')
    else if (this.rootApp.curBuildingApp)
      this.rootApp.curBuildingApp.floorAnimationApp.floorOpen(0),
        (this.flagAnimateIng = !0),
        this._startTweenSwitchShowOneBuilding(t)
    else {
      let e = this._getSelectBuilding(t)
      ;(this.flagAnimateIng = !0),
        (e.userData.initPosition = e.position.clone()),
        this._startTweenShowOneBuilding(e)
    }
  }
  _startTweenShowAllBuilding() {
    if (this.flagAnimateIng) {
      let t = { x: yh.camera.x, y: yh.camera.y, z: yh.camera.z }
      new Lh(this.rootApp.camera.position, this.tweenGroupFloor)
        .to(t, 1500)
        .onComplete(() => {
          for (; this.visibleGroup.children.length > 0; )
            this.wholeGroup.add(this.visibleGroup.children[0])
          ;(this.curBuildingApp = null),
            (this.rootApp.curBuildingApp = null),
            (this.flagAnimateIng = !1),
            this.rootApp.dispatchEvent({ type: 'showAllBuilding' })
        })
        .start()
    }
  }
  _startTweenShowOneBuilding(t) {
    if (this.flagAnimateIng) {
      let e = new H()
      t.localToWorld(e), console.log('centerWorld=======', e), this.rootApp.controls.target.copy(e)
      let n = {}
      if (this.curBuildingApp.camerPosition) n = this.curBuildingApp.camerPosition
      else {
        const e = new Y().setFromObject(t),
          i = new H()
        e.getSize(i)
        let s = 1.5
        ;(n = { x: i.x * s, y: i.y * s * 2, z: i.z * s }),
          (this.curBuildingApp.camerPosition = { x: i.x * s, y: i.y * s, z: i.z * s })
      }
      console.log('camerPosition======', n),
        new Lh(this.rootApp.camera.position, this.tweenGroupFloor)
          .to(n, 1e3)
          .onComplete(() => {
            ;(this.flagAnimateIng = !1),
              this.rootApp.dispatchEvent({
                type: 'showOneBuilding',
                name: this.curBuildingApp.name,
                buildingId: this.curBuildingApp.buildingId
              })
          })
          .start()
    }
  }
  _startTweenSwitchShowOneBuilding(t) {
    if (this.flagAnimateIng) {
      let e = { x: yh.camera.x, y: yh.camera.y, z: yh.camera.z }
      new Lh(this.wholeGroup.position, this.tweenGroupFloor)
        .to(this.wholeGroup.userData.initPosition, 1e3)
        .start(),
        new Lh(this.rootApp.camera.position, this.tweenGroupFloor)
          .to(e, 1e3)
          .onComplete(() => {
            for (; this.visibleGroup.children.length > 0; )
              this.wholeGroup.add(this.visibleGroup.children[0])
            ;(this.curBuildingApp = null),
              (this.rootApp.curBuildingApp = null),
              (this.flagAnimateIng = !1),
              this.rootApp.dispatchEvent({ type: 'showAllBuilding' }),
              setTimeout(() => {
                let e = this._getSelectBuilding(t)
                ;(this.flagAnimateIng = !0),
                  (e.userData.initPosition = e.position.clone()),
                  this._startTweenShowOneBuilding(e)
              }, 300)
          })
          .start()
    }
  }
  closeOneBuildingTip(t) {
    let e = this._getBuildingAppByname(t)
    e.tip && (e.tip.visible = !1)
  }
  showOneBuildingTip(t) {
    console.log('=====showOneBuildingTip====', t)
    let e = this._getBuildingAppByname(t)
    e.tip && (e.tip.visible = !0)
  }
  showAllBuildingTip() {
    for (let t of this.buildingApps) t.tip && (t.tip.visible = !0)
  }
  closeAllBuildingTip() {
    for (let t of this.buildingApps) t.tip && (t.tip.visible = !1)
  }
  _init() {
    this.rootApp.renderer.domElement.addEventListener('dblclick', (t) => {
      if (!yh.isMobile && 'building' === this.rootApp.eventApp.curEvent) {
        const e = this.rootApp.renderer.domElement.getBoundingClientRect()
        ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
          (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
          this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
        let n = this.wholeGroup
        const i = this.rootApp.raycaster.intersectObjects(n.children, !0)
        if (i.length > 0) {
          i[0].object.traverseAncestors((t) => {
            'builingGroup' === t.objtype && (t.isSandbox || this.showOneBuilding(t.name))
          })
        }
      }
    }),
      this.rootApp.addEventListener('showAllBuilding', () => {
        this.showAllBuildingTip()
        for (let t of this.buildingApps) t.closeSelectedFloor()
      }),
      this.rootApp.addEventListener('showOneBuilding', () => {
        this.closeAllBuildingTip()
      }),
      this.rootApp.addEventListener('onAnimate', (t) => {
        this.flagAnimateIng && this.tweenGroupFloor.update()
      })
  }
  setALlFloorColorMaterial(t, e) {
    let n = this._getBuildingAppByname(t),
      i = n.displayEffect
    for (let t in n.allFloorDic) {
      let s = n.allFloorDic[t]
      n.showOut ? i.setOutColorMaterial(s, e) : i.setFloorColorMaterial(s, e)
    }
  }
  setFloorColorMaterial(t, e, n) {
    let i = this._getBuildingAppByname(t),
      s = i.displayEffect,
      r = i.allFloorDic[e]
    i.showOut ? s.setOutColorMaterial(r, n) : s.setFloorColorMaterial(r, n)
  }
  resetFloorMaterial(t, e) {
    let n = this._getBuildingAppByname(t),
      i = n.displayEffect,
      s = n.allFloorDic[e]
    n.showOut ? i.setOutMaterial(s) : i.setFloorMaterial(s)
  }
  resetAllFloorMaterial(t) {
    let e = this._getBuildingAppByname(t),
      n = e.displayEffect
    for (let t in e.allFloorDic) {
      let i = e.allFloorDic[t]
      e.showOut ? n.setOutMaterial(i) : n.setFloorMaterial(i)
    }
  }
  setfloorTipScale() {
    console.log('=====ddddd=======', this.rootApp.scaleWhole)
    let t = 1.5 * this.rootApp.scaleWhole,
      e = new H(1 / t, 1 / t, 1)
    this.wholeGroup.traverse((t) => {
      t &&
        t.name &&
        (t.name.startsWith('floorTip_') || t.name.startsWith('buildingTip_')) &&
        t.scale.multiply(e)
    })
  }
  home() {
    'park' === this.rootApp.eventApp.getCurScenes() && this.rootApp.controls.reset(),
      'building' === this.rootApp.eventApp.getCurScenes() &&
        (this.buildingApps.length > 1
          ? (this.curBuildingApp.tmpSelectedFloor &&
              (this.curBuildingApp.tmpSelectedFloor.material =
                this.curBuildingApp.tmpSelectedFloor.userData.initMaterial),
            this.showAllBuilding())
          : this.rootApp.controls.reset()),
      'floor' === this.rootApp.eventApp.getCurScenes() &&
        (this.buildingApps.length > 1
          ? (this.curBuildingApp.tmpSelectedFloor &&
              (this.curBuildingApp.tmpSelectedFloor.material =
                this.curBuildingApp.tmpSelectedFloor.userData.initMaterial),
            this.showAllBuilding())
          : this.curBuildingApp && this.curBuildingApp.floorAnimationApp.floorOpen(0))
  }
}
class Fh {
  constructor(t) {
    ;(this.rootApp = t),
      (this.size = 0),
      (this.flag = 0),
      (this.glowDevs = []),
      (this.materails = {}),
      (this.timeCount = 0),
      (this.tmpTimeCount = 0),
      (this.speed = 0.1),
      (this.textureLoader = new ma())
    ;(this.texture = this.textureLoader.load(
      'data:image/png;base64,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'
    )),
      (this.geometry = new xe()),
      this.geometry.setAttribute('position', new ce([0, 0, 0], 3)),
      this.rootApp.addEventListener('onAnimate', (t) => {
        this.devGlowAnimation(t.delta)
      })
  }
  getMaterail(t) {
    let e = this.materails[t]
    return (
      e ||
      ((e = new Ir({ size: 0, map: this.texture, blending: 2, depthTest: !1, transparent: !0 })),
      e.color.set(t),
      (this.materails[t] = e),
      e)
    )
  }
  devGlowAnimation(t) {
    this.tmpTimeCount = this.tmpTimeCount + t
    let e = this.rootApp.scaleWhole
    if (((e *= 3), this.tmpTimeCount > this.speed)) {
      ;(this.tmpTimeCount = 0),
        0 === this.flag ? (this.size = this.size + 2e3 * e) : (this.size = this.size - 2e3 * e),
        this.size > 1e4 * e && (this.flag = 1),
        this.size <= 1 * e && (this.flag = 0)
      for (let t of this.glowDevs) t.material.size = this.size
    }
  }
  addGlowDev(t, e) {
    'string' == typeof t && (t = [t])
    for (let n of t) {
      let t = this.rootApp.scene.getObjectByName(n)
      if (!t) {
        console.log('addGlowDev   dev   null ===', n)
        continue
      }
      let i = this.getMaterail(e),
        s = this.getGlowDev(t.name)
      if (s) s.material = i
      else {
        const n = new Pr(this.geometry, i)
        ;(n.name = 'Glow_' + t.name),
          (n.userData.color = e),
          n.position.copy(t.position),
          t.parent.add(n),
          this.glowDevs.push(n)
      }
    }
  }
  getGlowDev(t) {
    for (let e of this.glowDevs) if (e.name === 'Glow_' + t) return e
    return null
  }
  delGlowDev(t) {
    'string' == typeof t && (t = [t])
    for (let e of t)
      for (let t in this.glowDevs) {
        let n = this.glowDevs[t]
        n.name === 'Glow_' + e && (n.parent.remove(n), this.glowDevs.splice(t, 1))
      }
  }
  delAllGlowDev() {
    for (let t of this.glowDevs) t.parent.remove(t)
    this.glowDevs = []
  }
}
class Gh {
  constructor() {
    ;(this.enabled = !0), (this.needsSwap = !0), (this.clear = !1), (this.renderToScreen = !1)
  }
  setSize() {}
  render() {
    console.error('THREE.Pass: .render() must be implemented in derived pass.')
  }
}
const zh = new gn(-1, 1, 1, -1, 0, 1),
  Bh = new xe()
Bh.setAttribute('position', new ce([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
  Bh.setAttribute('uv', new ce([0, 2, 0, 0, 2, 0], 2))
class Uh {
  constructor(t) {
    this._mesh = new Fe(Bh, t)
  }
  dispose() {
    this._mesh.geometry.dispose()
  }
  render(t) {
    t.render(this._mesh, zh)
  }
  get material() {
    return this._mesh.material
  }
  set material(t) {
    this._mesh.material = t
  }
}
const Vh = {
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
    vertexShader:
      '\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}',
    fragmentShader:
      '\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}'
  },
  Hh = {
    shaderID: 'luminosityHighPass',
    uniforms: {
      tDiffuse: { value: null },
      luminosityThreshold: { value: 1 },
      smoothWidth: { value: 1 },
      defaultColor: { value: new L(0) },
      defaultOpacity: { value: 0 }
    },
    vertexShader:
      '\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}',
    fragmentShader:
      '\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}'
  }
class kh extends Gh {
  constructor(t, e, n, i) {
    super(),
      (this.strength = void 0 !== e ? e : 1),
      (this.radius = n),
      (this.threshold = i),
      (this.resolution = void 0 !== t ? new _(t.x, t.y) : new _(256, 256)),
      (this.clearColor = new L(0, 0, 0)),
      (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5)
    let s = Math.round(this.resolution.x / 2),
      r = Math.round(this.resolution.y / 2)
    ;(this.renderTargetBright = new z(s, r)),
      (this.renderTargetBright.texture.name = 'UnrealBloomPass.bright'),
      (this.renderTargetBright.texture.generateMipmaps = !1),
      (this.renderTargetBright.samples = 16)
    for (let t = 0; t < this.nMips; t++) {
      const e = new z(s, r)
      ;(e.texture.name = 'UnrealBloomPass.h' + t),
        (e.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(e)
      const n = new z(s, r)
      ;(n.texture.name = 'UnrealBloomPass.v' + t),
        (n.texture.generateMipmaps = !1),
        (n.samples = 16),
        this.renderTargetsVertical.push(n),
        (s = Math.round(s / 2)),
        (r = Math.round(r / 2))
    }
    const o = Hh
    ;(this.highPassUniforms = Ve.clone(o.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = i),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new He({
        uniforms: this.highPassUniforms,
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        defines: {}
      })),
      (this.separableBlurMaterials = [])
    const a = [3, 5, 7, 9, 11]
    ;(s = Math.round(this.resolution.x / 2)), (r = Math.round(this.resolution.y / 2))
    for (let t = 0; t < this.nMips; t++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(a[t])),
        (this.separableBlurMaterials[t].uniforms.texSize.value = new _(s, r)),
        (s = Math.round(s / 2)),
        (r = Math.round(r / 2))
    ;(this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = e),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
      (this.compositeMaterial.needsUpdate = !0)
    ;(this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2]),
      (this.bloomTintColors = [
        new H(1, 1, 1),
        new H(1, 1, 1),
        new H(1, 1, 1),
        new H(1, 1, 1),
        new H(1, 1, 1)
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors)
    const l = Vh
    ;(this.copyUniforms = Ve.clone(l.uniforms)),
      (this.copyUniforms.opacity.value = 1),
      (this.materialCopy = new He({
        uniforms: this.copyUniforms,
        vertexShader: l.vertexShader,
        fragmentShader: l.fragmentShader,
        blending: 2,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new L()),
      (this.oldClearAlpha = 1),
      (this.basic = new se()),
      (this.fsQuad = new Uh(null))
  }
  dispose() {
    for (let t = 0; t < this.renderTargetsHorizontal.length; t++)
      this.renderTargetsHorizontal[t].dispose()
    for (let t = 0; t < this.renderTargetsVertical.length; t++)
      this.renderTargetsVertical[t].dispose()
    this.renderTargetBright.dispose()
    for (let t = 0; t < this.separableBlurMaterials.length; t++)
      this.separableBlurMaterials[t].dispose()
    this.compositeMaterial.dispose(),
      this.materialCopy.dispose(),
      this.basic.dispose(),
      this.fsQuad.dispose()
  }
  setSize(t, e) {
    let n = Math.round(t / 2),
      i = Math.round(e / 2)
    this.renderTargetBright.setSize(n, i)
    for (let t = 0; t < this.nMips; t++)
      this.renderTargetsHorizontal[t].setSize(n, i),
        this.renderTargetsVertical[t].setSize(n, i),
        (this.separableBlurMaterials[t].uniforms.texSize.value = new _(n, i)),
        (n = Math.round(n / 2)),
        (i = Math.round(i / 2))
  }
  render(t, e, n, i, s) {
    t.getClearColor(this._oldClearColor), (this.oldClearAlpha = t.getClearAlpha())
    const r = t.autoClear
    ;(t.autoClear = !1),
      t.setClearColor(this.clearColor, 0),
      s && t.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = n.texture),
        t.setRenderTarget(null),
        t.clear(),
        this.fsQuad.render(t)),
      (this.highPassUniforms.tDiffuse.value = n.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      t.setRenderTarget(this.renderTargetBright),
      t.clear(),
      this.fsQuad.render(t)
    let o = this.renderTargetBright
    for (let e = 0; e < this.nMips; e++)
      (this.fsQuad.material = this.separableBlurMaterials[e]),
        (this.separableBlurMaterials[e].uniforms.colorTexture.value = o.texture),
        (this.separableBlurMaterials[e].uniforms.direction.value = kh.BlurDirectionX),
        t.setRenderTarget(this.renderTargetsHorizontal[e]),
        t.clear(),
        this.fsQuad.render(t),
        (this.separableBlurMaterials[e].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[e].texture),
        (this.separableBlurMaterials[e].uniforms.direction.value = kh.BlurDirectionY),
        t.setRenderTarget(this.renderTargetsVertical[e]),
        t.clear(),
        this.fsQuad.render(t),
        (o = this.renderTargetsVertical[e])
    ;(this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors),
      t.setRenderTarget(this.renderTargetsHorizontal[0]),
      t.clear(),
      this.fsQuad.render(t),
      (this.fsQuad.material = this.materialCopy),
      (this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture),
      s && t.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (t.setRenderTarget(null), this.fsQuad.render(t))
        : (t.setRenderTarget(n), this.fsQuad.render(t)),
      t.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (t.autoClear = r)
  }
  getSeperableBlurMaterial(t) {
    return new He({
      defines: { KERNEL_RADIUS: t, SIGMA: t },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new _(0.5, 0.5) },
        direction: { value: new _(0.5, 0.5) }
      },
      vertexShader:
        'varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}',
      fragmentShader:
        '#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}'
    })
  }
  getCompositeMaterial(t) {
    return new He({
      defines: { NUM_MIPS: t },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader:
        'varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}',
      fragmentShader:
        'varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}'
    })
  }
}
;(kh.BlurDirectionX = new _(1, 0)), (kh.BlurDirectionY = new _(0, 1))
class Wh extends Gh {
  constructor(t, e, n, i, s) {
    super(),
      (this.scene = t),
      (this.camera = e),
      (this.overrideMaterial = n),
      (this.clearColor = i),
      (this.clearAlpha = void 0 !== s ? s : 0),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new L())
  }
  render(t, e, n) {
    const i = t.autoClear
    let s, r
    ;(t.autoClear = !1),
      void 0 !== this.overrideMaterial &&
        ((r = this.scene.overrideMaterial), (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor &&
        (t.getClearColor(this._oldClearColor),
        (s = t.getClearAlpha()),
        t.setClearColor(this.clearColor, this.clearAlpha)),
      this.clearDepth && t.clearDepth(),
      t.setRenderTarget(this.renderToScreen ? null : n),
      this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      t.render(this.scene, this.camera),
      this.clearColor && t.setClearColor(this._oldClearColor, s),
      void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = r),
      (t.autoClear = i)
  }
}
const Yh = {
    defines: { SMAA_THRESHOLD: '0.1' },
    uniforms: { tDiffuse: { value: null }, resolution: { value: new _(1 / 1024, 1 / 512) } },
    vertexShader:
      '\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}',
    fragmentShader:
      '\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}'
  },
  jh = {
    defines: {
      SMAA_MAX_SEARCH_STEPS: '8',
      SMAA_AREATEX_MAX_DISTANCE: '16',
      SMAA_AREATEX_PIXEL_SIZE: '( 1.0 / vec2( 160.0, 560.0 ) )',
      SMAA_AREATEX_SUBTEX_SIZE: '( 1.0 / 7.0 )'
    },
    uniforms: {
      tDiffuse: { value: null },
      tArea: { value: null },
      tSearch: { value: null },
      resolution: { value: new _(1 / 1024, 1 / 512) }
    },
    vertexShader:
      '\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}',
    fragmentShader:
      '\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}'
  },
  qh = {
    uniforms: {
      tDiffuse: { value: null },
      tColor: { value: null },
      resolution: { value: new _(1 / 1024, 1 / 512) }
    },
    vertexShader:
      '\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}',
    fragmentShader:
      '\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}'
  }
class Zh extends Gh {
  constructor(t, e) {
    super(),
      (this.edgesRT = new z(t, e, { depthBuffer: !1 })),
      (this.edgesRT.texture.name = 'SMAAPass.edges'),
      (this.weightsRT = new z(t, e, { depthBuffer: !1 })),
      (this.weightsRT.texture.name = 'SMAAPass.weights')
    const n = this,
      i = new Image()
    ;(i.src = this.getAreaTexture()),
      (i.onload = function () {
        n.areaTexture.needsUpdate = !0
      }),
      (this.areaTexture = new F()),
      (this.areaTexture.name = 'SMAAPass.area'),
      (this.areaTexture.image = i),
      (this.areaTexture.minFilter = 1006),
      (this.areaTexture.generateMipmaps = !1),
      (this.areaTexture.flipY = !1)
    const s = new Image()
    ;(s.src = this.getSearchTexture()),
      (s.onload = function () {
        n.searchTexture.needsUpdate = !0
      }),
      (this.searchTexture = new F()),
      (this.searchTexture.name = 'SMAAPass.search'),
      (this.searchTexture.image = s),
      (this.searchTexture.magFilter = 1003),
      (this.searchTexture.minFilter = 1003),
      (this.searchTexture.generateMipmaps = !1),
      (this.searchTexture.flipY = !1),
      void 0 === Yh && console.error('THREE.SMAAPass relies on SMAAShader'),
      (this.uniformsEdges = Ve.clone(Yh.uniforms)),
      this.uniformsEdges.resolution.value.set(1 / t, 1 / e),
      (this.materialEdges = new He({
        defines: Object.assign({}, Yh.defines),
        uniforms: this.uniformsEdges,
        vertexShader: Yh.vertexShader,
        fragmentShader: Yh.fragmentShader
      })),
      (this.uniformsWeights = Ve.clone(jh.uniforms)),
      this.uniformsWeights.resolution.value.set(1 / t, 1 / e),
      (this.uniformsWeights.tDiffuse.value = this.edgesRT.texture),
      (this.uniformsWeights.tArea.value = this.areaTexture),
      (this.uniformsWeights.tSearch.value = this.searchTexture),
      (this.materialWeights = new He({
        defines: Object.assign({}, jh.defines),
        uniforms: this.uniformsWeights,
        vertexShader: jh.vertexShader,
        fragmentShader: jh.fragmentShader
      })),
      (this.uniformsBlend = Ve.clone(qh.uniforms)),
      this.uniformsBlend.resolution.value.set(1 / t, 1 / e),
      (this.uniformsBlend.tDiffuse.value = this.weightsRT.texture),
      (this.materialBlend = new He({
        uniforms: this.uniformsBlend,
        vertexShader: qh.vertexShader,
        fragmentShader: qh.fragmentShader
      })),
      (this.needsSwap = !1),
      (this.fsQuad = new Uh(null))
  }
  render(t, e, n) {
    ;(this.uniformsEdges.tDiffuse.value = n.texture),
      (this.fsQuad.material = this.materialEdges),
      t.setRenderTarget(this.edgesRT),
      this.clear && t.clear(),
      this.fsQuad.render(t),
      (this.fsQuad.material = this.materialWeights),
      t.setRenderTarget(this.weightsRT),
      this.clear && t.clear(),
      this.fsQuad.render(t),
      (this.uniformsBlend.tColor.value = n.texture),
      (this.fsQuad.material = this.materialBlend),
      this.renderToScreen
        ? (t.setRenderTarget(null), this.fsQuad.render(t))
        : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t))
  }
  setSize(t, e) {
    this.edgesRT.setSize(t, e),
      this.weightsRT.setSize(t, e),
      this.materialEdges.uniforms.resolution.value.set(1 / t, 1 / e),
      this.materialWeights.uniforms.resolution.value.set(1 / t, 1 / e),
      this.materialBlend.uniforms.resolution.value.set(1 / t, 1 / e)
  }
  getAreaTexture() {
    return 'data:image/png;base64,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'
  }
  getSearchTexture() {
    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII='
  }
}
class Xh extends Gh {
  constructor(t, e) {
    super(),
      (this.textureID = void 0 !== e ? e : 'tDiffuse'),
      t instanceof He
        ? ((this.uniforms = t.uniforms), (this.material = t))
        : t &&
          ((this.uniforms = Ve.clone(t.uniforms)),
          (this.material = new He({
            defines: Object.assign({}, t.defines),
            uniforms: this.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader
          }))),
      (this.fsQuad = new Uh(this.material))
  }
  render(t, e, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (t.setRenderTarget(null), this.fsQuad.render(t))
        : (t.setRenderTarget(e),
          this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          this.fsQuad.render(t))
  }
}
class Kh extends Gh {
  constructor(t, e) {
    super(),
      (this.scene = t),
      (this.camera = e),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1)
  }
  render(t, e, n) {
    const i = t.getContext(),
      s = t.state
    let r, o
    s.buffers.color.setMask(!1),
      s.buffers.depth.setMask(!1),
      s.buffers.color.setLocked(!0),
      s.buffers.depth.setLocked(!0),
      this.inverse ? ((r = 0), (o = 1)) : ((r = 1), (o = 0)),
      s.buffers.stencil.setTest(!0),
      s.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
      s.buffers.stencil.setFunc(i.ALWAYS, r, 4294967295),
      s.buffers.stencil.setClear(o),
      s.buffers.stencil.setLocked(!0),
      t.setRenderTarget(n),
      this.clear && t.clear(),
      t.render(this.scene, this.camera),
      t.setRenderTarget(e),
      this.clear && t.clear(),
      t.render(this.scene, this.camera),
      s.buffers.color.setLocked(!1),
      s.buffers.depth.setLocked(!1),
      s.buffers.stencil.setLocked(!1),
      s.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
      s.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
      s.buffers.stencil.setLocked(!0)
  }
}
class Jh extends Gh {
  constructor() {
    super(), (this.needsSwap = !1)
  }
  render(t) {
    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
  }
}
class Qh {
  constructor(t, e) {
    if (((this.renderer = t), void 0 === e)) {
      const n = { minFilter: 1006, magFilter: 1006, format: 1023 },
        i = t.getSize(new _())
      ;(this._pixelRatio = t.getPixelRatio()),
        (this._width = i.width),
        (this._height = i.height),
        ((e = new z(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          n
        )).texture.name = 'EffectComposer.rt1')
    } else (this._pixelRatio = 1), (this._width = e.width), (this._height = e.height)
    ;(this.renderTarget1 = e),
      (this.renderTarget2 = e.clone()),
      (this.renderTarget2.texture.name = 'EffectComposer.rt2'),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      (this.passes = []),
      void 0 === Vh && console.error('THREE.EffectComposer relies on CopyShader'),
      void 0 === Xh && console.error('THREE.EffectComposer relies on ShaderPass'),
      (this.copyPass = new Xh(Vh)),
      (this.clock = new Ba())
  }
  swapBuffers() {
    const t = this.readBuffer
    ;(this.readBuffer = this.writeBuffer), (this.writeBuffer = t)
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
  }
  insertPass(t, e) {
    this.passes.splice(e, 0, t),
      t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
  }
  removePass(t) {
    const e = this.passes.indexOf(t)
    ;-1 !== e && this.passes.splice(e, 1)
  }
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++) if (this.passes[e].enabled) return !1
    return !0
  }
  render(t) {
    void 0 === t && (t = this.clock.getDelta())
    const e = this.renderer.getRenderTarget()
    let n = !1
    for (let e = 0, i = this.passes.length; e < i; e++) {
      const i = this.passes[e]
      if (!1 !== i.enabled) {
        if (
          ((i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e)),
          i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n),
          i.needsSwap)
        ) {
          if (n) {
            const e = this.renderer.getContext(),
              n = this.renderer.state.buffers.stencil
            n.setFunc(e.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t),
              n.setFunc(e.EQUAL, 1, 4294967295)
          }
          this.swapBuffers()
        }
        void 0 !== Kh && (i instanceof Kh ? (n = !0) : i instanceof Jh && (n = !1))
      }
    }
    this.renderer.setRenderTarget(e)
  }
  reset(t) {
    if (void 0 === t) {
      const e = this.renderer.getSize(new _())
      ;(this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = e.width),
        (this._height = e.height),
        (t = this.renderTarget1.clone()).setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        )
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2)
  }
  setSize(t, e) {
    ;(this._width = t), (this._height = e)
    const n = this._width * this._pixelRatio,
      i = this._height * this._pixelRatio
    this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i)
    for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i)
  }
  setPixelRatio(t) {
    ;(this._pixelRatio = t), this.setSize(this._width, this._height)
  }
}
new gn(-1, 1, 1, -1, 0, 1)
const $h = new xe()
$h.setAttribute('position', new ce([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
  $h.setAttribute('uv', new ce([0, 2, 0, 0, 2, 0], 2))
class tc {
  constructor(t) {
    ;(this.rootApp = t),
      (this.isCompose = !1),
      (this.lineMaterObjs = []),
      (this.setJson = null),
      (this.params = {
        isUnrealBloom: !1,
        bloomStrength: 0.7,
        bloomThreshold: 0,
        bloomRadius: 1,
        sceneColor: '#121212'
      }),
      (this.composer = new Qh(this.rootApp.renderer)),
      (this.dynamic_line_material = null),
      (this.textureDic = {})
  }
  setParams() {
    if (((this.setJson = xh.wholeJson.wholeDisplayEffect), this.setJson))
      for (let t in this.setJson) this.params[t] = this.setJson[t]
  }
  setDisplayEffect() {
    ;(this.textureDic = this.rootApp.wholeApp.textureDic),
      this.setJson.isUnrealBloom && ((this.isCompose = !0), this.bloom())
    let t = this.textureDic.sphereBack
    const e = new se({ side: 1, map: t }),
      n = new Fo(2, 128, 64, 0, 2 * Math.PI, 0, 0.5 * Math.PI),
      i = new Fe(n, e)
    this.rootApp.scene.add(i)
    const s = new sn(4, 4)
    let r = this.textureDic.ground
    const o = new Uo({ map: r, side: 2 }),
      a = new Fe(s, o)
    ;(a.position.y += 0.01),
      a.rotation.set(-Math.PI / 2, 0, 0),
      this.rootApp.scene.add(a),
      this.rootApp.addEventListener('onAnimate', (t) => {
        this.dynamic_line_material
      })
  }
  createDynamicLine() {
    return new He({
      uniforms: {
        disc_color: { value: new L(0.2, 0.47, 1) },
        disc_offset: { value: 0.2 },
        disc_speed: { value: 0.5 },
        flow_count: { value: 1 },
        emisstion_power: { value: 2 },
        gradient: { value: this.textureDic.elecLine },
        TIME: { value: 0 }
      },
      vertexShader:
        '\n                        uniform float TIME;\n                        varying vec2 vUv;\n                        varying float vTIME;\n                        void main() {\n                          vUv = uv;\n                          vTIME = TIME;\n                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                        }\n                        ',
      fragmentShader:
        '\n                        varying vec2 vUv;\n                        varying float vTIME;\n                        uniform sampler2D gradient;\n                        \n                        uniform vec3 disc_color;\n                        uniform float disc_offset;\n                        uniform float disc_speed;\n                        uniform float flow_count;\n                        uniform float emisstion_power;\n                        \n                        void main() {\n                            vec4 originColor = texture2D(gradient, vUv).rgba;\n                            vec3 color = originColor.rgb * disc_color;\n                            // if(color.r < 0.1 && color.g < 0.1 && color.b < 0.1){\n                              // discard;\n                            // }else{\n                              float global_disc = 0.0;\n                              float cd = distance(vUv, vec2(0.5));\n                              for(int i = 0; i < int(flow_count); i++) {\n                                  float offset = float(i) * disc_offset;\n                                  float radius_disc = 0.9;\n                                  float loop = fract((vTIME + offset) * disc_speed) * radius_disc;\n                                  float disc = smoothstep(cd, cd + 0.02, loop);\n                                  float fade = abs(loop - radius_disc);\n                                  fade = pow(fade, 3.0);\n                                  disc *= fade;\n                                  disc = clamp(disc, 0.0, 1.0);\n                                  global_disc += disc;\n                              }\n                              global_disc *= emisstion_power;\n                              vec3 albedo = color * vec3(global_disc) + color * 0.1;\n                              gl_FragColor.rgb = albedo;\n                              gl_FragColor.a = originColor.a;\n                            // }\n                        }\n                        '
    })
  }
  bloom() {
    let t = new kh(new _(this.rootApp.width, this.rootApp.height), 1.5, 0.4, 0.85)
    ;(t.threshold = this.params.bloomThreshold),
      (t.strength = this.params.bloomStrength),
      (t.radius = this.params.bloomRadius)
    const e = new Wh(this.rootApp.scene, this.rootApp.camera)
    this.composer.addPass(e), this.composer.addPass(t)
    let n = new Zh(this.rootApp.width, this.rootApp.height)
    this.composer.addPass(n), this.composer.setSize(this.rootApp.width, this.rootApp.height)
  }
  render() {
    this.isCompose
      ? this.composer.render()
      : this.rootApp.renderer.render(this.rootApp.scene, this.rootApp.camera)
  }
}
class ec {
  constructor(t) {
    ;(this.rootApp = t), (this.renderer = t.renderer), (this.curEvent = 'building'), this.init()
  }
  init() {
    this.rootApp.addEventListener('showAllBuilding', (t) => {
      this.curEvent = 'building'
    }),
      this.rootApp.addEventListener('showOneBuilding', (t) => {
        this.curEvent = 'floor'
      }),
      this.rootApp.addEventListener('onPostFloorOpen', (t) => {
        this.curEvent = 'dev'
      }),
      this.rootApp.addEventListener('onPostFloorClose', (t) => {
        this.curEvent = 'floor'
      })
  }
  getCurScenes() {
    return 'building' === this.curEvent ? 'park' : 'floor' === this.curEvent ? 'building' : 'floor'
  }
}
const nc = new H(),
  ic = new V(),
  sc = new H()
class rc extends Wt {
  constructor(t = document.createElement('div')) {
    super(),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.pointerEvents = 'auto'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      this.addEventListener('removed', function () {
        this.traverse(function (t) {
          t.element instanceof Element &&
            null !== t.element.parentNode &&
            t.element.parentNode.removeChild(t.element)
        })
      })
  }
  copy(t, e) {
    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this
  }
}
rc.prototype.isCSS3DObject = !0
class oc extends rc {
  constructor(t) {
    super(t), (this.rotation2D = 0)
  }
  copy(t, e) {
    return super.copy(t, e), (this.rotation2D = t.rotation2D), this
  }
}
oc.prototype.isCSS3DSprite = !0
const ac = new vt(),
  lc = new vt()
class hc {
  constructor(t = {}) {
    const e = this
    let n, i, s, r
    const o = { camera: { fov: 0, style: '' }, objects: new WeakMap() },
      a = void 0 !== t.element ? t.element : document.createElement('div')
    ;(a.style.overflow = 'hidden'), (this.domElement = a)
    const l = document.createElement('div')
    function h(t) {
      return Math.abs(t) < 1e-10 ? 0 : t
    }
    function c(t) {
      const e = t.elements
      return (
        'matrix3d(' +
        h(e[0]) +
        ',' +
        h(-e[1]) +
        ',' +
        h(e[2]) +
        ',' +
        h(e[3]) +
        ',' +
        h(e[4]) +
        ',' +
        h(-e[5]) +
        ',' +
        h(e[6]) +
        ',' +
        h(e[7]) +
        ',' +
        h(e[8]) +
        ',' +
        h(-e[9]) +
        ',' +
        h(e[10]) +
        ',' +
        h(e[11]) +
        ',' +
        h(e[12]) +
        ',' +
        h(-e[13]) +
        ',' +
        h(e[14]) +
        ',' +
        h(e[15]) +
        ')'
      )
    }
    function u(t) {
      const e = t.elements
      return (
        'translate(-50%,-50%)' +
        ('matrix3d(' +
          h(e[0]) +
          ',' +
          h(e[1]) +
          ',' +
          h(e[2]) +
          ',' +
          h(e[3]) +
          ',' +
          h(-e[4]) +
          ',' +
          h(-e[5]) +
          ',' +
          h(-e[6]) +
          ',' +
          h(-e[7]) +
          ',' +
          h(e[8]) +
          ',' +
          h(e[9]) +
          ',' +
          h(e[10]) +
          ',' +
          h(e[11]) +
          ',' +
          h(e[12]) +
          ',' +
          h(e[13]) +
          ',' +
          h(e[14]) +
          ',' +
          h(e[15]) +
          ')')
      )
    }
    function d(t, n, i, s) {
      if (t.isCSS3DObject) {
        const s = !0 === t.visible && !0 === t.layers.test(i.layers)
        if (((t.element.style.display = !0 === s ? '' : 'none'), !0 === s)) {
          let s
          t.onBeforeRender(e, n, i),
            t.isCSS3DSprite
              ? (ac.copy(i.matrixWorldInverse),
                ac.transpose(),
                0 !== t.rotation2D && ac.multiply(lc.makeRotationZ(t.rotation2D)),
                t.matrixWorld.decompose(nc, ic, sc),
                ac.setPosition(nc),
                ac.scale(sc),
                (ac.elements[3] = 0),
                (ac.elements[7] = 0),
                (ac.elements[11] = 0),
                (ac.elements[15] = 1),
                (s = u(ac)))
              : (s = u(t.matrixWorld))
          const r = t.element,
            a = o.objects.get(t)
          if (void 0 === a || a.style !== s) {
            r.style.transform = s
            const e = { style: s }
            o.objects.set(t, e)
          }
          r.parentNode !== l && l.appendChild(r), t.onAfterRender(e, n, i)
        }
      }
      for (let e = 0, s = t.children.length; e < s; e++) d(t.children[e], n, i)
    }
    ;(l.style.transformStyle = 'preserve-3d'),
      (l.style.pointerEvents = 'none'),
      a.appendChild(l),
      (this.getSize = function () {
        return { width: n, height: i }
      }),
      (this.render = function (t, e) {
        const n = e.projectionMatrix.elements[5] * r
        let i, u
        o.camera.fov !== n &&
          ((a.style.perspective = e.isPerspectiveCamera ? n + 'px' : ''), (o.camera.fov = n)),
          !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          e.isOrthographicCamera && ((i = -(e.right + e.left) / 2), (u = (e.top + e.bottom) / 2))
        const p =
          (e.isOrthographicCamera
            ? 'scale(' + n + ')translate(' + h(i) + 'px,' + h(u) + 'px)' + c(e.matrixWorldInverse)
            : 'translateZ(' + n + 'px)' + c(e.matrixWorldInverse)) +
          'translate(' +
          s +
          'px,' +
          r +
          'px)'
        o.camera.style !== p && ((l.style.transform = p), (o.camera.style = p)), d(t, t, e)
      }),
      (this.setSize = function (t, e) {
        ;(n = t),
          (i = e),
          (s = n / 2),
          (r = i / 2),
          (a.style.width = t + 'px'),
          (a.style.height = e + 'px'),
          (l.style.width = t + 'px'),
          (l.style.height = e + 'px')
      })
  }
}
class cc {
  constructor(t) {
    ;(this.rootApp = t),
      (this.css3dRenderer = new hc()),
      this.css3dRenderer.setSize(this.rootApp.width, this.rootApp.height),
      (this.css3dRenderer.domElement.style.position = 'absolute'),
      (this.css3dRenderer.domElement.style.top = 0),
      (this.css3dRenderer.domElement.style.pointerEvents = 'none'),
      (this.css3dRenderer.domElement.style.zIndex = 1),
      document.body.appendChild(this.css3dRenderer.domElement),
      document.getElementById(yh.container_id).appendChild(this.css3dRenderer.domElement),
      (this.css3dScene = new Os()),
      (this.group = new Is()),
      this.css3dScene.add(this.group),
      this.rootApp.addEventListener('onPreFloorClose', (t) => {
        this.delAllPlane()
      })
  }
  createPlane(t, e) {
    let n = new H()
    const i = new oc(t)
    ;(i.name = 'Lab3d_' + e.name), e.getWorldPosition(n)
    let s = this.group.worldToLocal(n)
    i.position.set(s.x, s.y, s.z), i.translateY(50)
    for (let t of this.group.children) t.name === 'Lab3d_' + e.name && t.removeFromParent()
    this.group.add(i)
  }
  addLabByObjName(t, e) {
    let n = this.rootApp.scene.getObjectByName(e)
    this.createPlane(t, n)
  }
  delAllPlane() {
    for (; this.group.children.length > 0; ) this.group.children[0].removeFromParent()
  }
  delByObjName(t) {
    for (let e of this.group.children)
      if (e.name === 'Lab3d_' + t) {
        e.removeFromParent()
        break
      }
  }
}
class uc extends Wt {
  constructor(t = document.createElement('div')) {
    super(),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      this.addEventListener('removed', function () {
        this.traverse(function (t) {
          t.element instanceof Element &&
            null !== t.element.parentNode &&
            t.element.parentNode.removeChild(t.element)
        })
      })
  }
  copy(t, e) {
    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this
  }
}
uc.prototype.isCSS2DObject = !0
const dc = new H(),
  pc = new vt(),
  gc = new vt(),
  fc = new H(),
  mc = new H()
class yc {
  constructor(t = {}) {
    const e = this
    let n, i, s, r
    const o = { objects: new WeakMap() },
      a = void 0 !== t.element ? t.element : document.createElement('div')
    function l(t, n, i) {
      if (t.isCSS2DObject) {
        dc.setFromMatrixPosition(t.matrixWorld), dc.applyMatrix4(gc)
        const l = !0 === t.visible && dc.z >= -1 && dc.z <= 1 && !0 === t.layers.test(i.layers)
        if (((t.element.style.display = !0 === l ? '' : 'none'), !0 === l)) {
          t.onBeforeRender(e, n, i)
          const o = t.element
          ;/apple/i.test(navigator.vendor)
            ? (o.style.transform =
                'translate(-50%,-50%) translate(' +
                Math.round(dc.x * s + s) +
                'px,' +
                Math.round(-dc.y * r + r) +
                'px)')
            : (o.style.transform =
                'translate(-50%,-50%) translate(' +
                (dc.x * s + s) +
                'px,' +
                (-dc.y * r + r) +
                'px)'),
            o.parentNode !== a && a.appendChild(o),
            t.onAfterRender(e, n, i)
        }
        const c = { distanceToCameraSquared: h(i, t) }
        o.objects.set(t, c)
      }
      for (let e = 0, s = t.children.length; e < s; e++) l(t.children[e], n, i)
    }
    function h(t, e) {
      return (
        fc.setFromMatrixPosition(t.matrixWorld),
        mc.setFromMatrixPosition(e.matrixWorld),
        fc.distanceToSquared(mc)
      )
    }
    ;(a.style.overflow = 'hidden'),
      (this.domElement = a),
      (this.getSize = function () {
        return { width: n, height: i }
      }),
      (this.render = function (t, e) {
        !0 === t.autoUpdate && t.updateMatrixWorld(),
          null === e.parent && e.updateMatrixWorld(),
          pc.copy(e.matrixWorldInverse),
          gc.multiplyMatrices(e.projectionMatrix, pc),
          l(t, t, e),
          (function (t) {
            const e = (function (t) {
                const e = []
                return (
                  t.traverse(function (t) {
                    t.isCSS2DObject && e.push(t)
                  }),
                  e
                )
              })(t).sort(function (t, e) {
                if (t.renderOrder !== e.renderOrder) return e.renderOrder - t.renderOrder
                return (
                  o.objects.get(t).distanceToCameraSquared -
                  o.objects.get(e).distanceToCameraSquared
                )
              }),
              n = e.length
            for (let t = 0, i = e.length; t < i; t++) e[t].element.style.zIndex = n - t
          })(t)
      }),
      (this.setSize = function (t, e) {
        ;(n = t),
          (i = e),
          (s = n / 2),
          (r = i / 2),
          (a.style.width = t + 'px'),
          (a.style.height = e + 'px')
      })
  }
}
class xc {
  constructor(t) {
    ;(this.rootApp = t),
      (this.css2dRenderer = new yc()),
      this.css2dRenderer.setSize(window.innerWidth, window.innerHeight),
      (this.css2dRenderer.domElement.style.position = 'absolute'),
      (this.css2dRenderer.domElement.style.top = '0px'),
      (this.css2dRenderer.domElement.style.pointerEvents = 'none'),
      (this.css2dRenderer.domElement.style.zIndex = 1),
      document.body.appendChild(this.css2dRenderer.domElement),
      (this.labList = []),
      this.rootApp.addEventListener('onPreFloorClose', (t) => {
        this.delAllLab()
      })
  }
  addLab(t, e, n) {
    if (e) {
      const i = new uc(t)
      e.add(i), i.position.set(0, n, 0), this.labList.push(i), (i.name = 'Lab2d_' + e.name)
    }
  }
  addLabByObjName(t, e, n) {
    let i = this.rootApp.scene.getObjectByName(e)
    this.addLab(t, i, n)
  }
  delAllLab() {
    for (let t of this.labList) t.removeFromParent()
    this.labList = []
  }
  delByObjName(t) {
    for (let e of this.labList)
      if (e.name === 'Lab2d_' + t) {
        e.removeFromParent(), this.labList.remove(e)
        break
      }
  }
}
var vc = (function (t) {
  var e = function (t) {
      var e,
        n = []
      for (e in t) Object.prototype.hasOwnProperty.call(t, e) && n.push(e)
      return n
    },
    n = function (t, e) {
      return parseFloat(t) - parseFloat(e)
    },
    i = function (i, s, r, o) {
      var a,
        l = {},
        h = { 0: [s] },
        c = {},
        u = function (t, e) {
          var n = '' + t
          h[n] || (h[n] = []), h[n].push(e)
        }
      for (l[s] = 0; h && (a = e(h)).length; ) {
        a.sort(n)
        var d = a[0],
          p = h[d],
          g = p.shift(),
          f = parseFloat(d),
          m = i[g] || {}
        for (var y in (p.length || delete h[d], m))
          if (Object.prototype.hasOwnProperty.call(m, y)) {
            var x = m[y] + f,
              v = l[y]
            ;(v === t || v > x) && ((l[y] = x), u(x, y), (c[y] = g))
          }
      }
      return l[r] === t ? null : c
    },
    s = function (e, n) {
      for (var i = [], s = n; s !== t; ) i.push(s), (s = e[s])
      return i.reverse(), i
    },
    r = function (t, e) {
      for (var n, r, o, a = e.shift(), l = []; e.length; ) {
        if (((n = e.shift()), !(r = i(t, a, n)))) return null
        if (((o = s(r, n)), !e.length)) return l.concat(o)
        l.push.apply(l, o.slice(0, -1)), (a = n)
      }
    },
    o = function (t, e) {
      try {
        return Array.prototype.slice.call(t, e)
      } catch (r) {
        for (var n = [], i = e || 0, s = t.length; i < s; ++i) n.push(t[i])
        return n
      }
    },
    a = function (t) {
      this.map = t
    }
  return (
    (a.prototype.findShortestPath = function (t, e) {
      return '[object Array]' === Object.prototype.toString.call(t)
        ? r(this.map, t)
        : r(this.map, 2 === arguments.length ? [t, e] : o(arguments))
    }),
    (a.findShortestPath = function (t, e, n) {
      return '[object Array]' === Object.prototype.toString.call(e)
        ? r(t, e)
        : r(t, 3 === arguments.length ? [e, n] : o(arguments, 1))
    }),
    a
  )
})()
/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * @license
 */ class _c {
  static equalsWithTolerance(t, e, n) {
    return Math.abs(t - e) <= n
  }
}
class wc extends Error {
  constructor(t) {
    super(t), (this.name = Object.keys({ Exception: wc })[0])
  }
  toString() {
    return this.message
  }
}
class Ec extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ IllegalArgumentException: Ec })[0])
  }
}
class bc {
  constructor(t, e) {
    ;(this.low = e || 0), (this.high = t || 0)
  }
  static toBinaryString(t) {
    let e,
      n = ''
    for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? '1' : '0'
    for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? '1' : '0'
    return n
  }
}
function Mc() {}
function Sc() {}
function Ac() {}
function Tc() {}
function Ic() {}
;(Mc.NaN = NaN),
  (Mc.isNaN = (t) => Number.isNaN(t)),
  (Mc.isInfinite = (t) => !Number.isFinite(t)),
  (Mc.MAX_VALUE = Number.MAX_VALUE),
  (Mc.POSITIVE_INFINITY = Number.POSITIVE_INFINITY),
  (Mc.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY),
  'function' == typeof Float64Array && 'function' == typeof Int32Array
    ? (function () {
        const t = 2146435072,
          e = new Float64Array(1),
          n = new Int32Array(e.buffer)
        ;(Mc.doubleToLongBits = function (i) {
          e[0] = i
          let s = 0 | n[0],
            r = 0 | n[1]
          return (
            (r & t) === t && 0 != (1048575 & r) && 0 !== s && ((s = 0), (r = 2146959360)),
            new bc(r, s)
          )
        }),
          (Mc.longBitsToDouble = function (t) {
            return (n[0] = t.low), (n[1] = t.high), e[0]
          })
      })()
    : (function () {
        const t = 1023,
          e = Math.log2,
          n = Math.floor,
          i = Math.pow,
          s = (function () {
            for (let t = 53; t > 0; t--) {
              const s = i(2, t) - 1
              if (n(e(s)) + 1 === t) return s
            }
            return 0
          })()
        ;(Mc.doubleToLongBits = function (r) {
          let o, a, l, h, c, u, d, p, g
          if (
            (r < 0 || 1 / r === Number.NEGATIVE_INFINITY ? ((u = 1 << 31), (r = -r)) : (u = 0),
            0 === r)
          )
            return (g = 0), (p = u), new bc(p, g)
          if (r === 1 / 0) return (g = 0), (p = 2146435072 | u), new bc(p, g)
          if (r != r) return (g = 0), (p = 2146959360), new bc(p, g)
          if (((h = 0), (g = 0), (o = n(r)), o > 1))
            if (o <= s)
              (h = n(e(o))),
                h <= 20
                  ? ((g = 0), (p = (o << (20 - h)) & 1048575))
                  : ((l = h - 20), (a = i(2, l)), (g = o % a << (32 - l)), (p = (o / a) & 1048575))
            else
              for (l = o, g = 0; (a = l / 2), (l = n(a)), 0 !== l; )
                h++, (g >>>= 1), (g |= (1 & p) << 31), (p >>>= 1), a !== l && (p |= 524288)
          if (((d = h + t), (c = 0 === o), (o = r - o), h < 52 && 0 !== o))
            for (l = 0; ; ) {
              if (
                ((a = 2 * o),
                a >= 1
                  ? ((o = a - 1), c ? (d--, (c = !1)) : ((l <<= 1), (l |= 1), h++))
                  : ((o = a), c ? 0 == --d && (h++, (c = !1)) : ((l <<= 1), h++)),
                20 === h)
              )
                (p |= l), (l = 0)
              else if (52 === h) {
                g |= l
                break
              }
              if (1 === a) {
                h < 20 ? (p |= l << (20 - h)) : h < 52 && (g |= l << (52 - h))
                break
              }
            }
          return (p |= d << 20), (p |= u), new bc(p, g)
        }),
          (Mc.longBitsToDouble = function (e) {
            let n, s, r, o
            const a = e.high,
              l = e.low,
              h = a & (1 << 31) ? -1 : 1
            for (r = ((2146435072 & a) >> 20) - t, o = 0, s = 1 << 19, n = 1; n <= 20; n++)
              a & s && (o += i(2, -n)), (s >>>= 1)
            for (s = 1 << 31, n = 21; n <= 52; n++) l & s && (o += i(2, -n)), (s >>>= 1)
            if (-1023 === r) {
              if (0 === o) return 0 * h
              r = -1022
            } else {
              if (1024 === r) return 0 === o ? h / 0 : NaN
              o += 1
            }
            return h * o * i(2, r)
          })
      })()
class Rc extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ RuntimeException: Rc })[0])
  }
}
class Lc extends Rc {
  constructor() {
    super(), Lc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (0 === arguments.length) Rc.constructor_.call(this)
    else if (1 === arguments.length) {
      const t = arguments[0]
      Rc.constructor_.call(this, t)
    }
  }
}
class Cc {
  static shouldNeverReachHere() {
    if (0 === arguments.length) Cc.shouldNeverReachHere(null)
    else if (1 === arguments.length) {
      const t = arguments[0]
      throw new Lc('Should never reach here' + (null !== t ? ': ' + t : ''))
    }
  }
  static isTrue() {
    if (1 === arguments.length) {
      const t = arguments[0]
      Cc.isTrue(t, null)
    } else if (2 === arguments.length) {
      const t = arguments[1]
      if (!arguments[0]) throw null === t ? new Lc() : new Lc(t)
    }
  }
  static equals() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      Cc.equals(t, e, null)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (!e.equals(t))
        throw new Lc('Expected ' + t + ' but encountered ' + e + (null !== n ? ': ' + n : ''))
    }
  }
}
const Nc = new ArrayBuffer(8),
  Pc = new Float64Array(Nc),
  Dc = new Int32Array(Nc)
class Oc {
  constructor() {
    Oc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.x = null), (this.y = null), (this.z = null), 0 === arguments.length))
      Oc.constructor_.call(this, 0, 0)
    else if (1 === arguments.length) {
      const t = arguments[0]
      Oc.constructor_.call(this, t.x, t.y, t.getZ())
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      Oc.constructor_.call(this, t, e, Oc.NULL_ORDINATE)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this.x = t), (this.y = e), (this.z = n)
    }
  }
  static hashCode(t) {
    return (Pc[0] = t), Dc[0] ^ Dc[1]
  }
  getM() {
    return Mc.NaN
  }
  setOrdinate(t, e) {
    switch (t) {
      case Oc.X:
        this.x = e
        break
      case Oc.Y:
        this.y = e
        break
      case Oc.Z:
        this.setZ(e)
        break
      default:
        throw new Ec('Invalid ordinate index: ' + t)
    }
  }
  equals2D() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.x === t.x && this.y === t.y
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return !!_c.equalsWithTolerance(this.x, t.x, e) && !!_c.equalsWithTolerance(this.y, t.y, e)
    }
  }
  setM(t) {
    throw new Ec('Invalid ordinate index: ' + Oc.M)
  }
  getZ() {
    return this.z
  }
  getOrdinate(t) {
    switch (t) {
      case Oc.X:
        return this.x
      case Oc.Y:
        return this.y
      case Oc.Z:
        return this.getZ()
    }
    throw new Ec('Invalid ordinate index: ' + t)
  }
  equals3D(t) {
    return (
      this.x === t.x &&
      this.y === t.y &&
      (this.getZ() === t.getZ() || (Mc.isNaN(this.getZ()) && Mc.isNaN(t.getZ())))
    )
  }
  equals(t) {
    return t instanceof Oc && this.equals2D(t)
  }
  equalInZ(t, e) {
    return _c.equalsWithTolerance(this.getZ(), t.getZ(), e)
  }
  setX(t) {
    this.x = t
  }
  compareTo(t) {
    const e = t
    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
  }
  getX() {
    return this.x
  }
  setZ(t) {
    this.z = t
  }
  clone() {
    try {
      return null
    } catch (t) {
      if (t instanceof CloneNotSupportedException)
        return (
          Cc.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null
        )
      throw t
    }
  }
  copy() {
    return new Oc(this)
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')'
  }
  distance3D(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.getZ() - t.getZ()
    return Math.sqrt(e * e + n * n + i * i)
  }
  getY() {
    return this.y
  }
  setY(t) {
    this.y = t
  }
  distance(t) {
    const e = this.x - t.x,
      n = this.y - t.y
    return Math.sqrt(e * e + n * n)
  }
  hashCode() {
    let t = 17
    return (t = 37 * t + Oc.hashCode(this.x)), (t = 37 * t + Oc.hashCode(this.y)), t
  }
  setCoordinate(t) {
    ;(this.x = t.x), (this.y = t.y), (this.z = t.getZ())
  }
  get interfaces_() {
    return [Sc, Ac, Ic]
  }
}
class Fc {
  constructor() {
    Fc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._dimensionsToTest = 2), 0 === arguments.length)) Fc.constructor_.call(this, 2)
    else if (1 === arguments.length) {
      const t = arguments[0]
      if (2 !== t && 3 !== t) throw new Ec('only 2 or 3 dimensions may be specified')
      this._dimensionsToTest = t
    }
  }
  static compare(t, e) {
    return t < e ? -1 : t > e ? 1 : Mc.isNaN(t) ? (Mc.isNaN(e) ? 0 : -1) : Mc.isNaN(e) ? 1 : 0
  }
  compare(t, e) {
    const n = Fc.compare(t.x, e.x)
    if (0 !== n) return n
    const i = Fc.compare(t.y, e.y)
    if (0 !== i) return i
    if (this._dimensionsToTest <= 2) return 0
    return Fc.compare(t.getZ(), e.getZ())
  }
  get interfaces_() {
    return [Tc]
  }
}
;(Oc.DimensionalComparator = Fc),
  (Oc.NULL_ORDINATE = Mc.NaN),
  (Oc.X = 0),
  (Oc.Y = 1),
  (Oc.Z = 2),
  (Oc.M = 3)
class Gc extends Oc {
  constructor() {
    super(), Gc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (0 === arguments.length) Oc.constructor_.call(this)
    else if (1 === arguments.length) {
      if (arguments[0] instanceof Gc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t.x, t.y)
      } else if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t.x, t.y)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      Oc.constructor_.call(this, t, e, Oc.NULL_ORDINATE)
    }
  }
  setOrdinate(t, e) {
    switch (t) {
      case Gc.X:
        this.x = e
        break
      case Gc.Y:
        this.y = e
        break
      default:
        throw new Ec('Invalid ordinate index: ' + t)
    }
  }
  getZ() {
    return Oc.NULL_ORDINATE
  }
  getOrdinate(t) {
    switch (t) {
      case Gc.X:
        return this.x
      case Gc.Y:
        return this.y
    }
    throw new Ec('Invalid ordinate index: ' + t)
  }
  setZ(t) {
    throw new Ec('CoordinateXY dimension 2 does not support z-ordinate')
  }
  copy() {
    return new Gc(this)
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ')'
  }
  setCoordinate(t) {
    ;(this.x = t.x), (this.y = t.y), (this.z = t.getZ())
  }
}
;(Gc.X = 0), (Gc.Y = 1), (Gc.Z = -1), (Gc.M = -1)
class zc extends Oc {
  constructor() {
    super(), zc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._m = null), 0 === arguments.length)) Oc.constructor_.call(this), (this._m = 0)
    else if (1 === arguments.length) {
      if (arguments[0] instanceof zc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t.x, t.y), (this._m = t._m)
      } else if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t.x, t.y), (this._m = this.getM())
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      Oc.constructor_.call(this, t, e, Oc.NULL_ORDINATE), (this._m = n)
    }
  }
  getM() {
    return this._m
  }
  setOrdinate(t, e) {
    switch (t) {
      case zc.X:
        this.x = e
        break
      case zc.Y:
        this.y = e
        break
      case zc.M:
        this._m = e
        break
      default:
        throw new Ec('Invalid ordinate index: ' + t)
    }
  }
  setM(t) {
    this._m = t
  }
  getZ() {
    return Oc.NULL_ORDINATE
  }
  getOrdinate(t) {
    switch (t) {
      case zc.X:
        return this.x
      case zc.Y:
        return this.y
      case zc.M:
        return this._m
    }
    throw new Ec('Invalid ordinate index: ' + t)
  }
  setZ(t) {
    throw new Ec('CoordinateXY dimension 2 does not support z-ordinate')
  }
  copy() {
    return new zc(this)
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')'
  }
  setCoordinate(t) {
    ;(this.x = t.x), (this.y = t.y), (this.z = t.getZ()), (this._m = t.getM())
  }
}
;(zc.X = 0), (zc.Y = 1), (zc.Z = -1), (zc.M = 2)
class Bc extends Oc {
  constructor() {
    super(), Bc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._m = null), 0 === arguments.length)) Oc.constructor_.call(this), (this._m = 0)
    else if (1 === arguments.length) {
      if (arguments[0] instanceof Bc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t), (this._m = t._m)
      } else if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        Oc.constructor_.call(this, t), (this._m = this.getM())
      }
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      Oc.constructor_.call(this, t, e, n), (this._m = i)
    }
  }
  getM() {
    return this._m
  }
  setOrdinate(t, e) {
    switch (t) {
      case Oc.X:
        this.x = e
        break
      case Oc.Y:
        this.y = e
        break
      case Oc.Z:
        this.z = e
        break
      case Oc.M:
        this._m = e
        break
      default:
        throw new Ec('Invalid ordinate index: ' + t)
    }
  }
  setM(t) {
    this._m = t
  }
  getOrdinate(t) {
    switch (t) {
      case Oc.X:
        return this.x
      case Oc.Y:
        return this.y
      case Oc.Z:
        return this.getZ()
      case Oc.M:
        return this.getM()
    }
    throw new Ec('Invalid ordinate index: ' + t)
  }
  copy() {
    return new Bc(this)
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')'
  }
  setCoordinate(t) {
    ;(this.x = t.x), (this.y = t.y), (this.z = t.getZ()), (this._m = t.getM())
  }
}
function Uc(t, e) {
  return t.interfaces_ && t.interfaces_.indexOf(e) > -1
}
class Vc {
  add() {}
  addAll() {}
  isEmpty() {}
  iterator() {}
  size() {}
  toArray() {}
  remove() {}
}
class Hc extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ IndexOutOfBoundsException: Hc })[0])
  }
}
class kc extends Vc {
  get() {}
  set() {}
  isEmpty() {}
}
class Wc extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ NoSuchElementException: Wc })[0])
  }
}
class Yc extends kc {
  constructor(t) {
    super(), (this.array = []), t instanceof Vc && this.addAll(t)
  }
  get interfaces_() {
    return [kc, Vc]
  }
  ensureCapacity() {}
  add(t) {
    return (
      1 === arguments.length
        ? this.array.push(t)
        : this.array.splice(arguments[0], 0, arguments[1]),
      !0
    )
  }
  clear() {
    this.array = []
  }
  addAll(t) {
    for (const e of t) this.array.push(e)
  }
  set(t, e) {
    const n = this.array[t]
    return (this.array[t] = e), n
  }
  iterator() {
    return new jc(this)
  }
  get(t) {
    if (t < 0 || t >= this.size()) throw new Hc()
    return this.array[t]
  }
  isEmpty() {
    return 0 === this.array.length
  }
  sort(t) {
    t ? this.array.sort((e, n) => t.compare(e, n)) : this.array.sort()
  }
  size() {
    return this.array.length
  }
  toArray() {
    return this.array.slice()
  }
  remove(t) {
    for (let e = 0, n = this.array.length; e < n; e++)
      if (this.array[e] === t) return !!this.array.splice(e, 1)
    return !1
  }
  [Symbol.iterator]() {
    return this.array.values()
  }
}
class jc {
  constructor(t) {
    ;(this.arrayList = t), (this.position = 0)
  }
  next() {
    if (this.position === this.arrayList.size()) throw new Wc()
    return this.arrayList.get(this.position++)
  }
  hasNext() {
    return this.position < this.arrayList.size()
  }
  set(t) {
    return this.arrayList.set(this.position - 1, t)
  }
  remove() {
    this.arrayList.remove(this.arrayList.get(this.position))
  }
}
class qc extends Yc {
  constructor() {
    super(), qc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (0 === arguments.length);
    else if (1 === arguments.length) {
      const t = arguments[0]
      this.ensureCapacity(t.length), this.add(t, !0)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.ensureCapacity(t.length), this.add(t, e)
    }
  }
  getCoordinate(t) {
    return this.get(t)
  }
  addAll() {
    if (2 === arguments.length && 'boolean' == typeof arguments[1] && Uc(arguments[0], Vc)) {
      const t = arguments[1]
      let e = !1
      for (let n = arguments[0].iterator(); n.hasNext(); ) this.add(n.next(), t), (e = !0)
      return e
    }
    return super.addAll.apply(this, arguments)
  }
  clone() {
    const t = super.clone.call(this)
    for (let e = 0; e < this.size(); e++) t.add(e, this.get(e).clone())
    return t
  }
  toCoordinateArray() {
    if (0 === arguments.length) return this.toArray(qc.coordArrayType)
    if (1 === arguments.length) {
      if (arguments[0]) return this.toArray(qc.coordArrayType)
      const t = this.size(),
        e = new Array(t).fill(null)
      for (let n = 0; n < t; n++) e[n] = this.get(t - n - 1)
      return e
    }
  }
  add() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return super.add.call(this, t)
    }
    if (2 === arguments.length) {
      if (arguments[0] instanceof Array && 'boolean' == typeof arguments[1]) {
        const t = arguments[0],
          e = arguments[1]
        return this.add(t, e, !0), !0
      }
      if (arguments[0] instanceof Oc && 'boolean' == typeof arguments[1]) {
        const t = arguments[0]
        if (!arguments[1] && this.size() >= 1) {
          if (this.get(this.size() - 1).equals2D(t)) return null
        }
        super.add.call(this, t)
      } else if (arguments[0] instanceof Object && 'boolean' == typeof arguments[1]) {
        const t = arguments[0],
          e = arguments[1]
        return this.add(t, e), !0
      }
    } else if (3 === arguments.length) {
      if (
        'boolean' == typeof arguments[2] &&
        arguments[0] instanceof Array &&
        'boolean' == typeof arguments[1]
      ) {
        const t = arguments[0],
          e = arguments[1]
        if (arguments[2]) for (let n = 0; n < t.length; n++) this.add(t[n], e)
        else for (let n = t.length - 1; n >= 0; n--) this.add(t[n], e)
        return !0
      }
      if (
        'boolean' == typeof arguments[2] &&
        Number.isInteger(arguments[0]) &&
        arguments[1] instanceof Oc
      ) {
        const t = arguments[0],
          e = arguments[1]
        if (!arguments[2]) {
          const n = this.size()
          if (n > 0) {
            if (t > 0) {
              if (this.get(t - 1).equals2D(e)) return null
            }
            if (t < n) {
              if (this.get(t).equals2D(e)) return null
            }
          }
        }
        super.add.call(this, t, e)
      }
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      let s = 1
      n > i && (s = -1)
      for (let r = n; r !== i; r += s) this.add(t[r], e)
      return !0
    }
  }
  closeRing() {
    if (this.size() > 0) {
      const t = this.get(0).copy()
      this.add(t, !1)
    }
  }
}
qc.coordArrayType = new Array(0).fill(null)
class Zc {
  filter(t, e) {}
  isDone() {}
  isGeometryChanged() {}
}
class Xc {
  constructor() {
    Xc.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._minx = null),
      (this._maxx = null),
      (this._miny = null),
      (this._maxy = null),
      0 === arguments.length)
    )
      this.init()
    else if (1 === arguments.length) {
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        this.init(t.x, t.x, t.y, t.y)
      } else if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        this.init(t)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.init(t.x, e.x, t.y, e.y)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      this.init(t, e, n, i)
    }
  }
  static intersects() {
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return (
        n.x >= (t.x < e.x ? t.x : e.x) &&
        n.x <= (t.x > e.x ? t.x : e.x) &&
        n.y >= (t.y < e.y ? t.y : e.y) &&
        n.y <= (t.y > e.y ? t.y : e.y)
      )
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      let s = Math.min(n.x, i.x),
        r = Math.max(n.x, i.x),
        o = Math.min(t.x, e.x),
        a = Math.max(t.x, e.x)
      return (
        !(o > r) &&
        !(a < s) &&
        ((s = Math.min(n.y, i.y)),
        (r = Math.max(n.y, i.y)),
        (o = Math.min(t.y, e.y)),
        (a = Math.max(t.y, e.y)),
        !(o > r) && !(a < s))
      )
    }
  }
  getArea() {
    return this.getWidth() * this.getHeight()
  }
  equals(t) {
    if (!(t instanceof Xc)) return !1
    const e = t
    return this.isNull()
      ? e.isNull()
      : this._maxx === e.getMaxX() &&
          this._maxy === e.getMaxY() &&
          this._minx === e.getMinX() &&
          this._miny === e.getMinY()
  }
  intersection(t) {
    if (this.isNull() || t.isNull() || !this.intersects(t)) return new Xc()
    const e = this._minx > t._minx ? this._minx : t._minx,
      n = this._miny > t._miny ? this._miny : t._miny,
      i = this._maxx < t._maxx ? this._maxx : t._maxx,
      s = this._maxy < t._maxy ? this._maxy : t._maxy
    return new Xc(e, i, n, s)
  }
  isNull() {
    return this._maxx < this._minx
  }
  getMaxX() {
    return this._maxx
  }
  covers() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        return this.covers(t.x, t.y)
      }
      if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        return (
          !this.isNull() &&
          !t.isNull() &&
          t.getMinX() >= this._minx &&
          t.getMaxX() <= this._maxx &&
          t.getMinY() >= this._miny &&
          t.getMaxY() <= this._maxy
        )
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return (
        !this.isNull() && t >= this._minx && t <= this._maxx && e >= this._miny && e <= this._maxy
      )
    }
  }
  intersects() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        return (
          !this.isNull() &&
          !t.isNull() &&
          !(
            t._minx > this._maxx ||
            t._maxx < this._minx ||
            t._miny > this._maxy ||
            t._maxy < this._miny
          )
        )
      }
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        return this.intersects(t.x, t.y)
      }
    } else if (2 === arguments.length) {
      if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
        const t = arguments[0],
          e = arguments[1]
        if (this.isNull()) return !1
        if ((t.x < e.x ? t.x : e.x) > this._maxx) return !1
        if ((t.x > e.x ? t.x : e.x) < this._minx) return !1
        if ((t.y < e.y ? t.y : e.y) > this._maxy) return !1
        return !((t.y > e.y ? t.y : e.y) < this._miny)
      }
      if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
        const t = arguments[0],
          e = arguments[1]
        return (
          !this.isNull() && !(t > this._maxx || t < this._minx || e > this._maxy || e < this._miny)
        )
      }
    }
  }
  getMinY() {
    return this._miny
  }
  getDiameter() {
    if (this.isNull()) return 0
    const t = this.getWidth(),
      e = this.getHeight()
    return Math.sqrt(t * t + e * e)
  }
  getMinX() {
    return this._minx
  }
  expandToInclude() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        this.expandToInclude(t.x, t.y)
      } else if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        if (t.isNull()) return null
        this.isNull()
          ? ((this._minx = t.getMinX()),
            (this._maxx = t.getMaxX()),
            (this._miny = t.getMinY()),
            (this._maxy = t.getMaxY()))
          : (t._minx < this._minx && (this._minx = t._minx),
            t._maxx > this._maxx && (this._maxx = t._maxx),
            t._miny < this._miny && (this._miny = t._miny),
            t._maxy > this._maxy && (this._maxy = t._maxy))
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.isNull()
        ? ((this._minx = t), (this._maxx = t), (this._miny = e), (this._maxy = e))
        : (t < this._minx && (this._minx = t),
          t > this._maxx && (this._maxx = t),
          e < this._miny && (this._miny = e),
          e > this._maxy && (this._maxy = e))
    }
  }
  minExtent() {
    if (this.isNull()) return 0
    const t = this.getWidth(),
      e = this.getHeight()
    return t < e ? t : e
  }
  getWidth() {
    return this.isNull() ? 0 : this._maxx - this._minx
  }
  compareTo(t) {
    const e = t
    return this.isNull()
      ? e.isNull()
        ? 0
        : -1
      : e.isNull()
        ? 1
        : this._minx < e._minx
          ? -1
          : this._minx > e._minx
            ? 1
            : this._miny < e._miny
              ? -1
              : this._miny > e._miny
                ? 1
                : this._maxx < e._maxx
                  ? -1
                  : this._maxx > e._maxx
                    ? 1
                    : this._maxy < e._maxy
                      ? -1
                      : this._maxy > e._maxy
                        ? 1
                        : 0
  }
  translate(t, e) {
    if (this.isNull()) return null
    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
  }
  copy() {
    return new Xc(this)
  }
  toString() {
    return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'
  }
  setToNull() {
    ;(this._minx = 0), (this._maxx = -1), (this._miny = 0), (this._maxy = -1)
  }
  disjoint(t) {
    return (
      !(!this.isNull() && !t.isNull()) ||
      t._minx > this._maxx ||
      t._maxx < this._minx ||
      t._miny > this._maxy ||
      t._maxy < this._miny
    )
  }
  getHeight() {
    return this.isNull() ? 0 : this._maxy - this._miny
  }
  maxExtent() {
    if (this.isNull()) return 0
    const t = this.getWidth(),
      e = this.getHeight()
    return t > e ? t : e
  }
  expandBy() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.expandBy(t, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (this.isNull()) return null
      ;(this._minx -= t),
        (this._maxx += t),
        (this._miny -= e),
        (this._maxy += e),
        (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
    }
  }
  contains() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        return this.covers(t)
      }
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        return this.covers(t)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.covers(t, e)
    }
  }
  centre() {
    return this.isNull()
      ? null
      : new Oc((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
  }
  init() {
    if (0 === arguments.length) this.setToNull()
    else if (1 === arguments.length) {
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        this.init(t.x, t.x, t.y, t.y)
      } else if (arguments[0] instanceof Xc) {
        const t = arguments[0]
        ;(this._minx = t._minx),
          (this._maxx = t._maxx),
          (this._miny = t._miny),
          (this._maxy = t._maxy)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.init(t.x, e.x, t.y, e.y)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      t < e ? ((this._minx = t), (this._maxx = e)) : ((this._minx = e), (this._maxx = t)),
        n < i ? ((this._miny = n), (this._maxy = i)) : ((this._miny = i), (this._maxy = n))
    }
  }
  getMaxY() {
    return this._maxy
  }
  distance(t) {
    if (this.intersects(t)) return 0
    let e = 0
    this._maxx < t._minx
      ? (e = t._minx - this._maxx)
      : this._minx > t._maxx && (e = this._minx - t._maxx)
    let n = 0
    return (
      this._maxy < t._miny
        ? (n = t._miny - this._maxy)
        : this._miny > t._maxy && (n = this._miny - t._maxy),
      0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
    )
  }
  hashCode() {
    let t = 17
    return (
      (t = 37 * t + Oc.hashCode(this._minx)),
      (t = 37 * t + Oc.hashCode(this._maxx)),
      (t = 37 * t + Oc.hashCode(this._miny)),
      (t = 37 * t + Oc.hashCode(this._maxy)),
      t
    )
  }
  get interfaces_() {
    return [Sc, Ic]
  }
}
class Kc {
  constructor(t) {
    this.str = t
  }
  append(t) {
    this.str += t
  }
  setCharAt(t, e) {
    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
  }
  toString() {
    return this.str
  }
}
class Jc {
  constructor(t) {
    this.value = t
  }
  intValue() {
    return this.value
  }
  compareTo(t) {
    return this.value < t ? -1 : this.value > t ? 1 : 0
  }
  static compare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
  }
  static isNan(t) {
    return Number.isNaN(t)
  }
  static valueOf(t) {
    return new Jc(t)
  }
}
class Qc {
  static isWhitespace(t) {
    return (t <= 32 && t >= 0) || 127 === t
  }
  static toUpperCase(t) {
    return t.toUpperCase()
  }
}
class $c {
  constructor() {
    $c.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._hi = 0), (this._lo = 0), 0 === arguments.length)) this.init(0)
    else if (1 === arguments.length) {
      if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        this.init(t)
      } else if (arguments[0] instanceof $c) {
        const t = arguments[0]
        this.init(t)
      } else if ('string' == typeof arguments[0]) {
        const t = arguments[0]
        $c.constructor_.call(this, $c.parse(t))
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.init(t, e)
    }
  }
  static determinant() {
    if (
      'number' == typeof arguments[3] &&
      'number' == typeof arguments[2] &&
      'number' == typeof arguments[0] &&
      'number' == typeof arguments[1]
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      return $c.determinant($c.valueOf(t), $c.valueOf(e), $c.valueOf(n), $c.valueOf(i))
    }
    if (
      arguments[3] instanceof $c &&
      arguments[2] instanceof $c &&
      arguments[0] instanceof $c &&
      arguments[1] instanceof $c
    ) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3]
      return arguments[0].multiply(n).selfSubtract(t.multiply(e))
    }
  }
  static sqr(t) {
    return $c.valueOf(t).selfMultiply(t)
  }
  static valueOf() {
    if ('string' == typeof arguments[0]) {
      const t = arguments[0]
      return $c.parse(t)
    }
    if ('number' == typeof arguments[0]) {
      return new $c(arguments[0])
    }
  }
  static sqrt(t) {
    return $c.valueOf(t).sqrt()
  }
  static parse(t) {
    let e = 0
    const n = t.length
    for (; Qc.isWhitespace(t.charAt(e)); ) e++
    let i = !1
    if (e < n) {
      const n = t.charAt(e)
      ;('-' !== n && '+' !== n) || (e++, '-' === n && (i = !0))
    }
    const s = new $c()
    let r = 0,
      o = 0,
      a = 0,
      l = !1
    for (; !(e >= n); ) {
      const n = t.charAt(e)
      if ((e++, Qc.isDigit(n))) {
        const t = n - '0'
        s.selfMultiply($c.TEN), s.selfAdd(t), r++
      } else {
        if ('.' !== n) {
          if ('e' === n || 'E' === n) {
            const n = t.substring(e)
            try {
              a = Jc.parseInt(n)
            } catch (e) {
              throw e instanceof NumberFormatException
                ? new NumberFormatException('Invalid exponent ' + n + ' in string ' + t)
                : e
            }
            break
          }
          throw new NumberFormatException(
            "Unexpected character '" + n + "' at position " + e + ' in string ' + t
          )
        }
        ;(o = r), (l = !0)
      }
    }
    let h = s
    l || (o = r)
    const c = r - o - a
    if (0 === c) h = s
    else if (c > 0) {
      const t = $c.TEN.pow(c)
      h = s.divide(t)
    } else if (c < 0) {
      const t = $c.TEN.pow(-c)
      h = s.multiply(t)
    }
    return i ? h.negate() : h
  }
  static createNaN() {
    return new $c(Mc.NaN, Mc.NaN)
  }
  static copy(t) {
    return new $c(t)
  }
  static magnitude(t) {
    const e = Math.abs(t),
      n = Math.log(e) / Math.log(10)
    let i = Math.trunc(Math.floor(n))
    return 10 * Math.pow(10, i) <= e && (i += 1), i
  }
  static stringOfChar(t, e) {
    const n = new Kc()
    for (let i = 0; i < e; i++) n.append(t)
    return n.toString()
  }
  le(t) {
    return this._hi < t._hi || (this._hi === t._hi && this._lo <= t._lo)
  }
  extractSignificantDigits(t, e) {
    let n = this.abs(),
      i = $c.magnitude(n._hi)
    const s = $c.TEN.pow(i)
    ;(n = n.divide(s)),
      n.gt($c.TEN)
        ? ((n = n.divide($c.TEN)), (i += 1))
        : n.lt($c.ONE) && ((n = n.multiply($c.TEN)), (i -= 1))
    const r = i + 1,
      o = new Kc(),
      a = $c.MAX_PRINT_DIGITS - 1
    for (let e = 0; e <= a; e++) {
      t && e === r && o.append('.')
      const i = Math.trunc(n._hi)
      if (i < 0) break
      let s = !1,
        l = 0
      i > 9 ? ((s = !0), (l = '9')) : (l = '0' + i),
        o.append(l),
        (n = n.subtract($c.valueOf(i)).multiply($c.TEN)),
        s && n.selfAdd($c.TEN)
      let h = !0
      const c = $c.magnitude(n._hi)
      if ((c < 0 && Math.abs(c) >= a - e && (h = !1), !h)) break
    }
    return (e[0] = i), o.toString()
  }
  sqr() {
    return this.multiply(this)
  }
  doubleValue() {
    return this._hi + this._lo
  }
  subtract() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      return this.add(t.negate())
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return this.add(-t)
    }
  }
  equals() {
    if (1 === arguments.length && arguments[0] instanceof $c) {
      const t = arguments[0]
      return this._hi === t._hi && this._lo === t._lo
    }
  }
  isZero() {
    return 0 === this._hi && 0 === this._lo
  }
  selfSubtract() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return this.isNaN() ? this : this.selfAdd(-t, 0)
    }
  }
  getSpecialNumberString() {
    return this.isZero() ? '0.0' : this.isNaN() ? 'NaN ' : null
  }
  min(t) {
    return this.le(t) ? this : t
  }
  selfDivide() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof $c) {
        const t = arguments[0]
        return this.selfDivide(t._hi, t._lo)
      }
      if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        return this.selfDivide(t, 0)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = null,
        i = null,
        s = null,
        r = null,
        o = null,
        a = null,
        l = null,
        h = null
      return (
        (o = this._hi / t),
        (a = $c.SPLIT * o),
        (n = a - o),
        (h = $c.SPLIT * t),
        (n = a - n),
        (i = o - n),
        (s = h - t),
        (l = o * t),
        (s = h - s),
        (r = t - s),
        (h = n * s - l + n * r + i * s + i * r),
        (a = (this._hi - l - h + this._lo - o * e) / t),
        (h = o + a),
        (this._hi = h),
        (this._lo = o - h + a),
        this
      )
    }
  }
  dump() {
    return 'DD<' + this._hi + ', ' + this._lo + '>'
  }
  divide() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      let e = null,
        n = null,
        i = null,
        s = null,
        r = null,
        o = null,
        a = null,
        l = null
      ;(r = this._hi / t._hi),
        (o = $c.SPLIT * r),
        (e = o - r),
        (l = $c.SPLIT * t._hi),
        (e = o - e),
        (n = r - e),
        (i = l - t._hi),
        (a = r * t._hi),
        (i = l - i),
        (s = t._hi - i),
        (l = e * i - a + e * s + n * i + n * s),
        (o = (this._hi - a - l + this._lo - r * t._lo) / t._hi),
        (l = r + o)
      return new $c(l, r - l + o)
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return Mc.isNaN(t) ? $c.createNaN() : $c.copy(this).selfDivide(t, 0)
    }
  }
  ge(t) {
    return this._hi > t._hi || (this._hi === t._hi && this._lo >= t._lo)
  }
  pow(t) {
    if (0 === t) return $c.valueOf(1)
    let e = new $c(this),
      n = $c.valueOf(1),
      i = Math.abs(t)
    if (i > 1) for (; i > 0; ) i % 2 == 1 && n.selfMultiply(e), (i /= 2), i > 0 && (e = e.sqr())
    else n = e
    return t < 0 ? n.reciprocal() : n
  }
  ceil() {
    if (this.isNaN()) return $c.NaN
    const t = Math.ceil(this._hi)
    let e = 0
    return t === this._hi && (e = Math.ceil(this._lo)), new $c(t, e)
  }
  compareTo(t) {
    const e = t
    return this._hi < e._hi
      ? -1
      : this._hi > e._hi
        ? 1
        : this._lo < e._lo
          ? -1
          : this._lo > e._lo
            ? 1
            : 0
  }
  rint() {
    if (this.isNaN()) return this
    return this.add(0.5).floor()
  }
  setValue() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      return this.init(t), this
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return this.init(t), this
    }
  }
  max(t) {
    return this.ge(t) ? this : t
  }
  sqrt() {
    if (this.isZero()) return $c.valueOf(0)
    if (this.isNegative()) return $c.NaN
    const t = 1 / Math.sqrt(this._hi),
      e = this._hi * t,
      n = $c.valueOf(e),
      i = this.subtract(n.sqr())._hi * (0.5 * t)
    return n.add(i)
  }
  selfAdd() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof $c) {
        const t = arguments[0]
        return this.selfAdd(t._hi, t._lo)
      }
      if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        let e = null,
          n = null,
          i = null,
          s = null,
          r = null,
          o = null
        return (
          (i = this._hi + t),
          (r = i - this._hi),
          (s = i - r),
          (s = t - r + (this._hi - s)),
          (o = s + this._lo),
          (e = i + o),
          (n = o + (i - e)),
          (this._hi = e + n),
          (this._lo = n + (e - this._hi)),
          this
        )
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = null,
        i = null,
        s = null,
        r = null,
        o = null,
        a = null,
        l = null,
        h = null
      ;(o = this._hi + t),
        (s = this._lo + e),
        (l = o - this._hi),
        (h = s - this._lo),
        (a = o - l),
        (r = s - h),
        (a = t - l + (this._hi - a)),
        (r = e - h + (this._lo - r)),
        (l = a + s),
        (n = o + l),
        (i = l + (o - n)),
        (l = r + i)
      const c = n + l,
        u = l + (n - c)
      return (this._hi = c), (this._lo = u), this
    }
  }
  selfMultiply() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof $c) {
        const t = arguments[0]
        return this.selfMultiply(t._hi, t._lo)
      }
      if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        return this.selfMultiply(t, 0)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = null,
        i = null,
        s = null,
        r = null,
        o = null,
        a = null
      ;(o = $c.SPLIT * this._hi),
        (n = o - this._hi),
        (a = $c.SPLIT * t),
        (n = o - n),
        (i = this._hi - n),
        (s = a - t),
        (o = this._hi * t),
        (s = a - s),
        (r = t - s),
        (a = n * s - o + n * r + i * s + i * r + (this._hi * e + this._lo * t))
      const l = o + a
      n = o - l
      const h = a + n
      return (this._hi = l), (this._lo = h), this
    }
  }
  selfSqr() {
    return this.selfMultiply(this)
  }
  floor() {
    if (this.isNaN()) return $c.NaN
    const t = Math.floor(this._hi)
    let e = 0
    return t === this._hi && (e = Math.floor(this._lo)), new $c(t, e)
  }
  negate() {
    return this.isNaN() ? this : new $c(-this._hi, -this._lo)
  }
  clone() {
    try {
      return null
    } catch (t) {
      if (t instanceof CloneNotSupportedException) return null
      throw t
    }
  }
  multiply() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      return t.isNaN() ? $c.createNaN() : $c.copy(this).selfMultiply(t)
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return Mc.isNaN(t) ? $c.createNaN() : $c.copy(this).selfMultiply(t, 0)
    }
  }
  isNaN() {
    return Mc.isNaN(this._hi)
  }
  intValue() {
    return Math.trunc(this._hi)
  }
  toString() {
    const t = $c.magnitude(this._hi)
    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
  }
  toStandardNotation() {
    const t = this.getSpecialNumberString()
    if (null !== t) return t
    const e = new Array(1).fill(null),
      n = this.extractSignificantDigits(!0, e),
      i = e[0] + 1
    let s = n
    if ('.' === n.charAt(0)) s = '0' + n
    else if (i < 0) s = '0.' + $c.stringOfChar('0', -i) + n
    else if (-1 === n.indexOf('.')) {
      const t = i - n.length
      s = n + $c.stringOfChar('0', t) + '.0'
    }
    return this.isNegative() ? '-' + s : s
  }
  reciprocal() {
    let t = null,
      e = null,
      n = null,
      i = null,
      s = null,
      r = null,
      o = null,
      a = null
    ;(s = 1 / this._hi),
      (r = $c.SPLIT * s),
      (t = r - s),
      (a = $c.SPLIT * this._hi),
      (t = r - t),
      (e = s - t),
      (n = a - this._hi),
      (o = s * this._hi),
      (n = a - n),
      (i = this._hi - n),
      (a = t * n - o + t * i + e * n + e * i),
      (r = (1 - o - a - s * this._lo) / this._hi)
    const l = s + r
    return new $c(l, s - l + r)
  }
  toSciNotation() {
    if (this.isZero()) return $c.SCI_NOT_ZERO
    const t = this.getSpecialNumberString()
    if (null !== t) return t
    const e = new Array(1).fill(null),
      n = this.extractSignificantDigits(!1, e),
      i = $c.SCI_NOT_EXPONENT_CHAR + e[0]
    if ('0' === n.charAt(0)) throw new IllegalStateException('Found leading zero: ' + n)
    let s = ''
    n.length > 1 && (s = n.substring(1))
    const r = n.charAt(0) + '.' + s
    return this.isNegative() ? '-' + r + i : r + i
  }
  abs() {
    return this.isNaN() ? $c.NaN : this.isNegative() ? this.negate() : new $c(this)
  }
  isPositive() {
    return this._hi > 0 || (0 === this._hi && this._lo > 0)
  }
  lt(t) {
    return this._hi < t._hi || (this._hi === t._hi && this._lo < t._lo)
  }
  add() {
    if (arguments[0] instanceof $c) {
      const t = arguments[0]
      return $c.copy(this).selfAdd(t)
    }
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      return $c.copy(this).selfAdd(t)
    }
  }
  init() {
    if (1 === arguments.length) {
      if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        ;(this._hi = t), (this._lo = 0)
      } else if (arguments[0] instanceof $c) {
        const t = arguments[0]
        ;(this._hi = t._hi), (this._lo = t._lo)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._hi = t), (this._lo = e)
    }
  }
  gt(t) {
    return this._hi > t._hi || (this._hi === t._hi && this._lo > t._lo)
  }
  isNegative() {
    return this._hi < 0 || (0 === this._hi && this._lo < 0)
  }
  trunc() {
    return this.isNaN() ? $c.NaN : this.isPositive() ? this.floor() : this.ceil()
  }
  signum() {
    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0
  }
  get interfaces_() {
    return [Ic, Sc, Ac]
  }
}
;($c.PI = new $c(3.141592653589793, 12246467991473532e-32)),
  ($c.TWO_PI = new $c(6.283185307179586, 24492935982947064e-32)),
  ($c.PI_2 = new $c(1.5707963267948966, 6123233995736766e-32)),
  ($c.E = new $c(2.718281828459045, 14456468917292502e-32)),
  ($c.NaN = new $c(Mc.NaN, Mc.NaN)),
  ($c.EPS = 123259516440783e-46),
  ($c.SPLIT = 134217729),
  ($c.MAX_PRINT_DIGITS = 32),
  ($c.TEN = $c.valueOf(10)),
  ($c.ONE = $c.valueOf(1)),
  ($c.SCI_NOT_EXPONENT_CHAR = 'E'),
  ($c.SCI_NOT_ZERO = '0.0E0')
class tu {
  static orientationIndex(t, e, n) {
    const i = tu.orientationIndexFilter(t, e, n)
    if (i <= 1) return i
    const s = $c.valueOf(e.x).selfAdd(-t.x),
      r = $c.valueOf(e.y).selfAdd(-t.y),
      o = $c.valueOf(n.x).selfAdd(-e.x),
      a = $c.valueOf(n.y).selfAdd(-e.y)
    return s.selfMultiply(a).selfSubtract(r.selfMultiply(o)).signum()
  }
  static signOfDet2x2() {
    if (
      arguments[3] instanceof $c &&
      arguments[2] instanceof $c &&
      arguments[0] instanceof $c &&
      arguments[1] instanceof $c
    ) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3]
      return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum()
    }
    if (
      'number' == typeof arguments[3] &&
      'number' == typeof arguments[2] &&
      'number' == typeof arguments[0] &&
      'number' == typeof arguments[1]
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = $c.valueOf(t),
        r = $c.valueOf(e),
        o = $c.valueOf(n),
        a = $c.valueOf(i)
      return s.multiply(a).selfSubtract(r.multiply(o)).signum()
    }
  }
  static intersection(t, e, n, i) {
    const s = new $c(t.y).selfSubtract(e.y),
      r = new $c(e.x).selfSubtract(t.x),
      o = new $c(t.x).selfMultiply(e.y).selfSubtract(new $c(e.x).selfMultiply(t.y)),
      a = new $c(n.y).selfSubtract(i.y),
      l = new $c(i.x).selfSubtract(n.x),
      h = new $c(n.x).selfMultiply(i.y).selfSubtract(new $c(i.x).selfMultiply(n.y)),
      c = r.multiply(h).selfSubtract(l.multiply(o)),
      u = a.multiply(o).selfSubtract(s.multiply(h)),
      d = s.multiply(l).selfSubtract(a.multiply(r)),
      p = c.selfDivide(d).doubleValue(),
      g = u.selfDivide(d).doubleValue()
    return Mc.isNaN(p) || Mc.isInfinite(p) || Mc.isNaN(g) || Mc.isInfinite(g) ? null : new Oc(p, g)
  }
  static orientationIndexFilter(t, e, n) {
    let i = null
    const s = (t.x - n.x) * (e.y - n.y),
      r = (t.y - n.y) * (e.x - n.x),
      o = s - r
    if (s > 0) {
      if (r <= 0) return tu.signum(o)
      i = s + r
    } else {
      if (!(s < 0)) return tu.signum(o)
      if (r >= 0) return tu.signum(o)
      i = -s - r
    }
    const a = tu.DP_SAFE_EPSILON * i
    return o >= a || -o >= a ? tu.signum(o) : 2
  }
  static signum(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
  }
}
tu.DP_SAFE_EPSILON = 1e-15
class eu {
  getM(t) {
    if (this.hasM()) {
      const e = this.getDimension() - this.getMeasures()
      return this.getOrdinate(t, e)
    }
    return Mc.NaN
  }
  setOrdinate(t, e, n) {}
  getZ(t) {
    return this.hasZ() ? this.getOrdinate(t, 2) : Mc.NaN
  }
  size() {}
  getOrdinate(t, e) {}
  getCoordinate() {}
  getCoordinateCopy(t) {}
  createCoordinate() {}
  getDimension() {}
  hasM() {
    return this.getMeasures() > 0
  }
  getX(t) {}
  hasZ() {
    return this.getDimension() - this.getMeasures() > 2
  }
  getMeasures() {
    return 0
  }
  expandEnvelope(t) {}
  copy() {}
  getY(t) {}
  toCoordinateArray() {}
  get interfaces_() {
    return [Ac]
  }
}
;(eu.X = 0), (eu.Y = 1), (eu.Z = 2), (eu.M = 3)
class nu {
  static index(t, e, n) {
    return tu.orientationIndex(t, e, n)
  }
  static isCCW() {
    if (arguments[0] instanceof Array) {
      const t = arguments[0],
        e = t.length - 1
      if (e < 3) throw new Ec('Ring has fewer than 4 points, so orientation cannot be determined')
      let n = t[0],
        i = 0
      for (let s = 1; s <= e; s++) {
        const e = t[s]
        e.y > n.y && ((n = e), (i = s))
      }
      let s = i
      do {
        ;(s -= 1), s < 0 && (s = e)
      } while (t[s].equals2D(n) && s !== i)
      let r = i
      do {
        r = (r + 1) % e
      } while (t[r].equals2D(n) && r !== i)
      const o = t[s],
        a = t[r]
      if (o.equals2D(n) || a.equals2D(n) || o.equals2D(a)) return !1
      const l = nu.index(o, n, a)
      let h = null
      return (h = 0 === l ? o.x > a.x : l > 0), h
    }
    if (Uc(arguments[0], eu)) {
      const t = arguments[0],
        e = t.size() - 1
      if (e < 3) throw new Ec('Ring has fewer than 4 points, so orientation cannot be determined')
      let n = t.getCoordinate(0),
        i = 0
      for (let s = 1; s <= e; s++) {
        const e = t.getCoordinate(s)
        e.y > n.y && ((n = e), (i = s))
      }
      let s = null,
        r = i
      do {
        ;(r -= 1), r < 0 && (r = e), (s = t.getCoordinate(r))
      } while (s.equals2D(n) && r !== i)
      let o = null,
        a = i
      do {
        ;(a = (a + 1) % e), (o = t.getCoordinate(a))
      } while (o.equals2D(n) && a !== i)
      if (s.equals2D(n) || o.equals2D(n) || s.equals2D(o)) return !1
      const l = nu.index(s, n, o)
      let h = null
      return (h = 0 === l ? s.x > o.x : l > 0), h
    }
  }
}
;(nu.CLOCKWISE = -1),
  (nu.RIGHT = nu.CLOCKWISE),
  (nu.COUNTERCLOCKWISE = 1),
  (nu.LEFT = nu.COUNTERCLOCKWISE),
  (nu.COLLINEAR = 0),
  (nu.STRAIGHT = nu.COLLINEAR)
class iu {
  static intersection(t, e, n, i) {
    const s = t.x < e.x ? t.x : e.x,
      r = t.y < e.y ? t.y : e.y,
      o = t.x > e.x ? t.x : e.x,
      a = t.y > e.y ? t.y : e.y,
      l = n.x < i.x ? n.x : i.x,
      h = n.y < i.y ? n.y : i.y,
      c = n.x > i.x ? n.x : i.x,
      u = n.y > i.y ? n.y : i.y,
      d = ((s > l ? s : l) + (o < c ? o : c)) / 2,
      p = ((r > h ? r : h) + (a < u ? a : u)) / 2,
      g = t.x - d,
      f = t.y - p,
      m = e.x - d,
      y = e.y - p,
      x = n.x - d,
      v = n.y - p,
      _ = i.x - d,
      w = i.y - p,
      E = f - y,
      b = m - g,
      M = g * y - m * f,
      S = v - w,
      A = _ - x,
      T = x * w - _ * v,
      I = E * A - S * b,
      R = (b * T - A * M) / I,
      L = (S * M - E * T) / I
    return Mc.isNaN(R) || Mc.isInfinite(R) || Mc.isNaN(L) || Mc.isInfinite(L)
      ? null
      : new Oc(R + d, L + p)
  }
}
class su {
  static arraycopy(t, e, n, i, s) {
    let r = 0
    for (let o = e; o < e + s; o++) (n[i + r] = t[o]), r++
  }
  static getProperty(t) {
    return { 'line.separator': '\n' }[t]
  }
}
class ru {
  static log10(t) {
    const e = Math.log(t)
    return Mc.isInfinite(e) || Mc.isNaN(e) ? e : e / ru.LOG_10
  }
  static min(t, e, n, i) {
    let s = t
    return e < s && (s = e), n < s && (s = n), i < s && (s = i), s
  }
  static clamp() {
    if (
      'number' == typeof arguments[2] &&
      'number' == typeof arguments[0] &&
      'number' == typeof arguments[1]
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return t < e ? e : t > n ? n : t
    }
    if (
      Number.isInteger(arguments[2]) &&
      Number.isInteger(arguments[0]) &&
      Number.isInteger(arguments[1])
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return t < e ? e : t > n ? n : t
    }
  }
  static wrap(t, e) {
    return t < 0 ? e - (-t % e) : t % e
  }
  static max() {
    if (3 === arguments.length) {
      const t = arguments[1],
        e = arguments[2]
      let n = arguments[0]
      return t > n && (n = t), e > n && (n = e), n
    }
    if (4 === arguments.length) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3]
      let i = arguments[0]
      return t > i && (i = t), e > i && (i = e), n > i && (i = n), i
    }
  }
  static average(t, e) {
    return (t + e) / 2
  }
}
ru.LOG_10 = Math.log(10)
class ou {
  static segmentToSegment(t, e, n, i) {
    if (t.equals(e)) return ou.pointToSegment(t, n, i)
    if (n.equals(i)) return ou.pointToSegment(i, t, e)
    let s = !1
    if (Xc.intersects(t, e, n, i)) {
      const r = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x)
      if (0 === r) s = !0
      else {
        const o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),
          a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / r,
          l = o / r
        ;(l < 0 || l > 1 || a < 0 || a > 1) && (s = !0)
      }
    } else s = !0
    return s
      ? ru.min(
          ou.pointToSegment(t, n, i),
          ou.pointToSegment(e, n, i),
          ou.pointToSegment(n, t, e),
          ou.pointToSegment(i, t, e)
        )
      : 0
  }
  static pointToSegment(t, e, n) {
    if (e.x === n.x && e.y === n.y) return t.distance(e)
    const i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
      s = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / i
    if (s <= 0) return t.distance(e)
    if (s >= 1) return t.distance(n)
    const r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i
    return Math.abs(r) * Math.sqrt(i)
  }
  static pointToLinePerpendicular(t, e, n) {
    const i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
      s = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i
    return Math.abs(s) * Math.sqrt(i)
  }
  static pointToSegmentString(t, e) {
    if (0 === e.length) throw new Ec('Line array must contain at least one vertex')
    let n = t.distance(e[0])
    for (let i = 0; i < e.length - 1; i++) {
      const s = ou.pointToSegment(t, e[i], e[i + 1])
      s < n && (n = s)
    }
    return n
  }
}
class au {
  create() {
    if (1 === arguments.length) arguments[0] instanceof Array || Uc(arguments[0], eu)
    else if (2 === arguments.length);
    else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.create(t, e)
    }
  }
}
class lu {
  filter(t) {}
}
class hu {
  constructor() {
    hu.constructor_.apply(this, arguments)
  }
  isGeometryCollection() {
    return this.getTypeCode() === hu.TYPECODE_GEOMETRYCOLLECTION
  }
  getFactory() {
    return this._factory
  }
  getGeometryN(t) {
    return this
  }
  getArea() {
    return 0
  }
  isRectangle() {
    return !1
  }
  equalsExact(t) {
    return this === t || this.equalsExact(t, 0)
  }
  geometryChanged() {
    this.apply(hu.geometryChangedFilter)
  }
  geometryChangedAction() {
    this._envelope = null
  }
  equalsNorm(t) {
    return null !== t && this.norm().equalsExact(t.norm())
  }
  getLength() {
    return 0
  }
  getNumGeometries() {
    return 1
  }
  compareTo() {
    let t
    if (1 === arguments.length) {
      const e = arguments[0]
      return (
        (t = e),
        this.getTypeCode() !== t.getTypeCode()
          ? this.getTypeCode() - t.getTypeCode()
          : this.isEmpty() && t.isEmpty()
            ? 0
            : this.isEmpty()
              ? -1
              : t.isEmpty()
                ? 1
                : this.compareToSameClass(e)
      )
    }
    if (2 === arguments.length) {
      const e = arguments[0],
        n = arguments[1]
      return (
        (t = e),
        this.getTypeCode() !== t.getTypeCode()
          ? this.getTypeCode() - t.getTypeCode()
          : this.isEmpty() && t.isEmpty()
            ? 0
            : this.isEmpty()
              ? -1
              : t.isEmpty()
                ? 1
                : this.compareToSameClass(e, n)
      )
    }
  }
  getUserData() {
    return this._userData
  }
  getSRID() {
    return this._SRID
  }
  getEnvelope() {
    return this.getFactory().toGeometry(this.getEnvelopeInternal())
  }
  checkNotGeometryCollection(t) {
    if (t.getTypeCode() === hu.TYPECODE_GEOMETRYCOLLECTION)
      throw new Ec('This method does not support GeometryCollection arguments')
  }
  equal(t, e, n) {
    return 0 === n ? t.equals(e) : t.distance(e) <= n
  }
  norm() {
    const t = this.copy()
    return t.normalize(), t
  }
  reverse() {
    const t = this.reverseInternal()
    return (
      null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t
    )
  }
  copy() {
    const t = this.copyInternal()
    return (
      (t.envelope = null == this._envelope ? null : this._envelope.copy()),
      (t._SRID = this._SRID),
      (t._userData = this._userData),
      t
    )
  }
  getPrecisionModel() {
    return this._factory.getPrecisionModel()
  }
  getEnvelopeInternal() {
    return (
      null === this._envelope && (this._envelope = this.computeEnvelopeInternal()),
      new Xc(this._envelope)
    )
  }
  setSRID(t) {
    this._SRID = t
  }
  setUserData(t) {
    this._userData = t
  }
  compare(t, e) {
    const n = t.iterator(),
      i = e.iterator()
    for (; n.hasNext() && i.hasNext(); ) {
      const t = n.next(),
        e = i.next(),
        s = t.compareTo(e)
      if (0 !== s) return s
    }
    return n.hasNext() ? 1 : i.hasNext() ? -1 : 0
  }
  hashCode() {
    return this.getEnvelopeInternal().hashCode()
  }
  isEquivalentClass(t) {
    return this.getClass() === t.getClass()
  }
  isGeometryCollectionOrDerived() {
    return (
      this.getTypeCode() === hu.TYPECODE_GEOMETRYCOLLECTION ||
      this.getTypeCode() === hu.TYPECODE_MULTIPOINT ||
      this.getTypeCode() === hu.TYPECODE_MULTILINESTRING ||
      this.getTypeCode() === hu.TYPECODE_MULTIPOLYGON
    )
  }
  get interfaces_() {
    return [Ac, Sc, Ic]
  }
  getClass() {
    return hu
  }
  static hasNonEmptyElements(t) {
    for (let e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0
    return !1
  }
  static hasNullElements(t) {
    for (let e = 0; e < t.length; e++) if (null === t[e]) return !0
    return !1
  }
}
;(hu.constructor_ = function (t) {
  t &&
    ((this._envelope = null),
    (this._userData = null),
    (this._factory = t),
    (this._SRID = t.getSRID()))
}),
  (hu.TYPECODE_POINT = 0),
  (hu.TYPECODE_MULTIPOINT = 1),
  (hu.TYPECODE_LINESTRING = 2),
  (hu.TYPECODE_LINEARRING = 3),
  (hu.TYPECODE_MULTILINESTRING = 4),
  (hu.TYPECODE_POLYGON = 5),
  (hu.TYPECODE_MULTIPOLYGON = 6),
  (hu.TYPECODE_GEOMETRYCOLLECTION = 7),
  (hu.TYPENAME_POINT = 'Point'),
  (hu.TYPENAME_MULTIPOINT = 'MultiPoint'),
  (hu.TYPENAME_LINESTRING = 'LineString'),
  (hu.TYPENAME_LINEARRING = 'LinearRing'),
  (hu.TYPENAME_MULTILINESTRING = 'MultiLineString'),
  (hu.TYPENAME_POLYGON = 'Polygon'),
  (hu.TYPENAME_MULTIPOLYGON = 'MultiPolygon'),
  (hu.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection'),
  (hu.geometryChangedFilter = {
    get interfaces_() {
      return [lu]
    },
    filter(t) {
      t.geometryChangedAction()
    }
  })
class cu {
  filter(t) {}
}
class uu {}
class du {
  static copyCoord(t, e, n, i) {
    const s = Math.min(t.getDimension(), n.getDimension())
    for (let r = 0; r < s; r++) n.setOrdinate(i, r, t.getOrdinate(e, r))
  }
  static isRing(t) {
    const e = t.size()
    return (
      0 === e ||
      (!(e <= 3) &&
        t.getOrdinate(0, eu.X) === t.getOrdinate(e - 1, eu.X) &&
        t.getOrdinate(0, eu.Y) === t.getOrdinate(e - 1, eu.Y))
    )
  }
  static scroll() {
    if (2 === arguments.length) {
      if (Uc(arguments[0], eu) && Number.isInteger(arguments[1])) {
        const t = arguments[0],
          e = arguments[1]
        du.scroll(t, e, du.isRing(t))
      } else if (Uc(arguments[0], eu) && arguments[1] instanceof Oc) {
        const t = arguments[0],
          e = arguments[1],
          n = du.indexOf(e, t)
        if (n <= 0) return null
        du.scroll(t, n)
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (e <= 0) return null
      const i = t.copy(),
        s = n ? t.size() - 1 : t.size()
      for (let n = 0; n < s; n++)
        for (let r = 0; r < t.getDimension(); r++)
          t.setOrdinate(n, r, i.getOrdinate((e + n) % s, r))
      if (n) for (let e = 0; e < t.getDimension(); e++) t.setOrdinate(s, e, t.getOrdinate(0, e))
    }
  }
  static isEqual(t, e) {
    const n = t.size()
    if (n !== e.size()) return !1
    const i = Math.min(t.getDimension(), e.getDimension())
    for (let s = 0; s < n; s++)
      for (let n = 0; n < i; n++) {
        const i = t.getOrdinate(s, n),
          r = e.getOrdinate(s, n)
        if (t.getOrdinate(s, n) !== e.getOrdinate(s, n) && (!Mc.isNaN(i) || !Mc.isNaN(r))) return !1
      }
    return !0
  }
  static minCoordinateIndex() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return du.minCoordinateIndex(t, 0, t.size() - 1)
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[2]
      let n = -1,
        i = null
      for (let s = arguments[1]; s <= e; s++) {
        const e = t.getCoordinate(s)
        ;(null === i || i.compareTo(e) > 0) && ((i = e), (n = s))
      }
      return n
    }
  }
  static extend(t, e, n) {
    const i = t.create(n, e.getDimension()),
      s = e.size()
    if ((du.copy(e, 0, i, 0, s), s > 0)) for (let t = s; t < n; t++) du.copy(e, s - 1, i, t, 1)
    return i
  }
  static reverse(t) {
    const e = t.size() - 1,
      n = Math.trunc(e / 2)
    for (let i = 0; i <= n; i++) du.swap(t, i, e - i)
  }
  static swap(t, e, n) {
    if (e === n) return null
    for (let i = 0; i < t.getDimension(); i++) {
      const s = t.getOrdinate(e, i)
      t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, s)
    }
  }
  static copy(t, e, n, i, s) {
    for (let r = 0; r < s; r++) du.copyCoord(t, e + r, n, i + r)
  }
  static ensureValidRing(t, e) {
    const n = e.size()
    if (0 === n) return e
    if (n <= 3) return du.createClosedRing(t, e, 4)
    return e.getOrdinate(0, eu.X) === e.getOrdinate(n - 1, eu.X) &&
      e.getOrdinate(0, eu.Y) === e.getOrdinate(n - 1, eu.Y)
      ? e
      : du.createClosedRing(t, e, n + 1)
  }
  static indexOf(t, e) {
    for (let n = 0; n < e.size(); n++)
      if (t.x === e.getOrdinate(n, eu.X) && t.y === e.getOrdinate(n, eu.Y)) return n
    return -1
  }
  static createClosedRing(t, e, n) {
    const i = t.create(n, e.getDimension()),
      s = e.size()
    du.copy(e, 0, i, 0, s)
    for (let t = s; t < n; t++) du.copy(e, 0, i, t, 1)
    return i
  }
  static minCoordinate(t) {
    let e = null
    for (let n = 0; n < t.size(); n++) {
      const i = t.getCoordinate(n)
      ;(null === e || e.compareTo(i) > 0) && (e = i)
    }
    return e
  }
}
class pu extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ UnsupportedOperationException: pu })[0])
  }
}
class gu {
  static toDimensionSymbol(t) {
    switch (t) {
      case gu.FALSE:
        return gu.SYM_FALSE
      case gu.TRUE:
        return gu.SYM_TRUE
      case gu.DONTCARE:
        return gu.SYM_DONTCARE
      case gu.P:
        return gu.SYM_P
      case gu.L:
        return gu.SYM_L
      case gu.A:
        return gu.SYM_A
    }
    throw new Ec('Unknown dimension value: ' + t)
  }
  static toDimensionValue(t) {
    switch (Qc.toUpperCase(t)) {
      case gu.SYM_FALSE:
        return gu.FALSE
      case gu.SYM_TRUE:
        return gu.TRUE
      case gu.SYM_DONTCARE:
        return gu.DONTCARE
      case gu.SYM_P:
        return gu.P
      case gu.SYM_L:
        return gu.L
      case gu.SYM_A:
        return gu.A
    }
    throw new Ec('Unknown dimension symbol: ' + t)
  }
}
;(gu.P = 0),
  (gu.L = 1),
  (gu.A = 2),
  (gu.FALSE = -1),
  (gu.TRUE = -2),
  (gu.DONTCARE = -3),
  (gu.SYM_FALSE = 'F'),
  (gu.SYM_TRUE = 'T'),
  (gu.SYM_DONTCARE = '*'),
  (gu.SYM_P = '0'),
  (gu.SYM_L = '1'),
  (gu.SYM_A = '2')
class fu {
  filter(t) {}
}
class mu extends hu {
  constructor() {
    super(), mu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._points = null), 0 === arguments.length));
    else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      hu.constructor_.call(this, e), this.init(t)
    }
  }
  computeEnvelopeInternal() {
    return this.isEmpty() ? new Xc() : this._points.expandEnvelope(new Xc())
  }
  isRing() {
    return this.isClosed() && this.isSimple()
  }
  getCoordinates() {
    return this._points.toCoordinateArray()
  }
  copyInternal() {
    return new mu(this._points.copy(), this._factory)
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      if (!this.isEquivalentClass(t)) return !1
      const n = t
      if (this._points.size() !== n._points.size()) return !1
      for (let t = 0; t < this._points.size(); t++)
        if (!this.equal(this._points.getCoordinate(t), n._points.getCoordinate(t), e)) return !1
      return !0
    }
    return super.equalsExact.apply(this, arguments)
  }
  normalize() {
    for (let t = 0; t < Math.trunc(this._points.size() / 2); t++) {
      const e = this._points.size() - 1 - t
      if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {
        if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {
          const t = this._points.copy()
          du.reverse(t), (this._points = t)
        }
        return null
      }
    }
  }
  getCoordinate() {
    return this.isEmpty() ? null : this._points.getCoordinate(0)
  }
  getBoundaryDimension() {
    return this.isClosed() ? gu.FALSE : 0
  }
  isClosed() {
    return (
      !this.isEmpty() &&
      this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
    )
  }
  reverseInternal() {
    const t = this._points.copy()
    return du.reverse(t), this.getFactory().createLineString(t)
  }
  getEndPoint() {
    return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
  }
  getTypeCode() {
    return hu.TYPECODE_LINESTRING
  }
  getDimension() {
    return 1
  }
  getLength() {
    return class {
      static ofLine(t) {
        const e = t.size()
        if (e <= 1) return 0
        let n = 0
        const i = new Oc()
        t.getCoordinate(0, i)
        let s = i.x,
          r = i.y
        for (let o = 1; o < e; o++) {
          t.getCoordinate(o, i)
          const e = i.x,
            a = i.y,
            l = e - s,
            h = a - r
          ;(n += Math.sqrt(l * l + h * h)), (s = e), (r = a)
        }
        return n
      }
    }.ofLine(this._points)
  }
  getNumPoints() {
    return this._points.size()
  }
  compareToSameClass() {
    if (1 === arguments.length) {
      const t = arguments[0]
      let e = 0,
        n = 0
      for (; e < this._points.size() && n < t._points.size(); ) {
        const i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n))
        if (0 !== i) return i
        e++, n++
      }
      return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0
    }
    if (2 === arguments.length) {
      const t = arguments[0]
      return arguments[1].compare(this._points, t._points)
    }
  }
  apply() {
    if (Uc(arguments[0], cu)) {
      const t = arguments[0]
      for (let e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e))
    } else if (Uc(arguments[0], Zc)) {
      const t = arguments[0]
      if (0 === this._points.size()) return null
      for (let e = 0; e < this._points.size() && (t.filter(this._points, e), !t.isDone()); e++);
      t.isGeometryChanged() && this.geometryChanged()
    } else if (Uc(arguments[0], fu)) {
      arguments[0].filter(this)
    } else if (Uc(arguments[0], lu)) {
      arguments[0].filter(this)
    }
  }
  getBoundary() {
    throw new pu()
  }
  isEquivalentClass(t) {
    return t instanceof mu
  }
  getCoordinateN(t) {
    return this._points.getCoordinate(t)
  }
  getGeometryType() {
    return hu.TYPENAME_LINESTRING
  }
  getCoordinateSequence() {
    return this._points
  }
  isEmpty() {
    return 0 === this._points.size()
  }
  init(t) {
    if (
      (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
      1 === t.size())
    )
      throw new Ec(
        'Invalid number of points in LineString (found ' + t.size() + ' - must be 0 or >= 2)'
      )
    this._points = t
  }
  isCoordinate(t) {
    for (let e = 0; e < this._points.size(); e++)
      if (this._points.getCoordinate(e).equals(t)) return !0
    return !1
  }
  getStartPoint() {
    return this.isEmpty() ? null : this.getPointN(0)
  }
  getPointN(t) {
    return this.getFactory().createPoint(this._points.getCoordinate(t))
  }
  get interfaces_() {
    return [uu]
  }
}
class yu {}
class xu extends hu {
  constructor() {
    super(), xu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._coordinates = null
    const t = arguments[0],
      e = arguments[1]
    hu.constructor_.call(this, e), this.init(t)
  }
  computeEnvelopeInternal() {
    if (this.isEmpty()) return new Xc()
    const t = new Xc()
    return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
  }
  getCoordinates() {
    return this.isEmpty() ? [] : [this.getCoordinate()]
  }
  copyInternal() {
    return new xu(this._coordinates.copy(), this._factory)
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      return (
        !!this.isEquivalentClass(t) &&
        (!(!this.isEmpty() || !t.isEmpty()) ||
          (this.isEmpty() === t.isEmpty() &&
            this.equal(t.getCoordinate(), this.getCoordinate(), e)))
      )
    }
    return super.equalsExact.apply(this, arguments)
  }
  normalize() {}
  getCoordinate() {
    return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null
  }
  getBoundaryDimension() {
    return gu.FALSE
  }
  reverseInternal() {
    return this.getFactory().createPoint(this._coordinates.copy())
  }
  getTypeCode() {
    return hu.TYPECODE_POINT
  }
  getDimension() {
    return 0
  }
  getNumPoints() {
    return this.isEmpty() ? 0 : 1
  }
  getX() {
    if (null === this.getCoordinate()) throw new IllegalStateException('getX called on empty Point')
    return this.getCoordinate().x
  }
  compareToSameClass() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.getCoordinate().compareTo(t.getCoordinate())
    }
    if (2 === arguments.length) {
      const t = arguments[0]
      return arguments[1].compare(this._coordinates, t._coordinates)
    }
  }
  apply() {
    if (Uc(arguments[0], cu)) {
      const t = arguments[0]
      if (this.isEmpty()) return null
      t.filter(this.getCoordinate())
    } else if (Uc(arguments[0], Zc)) {
      const t = arguments[0]
      if (this.isEmpty()) return null
      t.filter(this._coordinates, 0), t.isGeometryChanged() && this.geometryChanged()
    } else if (Uc(arguments[0], fu)) {
      arguments[0].filter(this)
    } else if (Uc(arguments[0], lu)) {
      arguments[0].filter(this)
    }
  }
  getBoundary() {
    return this.getFactory().createGeometryCollection()
  }
  getGeometryType() {
    return hu.TYPENAME_POINT
  }
  getCoordinateSequence() {
    return this._coordinates
  }
  getY() {
    if (null === this.getCoordinate()) throw new IllegalStateException('getY called on empty Point')
    return this.getCoordinate().y
  }
  isEmpty() {
    return 0 === this._coordinates.size()
  }
  init(t) {
    null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
      Cc.isTrue(t.size() <= 1),
      (this._coordinates = t)
  }
  isSimple() {
    return !0
  }
  get interfaces_() {
    return [yu]
  }
}
class vu {
  static ofRing() {
    if (arguments[0] instanceof Array) {
      const t = arguments[0]
      return Math.abs(vu.ofRingSigned(t))
    }
    if (Uc(arguments[0], eu)) {
      const t = arguments[0]
      return Math.abs(vu.ofRingSigned(t))
    }
  }
  static ofRingSigned() {
    if (arguments[0] instanceof Array) {
      const t = arguments[0]
      if (t.length < 3) return 0
      let e = 0
      const n = t[0].x
      for (let i = 1; i < t.length - 1; i++) {
        const s = t[i].x - n,
          r = t[i + 1].y
        e += s * (t[i - 1].y - r)
      }
      return e / 2
    }
    if (Uc(arguments[0], eu)) {
      const t = arguments[0],
        e = t.size()
      if (e < 3) return 0
      const n = new Oc(),
        i = new Oc(),
        s = new Oc()
      t.getCoordinate(0, i), t.getCoordinate(1, s)
      const r = i.x
      s.x -= r
      let o = 0
      for (let a = 1; a < e - 1; a++)
        (n.y = i.y),
          (i.x = s.x),
          (i.y = s.y),
          t.getCoordinate(a + 1, s),
          (s.x -= r),
          (o += i.x * (n.y - s.y))
      return o / 2
    }
  }
}
class _u {
  static sort() {
    const t = arguments[0]
    if (1 === arguments.length) t.sort((t, e) => t.compareTo(e))
    else if (2 === arguments.length) t.sort((t, e) => arguments[1].compare(t, e))
    else if (3 === arguments.length) {
      const e = t.slice(arguments[1], arguments[2])
      e.sort()
      const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length))
      t.splice(0, t.length)
      for (const e of n) t.push(e)
    } else if (4 === arguments.length) {
      const e = t.slice(arguments[1], arguments[2])
      e.sort((t, e) => arguments[3].compare(t, e))
      const n = t.slice(0, arguments[1]).concat(e, t.slice(arguments[2], t.length))
      t.splice(0, t.length)
      for (const e of n) t.push(e)
    }
  }
  static asList(t) {
    const e = new Yc()
    for (const n of t) e.add(n)
    return e
  }
  static copyOf(t, e) {
    return t.slice(0, e)
  }
}
class wu {}
class Eu extends hu {
  constructor() {
    super(), Eu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._shell = null), (this._holes = null)
    let t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    if (
      (hu.constructor_.call(this, n),
      null === t && (t = this.getFactory().createLinearRing()),
      null === e && (e = []),
      hu.hasNullElements(e))
    )
      throw new Ec('holes must not contain null elements')
    if (t.isEmpty() && hu.hasNonEmptyElements(e)) throw new Ec('shell is empty but holes are not')
    ;(this._shell = t), (this._holes = e)
  }
  computeEnvelopeInternal() {
    return this._shell.getEnvelopeInternal()
  }
  getCoordinates() {
    if (this.isEmpty()) return []
    const t = new Array(this.getNumPoints()).fill(null)
    let e = -1
    const n = this._shell.getCoordinates()
    for (let i = 0; i < n.length; i++) e++, (t[e] = n[i])
    for (let n = 0; n < this._holes.length; n++) {
      const i = this._holes[n].getCoordinates()
      for (let n = 0; n < i.length; n++) e++, (t[e] = i[n])
    }
    return t
  }
  getArea() {
    let t = 0
    t += vu.ofRing(this._shell.getCoordinateSequence())
    for (let e = 0; e < this._holes.length; e++)
      t -= vu.ofRing(this._holes[e].getCoordinateSequence())
    return t
  }
  copyInternal() {
    const t = this._shell.copy(),
      e = new Array(this._holes.length).fill(null)
    for (let t = 0; t < this._holes.length; t++) e[t] = this._holes[t].copy()
    return new Eu(t, e, this._factory)
  }
  isRectangle() {
    if (0 !== this.getNumInteriorRing()) return !1
    if (null === this._shell) return !1
    if (5 !== this._shell.getNumPoints()) return !1
    const t = this._shell.getCoordinateSequence(),
      e = this.getEnvelopeInternal()
    for (let n = 0; n < 5; n++) {
      const i = t.getX(n)
      if (i !== e.getMinX() && i !== e.getMaxX()) return !1
      const s = t.getY(n)
      if (s !== e.getMinY() && s !== e.getMaxY()) return !1
    }
    let n = t.getX(0),
      i = t.getY(0)
    for (let e = 1; e <= 4; e++) {
      const s = t.getX(e),
        r = t.getY(e)
      if ((s !== n) === (r !== i)) return !1
      ;(n = s), (i = r)
    }
    return !0
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      if (!this.isEquivalentClass(t)) return !1
      const n = t,
        i = this._shell,
        s = n._shell
      if (!i.equalsExact(s, e)) return !1
      if (this._holes.length !== n._holes.length) return !1
      for (let t = 0; t < this._holes.length; t++)
        if (!this._holes[t].equalsExact(n._holes[t], e)) return !1
      return !0
    }
    return super.equalsExact.apply(this, arguments)
  }
  normalize() {
    if (0 === arguments.length) {
      this._shell = this.normalized(this._shell, !0)
      for (let t = 0; t < this._holes.length; t++)
        this._holes[t] = this.normalized(this._holes[t], !1)
      _u.sort(this._holes)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (t.isEmpty()) return null
      const n = t.getCoordinateSequence(),
        i = du.minCoordinateIndex(n, 0, n.size() - 2)
      du.scroll(n, i, !0), nu.isCCW(n) === e && du.reverse(n)
    }
  }
  getCoordinate() {
    return this._shell.getCoordinate()
  }
  getNumInteriorRing() {
    return this._holes.length
  }
  getBoundaryDimension() {
    return 1
  }
  reverseInternal() {
    const t = this.getExteriorRing().reverse(),
      e = new Array(this.getNumInteriorRing()).fill(null)
    for (let t = 0; t < e.length; t++) e[t] = this.getInteriorRingN(t).reverse()
    return this.getFactory().createPolygon(t, e)
  }
  getTypeCode() {
    return hu.TYPECODE_POLYGON
  }
  getDimension() {
    return 2
  }
  getLength() {
    let t = 0
    t += this._shell.getLength()
    for (let e = 0; e < this._holes.length; e++) t += this._holes[e].getLength()
    return t
  }
  getNumPoints() {
    let t = this._shell.getNumPoints()
    for (let e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints()
    return t
  }
  convexHull() {
    return this.getExteriorRing().convexHull()
  }
  normalized(t, e) {
    const n = t.copy()
    return this.normalize(n, e), n
  }
  compareToSameClass() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = this._shell,
        n = t._shell
      return e.compareToSameClass(n)
    }
    if (2 === arguments.length) {
      const t = arguments[1],
        e = arguments[0],
        n = this._shell,
        i = e._shell,
        s = n.compareToSameClass(i, t)
      if (0 !== s) return s
      const r = this.getNumInteriorRing(),
        o = e.getNumInteriorRing()
      let a = 0
      for (; a < r && a < o; ) {
        const n = this.getInteriorRingN(a),
          i = e.getInteriorRingN(a),
          s = n.compareToSameClass(i, t)
        if (0 !== s) return s
        a++
      }
      return a < r ? 1 : a < o ? -1 : 0
    }
  }
  apply() {
    if (Uc(arguments[0], cu)) {
      const t = arguments[0]
      this._shell.apply(t)
      for (let e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
    } else if (Uc(arguments[0], Zc)) {
      const t = arguments[0]
      if ((this._shell.apply(t), !t.isDone()))
        for (let e = 0; e < this._holes.length && (this._holes[e].apply(t), !t.isDone()); e++);
      t.isGeometryChanged() && this.geometryChanged()
    } else if (Uc(arguments[0], fu)) {
      arguments[0].filter(this)
    } else if (Uc(arguments[0], lu)) {
      const t = arguments[0]
      t.filter(this), this._shell.apply(t)
      for (let e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
    }
  }
  getBoundary() {
    if (this.isEmpty()) return this.getFactory().createMultiLineString()
    const t = new Array(this._holes.length + 1).fill(null)
    t[0] = this._shell
    for (let e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e]
    return t.length <= 1
      ? this.getFactory().createLinearRing(t[0].getCoordinateSequence())
      : this.getFactory().createMultiLineString(t)
  }
  getGeometryType() {
    return hu.TYPENAME_POLYGON
  }
  getExteriorRing() {
    return this._shell
  }
  isEmpty() {
    return this._shell.isEmpty()
  }
  getInteriorRingN(t) {
    return this._holes[t]
  }
  get interfaces_() {
    return [wu]
  }
}
class bu extends Vc {
  contains() {}
}
class Mu extends bu {}
class Su extends Mu {
  constructor(t) {
    super(), (this.array = []), t instanceof Vc && this.addAll(t)
  }
  contains(t) {
    for (const e of this.array) if (0 === e.compareTo(t)) return !0
    return !1
  }
  add(t) {
    if (this.contains(t)) return !1
    for (let e = 0, n = this.array.length; e < n; e++) {
      if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t)
    }
    return this.array.push(t), !0
  }
  addAll(t) {
    for (const e of t) this.add(e)
    return !0
  }
  remove() {
    throw new pu()
  }
  size() {
    return this.array.length
  }
  isEmpty() {
    return 0 === this.array.length
  }
  toArray() {
    return this.array.slice()
  }
  iterator() {
    return new Au(this.array)
  }
}
class Au {
  constructor(t) {
    ;(this.array = t), (this.position = 0)
  }
  next() {
    if (this.position === this.array.length) throw new Wc()
    return this.array[this.position++]
  }
  hasNext() {
    return this.position < this.array.length
  }
  remove() {
    throw new pu()
  }
}
class Tu extends hu {
  constructor() {
    super(), Tu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._geometries = null), 0 === arguments.length));
    else if (2 === arguments.length) {
      let t = arguments[0],
        e = arguments[1]
      if ((hu.constructor_.call(this, e), null === t && (t = []), hu.hasNullElements(t)))
        throw new Ec('geometries must not contain null elements')
      this._geometries = t
    }
  }
  computeEnvelopeInternal() {
    const t = new Xc()
    for (let e = 0; e < this._geometries.length; e++)
      t.expandToInclude(this._geometries[e].getEnvelopeInternal())
    return t
  }
  getGeometryN(t) {
    return this._geometries[t]
  }
  getCoordinates() {
    const t = new Array(this.getNumPoints()).fill(null)
    let e = -1
    for (let n = 0; n < this._geometries.length; n++) {
      const i = this._geometries[n].getCoordinates()
      for (let n = 0; n < i.length; n++) e++, (t[e] = i[n])
    }
    return t
  }
  getArea() {
    let t = 0
    for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea()
    return t
  }
  copyInternal() {
    const t = new Array(this._geometries.length).fill(null)
    for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy()
    return new Tu(t, this._factory)
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      if (!this.isEquivalentClass(t)) return !1
      const n = t
      if (this._geometries.length !== n._geometries.length) return !1
      for (let t = 0; t < this._geometries.length; t++)
        if (!this._geometries[t].equalsExact(n._geometries[t], e)) return !1
      return !0
    }
    return super.equalsExact.apply(this, arguments)
  }
  normalize() {
    for (let t = 0; t < this._geometries.length; t++) this._geometries[t].normalize()
    _u.sort(this._geometries)
  }
  getCoordinate() {
    return this.isEmpty() ? null : this._geometries[0].getCoordinate()
  }
  getBoundaryDimension() {
    let t = gu.FALSE
    for (let e = 0; e < this._geometries.length; e++)
      t = Math.max(t, this._geometries[e].getBoundaryDimension())
    return t
  }
  reverseInternal() {
    const t = this._geometries.length,
      e = new Yc(t)
    for (let n = 0; n < t; n++) e.add(this._geometries[n].reverse())
    return this.getFactory().buildGeometry(e)
  }
  getTypeCode() {
    return hu.TYPECODE_GEOMETRYCOLLECTION
  }
  getDimension() {
    let t = gu.FALSE
    for (let e = 0; e < this._geometries.length; e++)
      t = Math.max(t, this._geometries[e].getDimension())
    return t
  }
  getLength() {
    let t = 0
    for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength()
    return t
  }
  getNumPoints() {
    let t = 0
    for (let e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints()
    return t
  }
  getNumGeometries() {
    return this._geometries.length
  }
  compareToSameClass() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Su(_u.asList(this._geometries)),
        n = new Su(_u.asList(t._geometries))
      return this.compare(e, n)
    }
    if (2 === arguments.length) {
      const t = arguments[1],
        e = arguments[0],
        n = this.getNumGeometries(),
        i = e.getNumGeometries()
      let s = 0
      for (; s < n && s < i; ) {
        const n = this.getGeometryN(s),
          i = e.getGeometryN(s),
          r = n.compareToSameClass(i, t)
        if (0 !== r) return r
        s++
      }
      return s < n ? 1 : s < i ? -1 : 0
    }
  }
  apply() {
    if (Uc(arguments[0], cu)) {
      const t = arguments[0]
      for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
    } else if (Uc(arguments[0], Zc)) {
      const t = arguments[0]
      if (0 === this._geometries.length) return null
      for (
        let e = 0;
        e < this._geometries.length && (this._geometries[e].apply(t), !t.isDone());
        e++
      );
      t.isGeometryChanged() && this.geometryChanged()
    } else if (Uc(arguments[0], fu)) {
      const t = arguments[0]
      t.filter(this)
      for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
    } else if (Uc(arguments[0], lu)) {
      const t = arguments[0]
      t.filter(this)
      for (let e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t)
    }
  }
  getBoundary() {
    return hu.checkNotGeometryCollection(this), Cc.shouldNeverReachHere(), null
  }
  getGeometryType() {
    return hu.TYPENAME_GEOMETRYCOLLECTION
  }
  isEmpty() {
    for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1
    return !0
  }
}
class Iu extends Tu {
  constructor() {
    super(), Iu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Tu.constructor_.call(this, t, e)
  }
  copyInternal() {
    const t = new Array(this._geometries.length).fill(null)
    for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy()
    return new Iu(t, this._factory)
  }
  isValid() {
    return !0
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e)
    }
    return super.equalsExact.apply(this, arguments)
  }
  getCoordinate() {
    if (1 === arguments.length && Number.isInteger(arguments[0])) {
      const t = arguments[0]
      return this._geometries[t].getCoordinate()
    }
    return super.getCoordinate.apply(this, arguments)
  }
  getBoundaryDimension() {
    return gu.FALSE
  }
  getTypeCode() {
    return hu.TYPECODE_MULTIPOINT
  }
  getDimension() {
    return 0
  }
  getBoundary() {
    return this.getFactory().createGeometryCollection()
  }
  getGeometryType() {
    return hu.TYPENAME_MULTIPOINT
  }
  get interfaces_() {
    return [yu]
  }
}
class Ru extends mu {
  constructor() {
    super(), Ru.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    mu.constructor_.call(this, t, e), this.validateConstruction()
  }
  copyInternal() {
    return new Ru(this._points.copy(), this._factory)
  }
  getBoundaryDimension() {
    return gu.FALSE
  }
  isClosed() {
    return !!this.isEmpty() || super.isClosed.call(this)
  }
  reverseInternal() {
    const t = this._points.copy()
    return du.reverse(t), this.getFactory().createLinearRing(t)
  }
  getTypeCode() {
    return hu.TYPECODE_LINEARRING
  }
  validateConstruction() {
    if (!this.isEmpty() && !super.isClosed.call(this))
      throw new Ec('Points of LinearRing do not form a closed linestring')
    if (
      this.getCoordinateSequence().size() >= 1 &&
      this.getCoordinateSequence().size() < Ru.MINIMUM_VALID_SIZE
    )
      throw new Ec(
        'Invalid number of points in LinearRing (found ' +
          this.getCoordinateSequence().size() +
          ' - must be 0 or >= 4)'
      )
  }
  getGeometryType() {
    return hu.TYPENAME_LINEARRING
  }
}
Ru.MINIMUM_VALID_SIZE = 4
class Lu {
  static measures(t) {
    return t instanceof Gc ? 0 : t instanceof zc || t instanceof Bc ? 1 : 0
  }
  static dimension(t) {
    return t instanceof Gc ? 2 : t instanceof zc ? 3 : t instanceof Bc ? 4 : 3
  }
  static create() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Lu.create(t, 0)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return 2 === t
        ? new Gc()
        : 3 === t && 0 === e
          ? new Oc()
          : 3 === t && 1 === e
            ? new zc()
            : 4 === t && 1 === e
              ? new Bc()
              : new Oc()
    }
  }
}
class Cu {
  static isRing(t) {
    return !(t.length < 4) && !!t[0].equals2D(t[t.length - 1])
  }
  static ptNotInList(t, e) {
    for (let n = 0; n < t.length; n++) {
      const i = t[n]
      if (Cu.indexOf(i, e) < 0) return i
    }
    return null
  }
  static scroll(t, e) {
    const n = Cu.indexOf(e, t)
    if (n < 0) return null
    const i = new Array(t.length).fill(null)
    su.arraycopy(t, n, i, 0, t.length - n),
      su.arraycopy(t, 0, i, t.length - n, n),
      su.arraycopy(i, 0, t, 0, t.length)
  }
  static equals() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (t === e) return !0
      if (null === t || null === e) return !1
      if (t.length !== e.length) return !1
      for (let n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1
      return !0
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (t === e) return !0
      if (null === t || null === e) return !1
      if (t.length !== e.length) return !1
      for (let i = 0; i < t.length; i++) if (0 !== n.compare(t[i], e[i])) return !1
      return !0
    }
  }
  static intersection(t, e) {
    const n = new qc()
    for (let i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0)
    return n.toCoordinateArray()
  }
  static measures(t) {
    if (null === t || 0 === t.length) return 0
    let e = 0
    for (const n of t) e = Math.max(e, Lu.measures(n))
    return e
  }
  static hasRepeatedPoints(t) {
    for (let e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0
    return !1
  }
  static removeRepeatedPoints(t) {
    if (!Cu.hasRepeatedPoints(t)) return t
    return new qc(t, !1).toCoordinateArray()
  }
  static reverse(t) {
    const e = t.length - 1,
      n = Math.trunc(e / 2)
    for (let i = 0; i <= n; i++) {
      const n = t[i]
      ;(t[i] = t[e - i]), (t[e - i] = n)
    }
  }
  static removeNull(t) {
    let e = 0
    for (let n = 0; n < t.length; n++) null !== t[n] && e++
    const n = new Array(e).fill(null)
    if (0 === e) return n
    let i = 0
    for (let e = 0; e < t.length; e++) null !== t[e] && (n[i++] = t[e])
    return n
  }
  static copyDeep() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Array(t.length).fill(null)
      for (let n = 0; n < t.length; n++) e[n] = t[n].copy()
      return e
    }
    if (5 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4]
      for (let r = 0; r < s; r++) n[i + r] = t[e + r].copy()
    }
  }
  static isEqualReversed(t, e) {
    for (let n = 0; n < t.length; n++) {
      const i = t[n],
        s = e[t.length - n - 1]
      if (0 !== i.compareTo(s)) return !1
    }
    return !0
  }
  static envelope(t) {
    const e = new Xc()
    for (let n = 0; n < t.length; n++) e.expandToInclude(t[n])
    return e
  }
  static toCoordinateArray(t) {
    return t.toArray(Cu.coordArrayType)
  }
  static dimension(t) {
    if (null === t || 0 === t.length) return 3
    let e = 0
    for (const n of t) e = Math.max(e, Lu.dimension(n))
    return e
  }
  static atLeastNCoordinatesOrNothing(t, e) {
    return e.length >= t ? e : []
  }
  static indexOf(t, e) {
    for (let n = 0; n < e.length; n++) if (t.equals(e[n])) return n
    return -1
  }
  static increasingDirection(t) {
    for (let e = 0; e < Math.trunc(t.length / 2); e++) {
      const n = t.length - 1 - e,
        i = t[e].compareTo(t[n])
      if (0 !== i) return i
    }
    return 1
  }
  static compare(t, e) {
    let n = 0
    for (; n < t.length && n < e.length; ) {
      const i = t[n].compareTo(e[n])
      if (0 !== i) return i
      n++
    }
    return n < e.length ? -1 : n < t.length ? 1 : 0
  }
  static minCoordinate(t) {
    let e = null
    for (let n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n])
    return e
  }
  static extract(t, e, n) {
    e = ru.clamp(e, 0, t.length)
    let i = (n = ru.clamp(n, -1, t.length)) - e + 1
    n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0)
    const s = new Array(i).fill(null)
    if (0 === i) return s
    let r = 0
    for (let i = e; i <= n; i++) s[r++] = t[i]
    return s
  }
}
;(Cu.ForwardComparator = class {
  compare(t, e) {
    const n = t,
      i = e
    return Cu.compare(n, i)
  }
  get interfaces_() {
    return [Tc]
  }
}),
  (Cu.BidirectionalComparator = class {
    compare(t, e) {
      const n = t,
        i = e
      if (n.length < i.length) return -1
      if (n.length > i.length) return 1
      if (0 === n.length) return 0
      const s = Cu.compare(n, i)
      return Cu.isEqualReversed(n, i) ? 0 : s
    }
    OLDcompare(t, e) {
      const n = t,
        i = e
      if (n.length < i.length) return -1
      if (n.length > i.length) return 1
      if (0 === n.length) return 0
      const s = Cu.increasingDirection(n),
        r = Cu.increasingDirection(i)
      let o = s > 0 ? 0 : n.length - 1,
        a = r > 0 ? 0 : n.length - 1
      for (let t = 0; t < n.length; t++) {
        const t = n[o].compareTo(i[a])
        if (0 !== t) return t
        ;(o += s), (a += r)
      }
      return 0
    }
    get interfaces_() {
      return [Tc]
    }
  }),
  (Cu.coordArrayType = new Array(0).fill(null))
class Nu {
  constructor(t) {
    this.str = t
  }
  append(t) {
    this.str += t
  }
  setCharAt(t, e) {
    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
  }
  toString() {
    return this.str
  }
}
class Pu {
  constructor() {
    Pu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._dimension = 3),
      (this._measures = 0),
      (this._coordinates = null),
      1 === arguments.length)
    ) {
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        Pu.constructor_.call(this, t, Cu.dimension(t), Cu.measures(t))
      } else if (Number.isInteger(arguments[0])) {
        const t = arguments[0]
        this._coordinates = new Array(t).fill(null)
        for (let e = 0; e < t; e++) this._coordinates[e] = new Oc()
      } else if (Uc(arguments[0], eu)) {
        const t = arguments[0]
        if (null === t) return (this._coordinates = new Array(0).fill(null)), null
        ;(this._dimension = t.getDimension()),
          (this._measures = t.getMeasures()),
          (this._coordinates = new Array(t.size()).fill(null))
        for (let e = 0; e < this._coordinates.length; e++)
          this._coordinates[e] = t.getCoordinateCopy(e)
      }
    } else if (2 === arguments.length) {
      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
        const t = arguments[0],
          e = arguments[1]
        Pu.constructor_.call(this, t, e, Cu.measures(t))
      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
        const t = arguments[0],
          e = arguments[1]
        ;(this._coordinates = new Array(t).fill(null)), (this._dimension = e)
        for (let n = 0; n < t; n++) this._coordinates[n] = Lu.create(e)
      }
    } else if (3 === arguments.length)
      if (
        Number.isInteger(arguments[2]) &&
        arguments[0] instanceof Array &&
        Number.isInteger(arguments[1])
      ) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        ;(this._dimension = e),
          (this._measures = n),
          (this._coordinates = null === t ? new Array(0).fill(null) : t)
      } else if (
        Number.isInteger(arguments[2]) &&
        Number.isInteger(arguments[0]) &&
        Number.isInteger(arguments[1])
      ) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        ;(this._coordinates = new Array(t).fill(null)), (this._dimension = e), (this._measures = n)
        for (let e = 0; e < t; e++) this._coordinates[e] = this.createCoordinate()
      }
  }
  getM(t) {
    return this.hasM() ? this._coordinates[t].getM() : Mc.NaN
  }
  setOrdinate(t, e, n) {
    switch (e) {
      case eu.X:
        this._coordinates[t].x = n
        break
      case eu.Y:
        this._coordinates[t].y = n
        break
      default:
        this._coordinates[t].setOrdinate(e, n)
    }
  }
  getZ(t) {
    return this.hasZ() ? this._coordinates[t].getZ() : Mc.NaN
  }
  size() {
    return this._coordinates.length
  }
  getOrdinate(t, e) {
    switch (e) {
      case eu.X:
        return this._coordinates[t].x
      case eu.Y:
        return this._coordinates[t].y
      default:
        return this._coordinates[t].getOrdinate(e)
    }
  }
  getCoordinate() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this._coordinates[t]
    }
    if (2 === arguments.length) {
      const t = arguments[0]
      arguments[1].setCoordinate(this._coordinates[t])
    }
  }
  getCoordinateCopy(t) {
    const e = this.createCoordinate()
    return e.setCoordinate(this._coordinates[t]), e
  }
  createCoordinate() {
    return Lu.create(this.getDimension(), this.getMeasures())
  }
  getDimension() {
    return this._dimension
  }
  getX(t) {
    return this._coordinates[t].x
  }
  getMeasures() {
    return this._measures
  }
  expandEnvelope(t) {
    for (let e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e])
    return t
  }
  copy() {
    const t = new Array(this.size()).fill(null)
    for (let e = 0; e < this._coordinates.length; e++) {
      const n = this.createCoordinate()
      n.setCoordinate(this._coordinates[e]), (t[e] = n)
    }
    return new Pu(t, this._dimension, this._measures)
  }
  toString() {
    if (this._coordinates.length > 0) {
      const t = new Nu(17 * this._coordinates.length)
      t.append('('), t.append(this._coordinates[0])
      for (let e = 1; e < this._coordinates.length; e++)
        t.append(', '), t.append(this._coordinates[e])
      return t.append(')'), t.toString()
    }
    return '()'
  }
  getY(t) {
    return this._coordinates[t].y
  }
  toCoordinateArray() {
    return this._coordinates
  }
  get interfaces_() {
    return [eu, Ic]
  }
}
class Du {
  static instance() {
    return Du.instanceObject
  }
  readResolve() {
    return Du.instance()
  }
  create() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        return new Pu(arguments[0])
      }
      if (Uc(arguments[0], eu)) {
        return new Pu(arguments[0])
      }
    } else {
      if (2 === arguments.length) {
        let t = arguments[1]
        return t > 3 && (t = 3), t < 2 && (t = 2), new Pu(arguments[0], t)
      }
      if (3 === arguments.length) {
        let t = arguments[2],
          e = arguments[1] - t
        return t > 1 && (t = 1), e > 3 && (e = 3), e < 2 && (e = 2), new Pu(arguments[0], e + t, t)
      }
    }
  }
  get interfaces_() {
    return [au, Ic]
  }
}
Du.instanceObject = new Du()
class Ou extends Tu {
  constructor() {
    super(), Ou.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Tu.constructor_.call(this, t, e)
  }
  copyInternal() {
    const t = new Array(this._geometries.length).fill(null)
    for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy()
    return new Ou(t, this._factory)
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e)
    }
    return super.equalsExact.apply(this, arguments)
  }
  getBoundaryDimension() {
    return 1
  }
  getTypeCode() {
    return hu.TYPECODE_MULTIPOLYGON
  }
  getDimension() {
    return 2
  }
  getBoundary() {
    if (this.isEmpty()) return this.getFactory().createMultiLineString()
    const t = new Yc()
    for (let e = 0; e < this._geometries.length; e++) {
      const n = this._geometries[e].getBoundary()
      for (let e = 0; e < n.getNumGeometries(); e++) t.add(n.getGeometryN(e))
    }
    const e = new Array(t.size()).fill(null)
    return this.getFactory().createMultiLineString(t.toArray(e))
  }
  getGeometryType() {
    return hu.TYPENAME_MULTIPOLYGON
  }
  get interfaces_() {
    return [wu]
  }
}
class Fu {
  get() {}
  put() {}
  size() {}
  values() {}
  entrySet() {}
}
class Gu extends bu {
  constructor(t) {
    super(), (this.map = new Map()), t instanceof Vc && this.addAll(t)
  }
  contains(t) {
    const e = t.hashCode ? t.hashCode() : t
    return !!this.map.has(e)
  }
  add(t) {
    const e = t.hashCode ? t.hashCode() : t
    return !this.map.has(e) && !!this.map.set(e, t)
  }
  addAll(t) {
    for (const e of t) this.add(e)
    return !0
  }
  remove() {
    throw new pu()
  }
  size() {
    return this.map.size
  }
  isEmpty() {
    return 0 === this.map.size
  }
  toArray() {
    return Array.from(this.map.values())
  }
  iterator() {
    return new zu(this.map)
  }
  [Symbol.iterator]() {
    return this.map
  }
}
class zu {
  constructor(t) {
    this.iterator = t.values()
    const { done: e, value: n } = this.iterator.next()
    ;(this.done = e), (this.value = n)
  }
  next() {
    if (this.done) throw new Wc()
    const t = this.value,
      { done: e, value: n } = this.iterator.next()
    return (this.done = e), (this.value = n), t
  }
  hasNext() {
    return !this.done
  }
  remove() {
    throw new pu()
  }
}
class Bu extends Fu {
  constructor() {
    super(), (this.map = new Map())
  }
  get(t) {
    return this.map.get(t) || null
  }
  put(t, e) {
    return this.map.set(t, e), e
  }
  values() {
    const t = new Yc(),
      e = this.map.values()
    let n = e.next()
    for (; !n.done; ) t.add(n.value), (n = e.next())
    return t
  }
  entrySet() {
    const t = new Gu()
    return this.map.entries().forEach((e) => t.add(e)), t
  }
  size() {
    return this.map.size()
  }
}
class Uu {
  constructor() {
    Uu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._modelType = null), (this._scale = null), 0 === arguments.length))
      this._modelType = Uu.FLOATING
    else if (1 === arguments.length)
      if (arguments[0] instanceof Vu) {
        const t = arguments[0]
        ;(this._modelType = t), t === Uu.FIXED && this.setScale(1)
      } else if ('number' == typeof arguments[0]) {
        const t = arguments[0]
        ;(this._modelType = Uu.FIXED), this.setScale(t)
      } else if (arguments[0] instanceof Uu) {
        const t = arguments[0]
        ;(this._modelType = t._modelType), (this._scale = t._scale)
      }
  }
  static mostPrecise(t, e) {
    return t.compareTo(e) >= 0 ? t : e
  }
  equals(t) {
    if (!(t instanceof Uu)) return !1
    const e = t
    return this._modelType === e._modelType && this._scale === e._scale
  }
  compareTo(t) {
    const e = t,
      n = this.getMaximumSignificantDigits(),
      i = e.getMaximumSignificantDigits()
    return Jc.compare(n, i)
  }
  getScale() {
    return this._scale
  }
  isFloating() {
    return this._modelType === Uu.FLOATING || this._modelType === Uu.FLOATING_SINGLE
  }
  getType() {
    return this._modelType
  }
  toString() {
    let t = 'UNKNOWN'
    return (
      this._modelType === Uu.FLOATING
        ? (t = 'Floating')
        : this._modelType === Uu.FLOATING_SINGLE
          ? (t = 'Floating-Single')
          : this._modelType === Uu.FIXED && (t = 'Fixed (Scale=' + this.getScale() + ')'),
      t
    )
  }
  makePrecise() {
    if ('number' == typeof arguments[0]) {
      const t = arguments[0]
      if (Mc.isNaN(t)) return t
      if (this._modelType === Uu.FLOATING_SINGLE) {
        return t
      }
      return this._modelType === Uu.FIXED ? Math.round(t * this._scale) / this._scale : t
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      if (this._modelType === Uu.FLOATING) return null
      ;(t.x = this.makePrecise(t.x)), (t.y = this.makePrecise(t.y))
    }
  }
  getMaximumSignificantDigits() {
    let t = 16
    return (
      this._modelType === Uu.FLOATING
        ? (t = 16)
        : this._modelType === Uu.FLOATING_SINGLE
          ? (t = 6)
          : this._modelType === Uu.FIXED &&
            (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))),
      t
    )
  }
  setScale(t) {
    this._scale = Math.abs(t)
  }
  get interfaces_() {
    return [Ic, Sc]
  }
}
class Vu {
  constructor() {
    Vu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._name = null
    const t = arguments[0]
    ;(this._name = t), Vu.nameToTypeMap.put(t, this)
  }
  readResolve() {
    return Vu.nameToTypeMap.get(this._name)
  }
  toString() {
    return this._name
  }
  get interfaces_() {
    return [Ic]
  }
}
;(Vu.nameToTypeMap = new Bu()),
  (Uu.Type = Vu),
  (Uu.FIXED = new Vu('FIXED')),
  (Uu.FLOATING = new Vu('FLOATING')),
  (Uu.FLOATING_SINGLE = new Vu('FLOATING SINGLE')),
  (Uu.maximumPreciseValue = 9007199254740992)
class Hu extends Tu {
  constructor() {
    super(), Hu.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Tu.constructor_.call(this, t, e)
  }
  copyInternal() {
    const t = new Array(this._geometries.length).fill(null)
    for (let e = 0; e < t.length; e++) t[e] = this._geometries[e].copy()
    return new Hu(t, this._factory)
  }
  equalsExact() {
    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof hu) {
      const t = arguments[0],
        e = arguments[1]
      return !!this.isEquivalentClass(t) && super.equalsExact.call(this, t, e)
    }
    return super.equalsExact.apply(this, arguments)
  }
  getBoundaryDimension() {
    return this.isClosed() ? gu.FALSE : 0
  }
  isClosed() {
    if (this.isEmpty()) return !1
    for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1
    return !0
  }
  getTypeCode() {
    return hu.TYPECODE_MULTILINESTRING
  }
  getDimension() {
    return 1
  }
  getBoundary() {
    throw new pu()
  }
  getGeometryType() {
    return hu.TYPENAME_MULTILINESTRING
  }
  get interfaces_() {
    return [uu]
  }
}
class ku {
  constructor() {
    ku.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._precisionModel = null),
      (this._coordinateSequenceFactory = null),
      (this._SRID = null),
      0 === arguments.length)
    )
      ku.constructor_.call(this, new Uu(), 0)
    else if (1 === arguments.length) {
      if (Uc(arguments[0], au)) {
        const t = arguments[0]
        ku.constructor_.call(this, new Uu(), 0, t)
      } else if (arguments[0] instanceof Uu) {
        const t = arguments[0]
        ku.constructor_.call(this, t, 0, ku.getDefaultCoordinateSequenceFactory())
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ku.constructor_.call(this, t, e, ku.getDefaultCoordinateSequenceFactory())
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._precisionModel = t), (this._coordinateSequenceFactory = n), (this._SRID = e)
    }
  }
  static toMultiPolygonArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toGeometryArray(t) {
    if (null === t) return null
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static getDefaultCoordinateSequenceFactory() {
    return Du.instance()
  }
  static toMultiLineStringArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toLineStringArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toMultiPointArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toLinearRingArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toPointArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static toPolygonArray(t) {
    const e = new Array(t.size()).fill(null)
    return t.toArray(e)
  }
  static createPointFromInternalCoord(t, e) {
    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
  }
  createEmpty(t) {
    switch (t) {
      case -1:
        return this.createGeometryCollection()
      case 0:
        return this.createPoint()
      case 1:
        return this.createLineString()
      case 2:
        return this.createPolygon()
      default:
        throw new Ec('Invalid dimension: ' + t)
    }
  }
  toGeometry(t) {
    return t.isNull()
      ? this.createPoint()
      : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY()
        ? this.createPoint(new Oc(t.getMinX(), t.getMinY()))
        : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY()
          ? this.createLineString([
              new Oc(t.getMinX(), t.getMinY()),
              new Oc(t.getMaxX(), t.getMaxY())
            ])
          : this.createPolygon(
              this.createLinearRing([
                new Oc(t.getMinX(), t.getMinY()),
                new Oc(t.getMinX(), t.getMaxY()),
                new Oc(t.getMaxX(), t.getMaxY()),
                new Oc(t.getMaxX(), t.getMinY()),
                new Oc(t.getMinX(), t.getMinY())
              ]),
              null
            )
  }
  createLineString() {
    if (0 === arguments.length)
      return this.createLineString(this.getCoordinateSequenceFactory().create([]))
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        return this.createLineString(
          null !== t ? this.getCoordinateSequenceFactory().create(t) : null
        )
      }
      if (Uc(arguments[0], eu)) {
        return new mu(arguments[0], this)
      }
    }
  }
  createMultiLineString() {
    if (0 === arguments.length) return new Hu(null, this)
    if (1 === arguments.length) {
      return new Hu(arguments[0], this)
    }
  }
  buildGeometry(t) {
    let e = null,
      n = !1,
      i = !1
    for (let s = t.iterator(); s.hasNext(); ) {
      const t = s.next(),
        r = t.getTypeCode()
      null === e && (e = r), r !== e && (n = !0), t instanceof Tu && (i = !0)
    }
    if (null === e) return this.createGeometryCollection()
    if (n || i) return this.createGeometryCollection(ku.toGeometryArray(t))
    const s = t.iterator().next()
    if (t.size() > 1) {
      if (s instanceof Eu) return this.createMultiPolygon(ku.toPolygonArray(t))
      if (s instanceof mu) return this.createMultiLineString(ku.toLineStringArray(t))
      if (s instanceof xu) return this.createMultiPoint(ku.toPointArray(t))
      Cc.shouldNeverReachHere('Unhandled geometry type: ' + s.getGeometryType())
    }
    return s
  }
  createMultiPointFromCoords(t) {
    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
  }
  createPoint() {
    if (0 === arguments.length)
      return this.createPoint(this.getCoordinateSequenceFactory().create([]))
    if (1 === arguments.length) {
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
      }
      if (Uc(arguments[0], eu)) {
        return new xu(arguments[0], this)
      }
    }
  }
  getCoordinateSequenceFactory() {
    return this._coordinateSequenceFactory
  }
  createPolygon() {
    if (0 === arguments.length) return this.createPolygon(null, null)
    if (1 === arguments.length) {
      if (Uc(arguments[0], eu)) {
        const t = arguments[0]
        return this.createPolygon(this.createLinearRing(t))
      }
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        return this.createPolygon(this.createLinearRing(t))
      }
      if (arguments[0] instanceof Ru) {
        const t = arguments[0]
        return this.createPolygon(t, null)
      }
    } else if (2 === arguments.length) {
      return new Eu(arguments[0], arguments[1], this)
    }
  }
  getSRID() {
    return this._SRID
  }
  createGeometryCollection() {
    if (0 === arguments.length) return new Tu(null, this)
    if (1 === arguments.length) {
      return new Tu(arguments[0], this)
    }
  }
  getPrecisionModel() {
    return this._precisionModel
  }
  createLinearRing() {
    if (0 === arguments.length)
      return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        return this.createLinearRing(
          null !== t ? this.getCoordinateSequenceFactory().create(t) : null
        )
      }
      if (Uc(arguments[0], eu)) {
        return new Ru(arguments[0], this)
      }
    }
  }
  createMultiPolygon() {
    if (0 === arguments.length) return new Ou(null, this)
    if (1 === arguments.length) {
      return new Ou(arguments[0], this)
    }
  }
  createMultiPoint() {
    if (0 === arguments.length) return new Iu(null, this)
    if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        return new Iu(arguments[0], this)
      }
      if (Uc(arguments[0], eu)) {
        const t = arguments[0]
        if (null === t) return this.createMultiPoint(new Array(0).fill(null))
        const e = new Array(t.size()).fill(null)
        for (let n = 0; n < t.size(); n++) {
          const i = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures())
          du.copy(t, n, i, 0, 1), (e[n] = this.createPoint(i))
        }
        return this.createMultiPoint(e)
      }
    }
  }
  get interfaces_() {
    return [Ic]
  }
}
const Wu = 'XY',
  Yu = 'XYZ',
  ju = 'XYM',
  qu = 'XYZM',
  Zu = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle'
  },
  Xu = 1,
  Ku = 2,
  Ju = 3,
  Qu = 4,
  $u = 5,
  td = 6
for (const t in Zu) Zu[t].toUpperCase()
class ed {
  constructor(t) {
    ;(this.wkt = t), (this.index_ = -1)
  }
  isAlpha_(t) {
    return (t >= 'a' && t <= 'z') || (t >= 'A' && t <= 'Z')
  }
  isNumeric_(t, e) {
    return (t >= '0' && t <= '9') || ('.' == t && !(void 0 !== e && e))
  }
  isWhiteSpace_(t) {
    return ' ' == t || '\t' == t || '\r' == t || '\n' == t
  }
  nextChar_() {
    return this.wkt.charAt(++this.index_)
  }
  nextToken() {
    const t = this.nextChar_(),
      e = this.index_
    let n,
      i = t
    if ('(' == t) n = Ku
    else if (',' == t) n = $u
    else if (')' == t) n = Ju
    else if (this.isNumeric_(t) || '-' == t) (n = Qu), (i = this.readNumber_())
    else if (this.isAlpha_(t)) (n = Xu), (i = this.readText_())
    else {
      if (this.isWhiteSpace_(t)) return this.nextToken()
      if ('' !== t) throw new Error('Unexpected character: ' + t)
      n = td
    }
    return { position: e, value: i, type: n }
  }
  readNumber_() {
    let t
    const e = this.index_
    let n = !1,
      i = !1
    do {
      '.' == t ? (n = !0) : ('e' != t && 'E' != t) || (i = !0), (t = this.nextChar_())
    } while (
      this.isNumeric_(t, n) ||
      (!i && ('e' == t || 'E' == t)) ||
      (i && ('-' == t || '+' == t))
    )
    return parseFloat(this.wkt.substring(e, this.index_--))
  }
  readText_() {
    let t
    const e = this.index_
    do {
      t = this.nextChar_()
    } while (this.isAlpha_(t))
    return this.wkt.substring(e, this.index_--).toUpperCase()
  }
}
class nd {
  constructor(t, e) {
    ;(this.lexer_ = t), this.token_, (this.layout_ = Wu), (this.factory = e)
  }
  consume_() {
    this.token_ = this.lexer_.nextToken()
  }
  isTokenType(t) {
    return this.token_.type == t
  }
  match(t) {
    const e = this.isTokenType(t)
    return e && this.consume_(), e
  }
  parse() {
    this.consume_()
    return this.parseGeometry_()
  }
  parseGeometryLayout_() {
    let t = Wu
    const e = this.token_
    if (this.isTokenType(Xu)) {
      const n = e.value
      'Z' === n ? (t = Yu) : 'M' === n ? (t = ju) : 'ZM' === n && (t = qu),
        t !== Wu && this.consume_()
    }
    return t
  }
  parseGeometryCollectionText_() {
    if (this.match(Ku)) {
      const t = []
      do {
        t.push(this.parseGeometry_())
      } while (this.match($u))
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parsePointText_() {
    if (this.match(Ku)) {
      const t = this.parsePoint_()
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return null
    throw new Error(this.formatErrorMessage_())
  }
  parseLineStringText_() {
    if (this.match(Ku)) {
      const t = this.parsePointList_()
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parsePolygonText_() {
    if (this.match(Ku)) {
      const t = this.parseLineStringTextList_()
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parseMultiPointText_() {
    if (this.match(Ku)) {
      let t
      if (
        ((t = this.token_.type == Ku ? this.parsePointTextList_() : this.parsePointList_()),
        this.match(Ju))
      )
        return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parseMultiLineStringText_() {
    if (this.match(Ku)) {
      const t = this.parseLineStringTextList_()
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parseMultiPolygonText_() {
    if (this.match(Ku)) {
      const t = this.parsePolygonTextList_()
      if (this.match(Ju)) return t
    } else if (this.isEmptyGeometry_()) return []
    throw new Error(this.formatErrorMessage_())
  }
  parsePoint_() {
    const t = [],
      e = this.layout_.length
    for (let n = 0; n < e; ++n) {
      const e = this.token_
      if (!this.match(Qu)) break
      t.push(e.value)
    }
    if (t.length == e) return t
    throw new Error(this.formatErrorMessage_())
  }
  parsePointList_() {
    const t = [this.parsePoint_()]
    for (; this.match($u); ) t.push(this.parsePoint_())
    return t
  }
  parsePointTextList_() {
    const t = [this.parsePointText_()]
    for (; this.match($u); ) t.push(this.parsePointText_())
    return t
  }
  parseLineStringTextList_() {
    const t = [this.parseLineStringText_()]
    for (; this.match($u); ) t.push(this.parseLineStringText_())
    return t
  }
  parsePolygonTextList_() {
    const t = [this.parsePolygonText_()]
    for (; this.match($u); ) t.push(this.parsePolygonText_())
    return t
  }
  isEmptyGeometry_() {
    const t = this.isTokenType(Xu) && 'EMPTY' == this.token_.value
    return t && this.consume_(), t
  }
  formatErrorMessage_() {
    return (
      'Unexpected `' +
      this.token_.value +
      '` at position ' +
      this.token_.position +
      ' in `' +
      this.lexer_.wkt +
      '`'
    )
  }
  parseGeometry_() {
    const t = this.factory,
      e = (t) => new Oc(...t),
      n = (n) => {
        const i = n.map((n) => t.createLinearRing(n.map(e)))
        return i.length > 1 ? t.createPolygon(i[0], i.slice(1)) : t.createPolygon(i[0])
      },
      i = this.token_
    if (this.match(Xu)) {
      const s = i.value
      if (((this.layout_ = this.parseGeometryLayout_()), 'GEOMETRYCOLLECTION' == s)) {
        const e = this.parseGeometryCollectionText_()
        return t.createGeometryCollection(e)
      }
      switch (s) {
        case 'POINT': {
          const e = this.parsePointText_()
          return e ? t.createPoint(new Oc(...e)) : t.createPoint()
        }
        case 'LINESTRING': {
          const n = this.parseLineStringText_().map(e)
          return t.createLineString(n)
        }
        case 'LINEARRING': {
          const n = this.parseLineStringText_().map(e)
          return t.createLinearRing(n)
        }
        case 'POLYGON': {
          const e = this.parsePolygonText_()
          return e && 0 !== e.length ? n(e) : t.createPolygon()
        }
        case 'MULTIPOINT': {
          const n = this.parseMultiPointText_()
          if (!n || 0 === n.length) return t.createMultiPoint()
          const i = n.map(e).map((e) => t.createPoint(e))
          return t.createMultiPoint(i)
        }
        case 'MULTILINESTRING': {
          const n = this.parseMultiLineStringText_().map((n) => t.createLineString(n.map(e)))
          return t.createMultiLineString(n)
        }
        case 'MULTIPOLYGON': {
          const e = this.parseMultiPolygonText_()
          if (!e || 0 === e.length) return t.createMultiPolygon()
          const i = e.map(n)
          return t.createMultiPolygon(i)
        }
        default:
          throw new Error('Invalid geometry type: ' + s)
      }
    }
    throw new Error(this.formatErrorMessage_())
  }
}
function id(t) {
  if (t.isEmpty()) return ''
  const e = t.getCoordinate(),
    n = [e.x, e.y]
  return (
    void 0 === e.z || Number.isNaN(e.z) || n.push(e.z),
    void 0 === e.m || Number.isNaN(e.m) || n.push(e.m),
    n.join(' ')
  )
}
function sd(t) {
  const e = t.getCoordinates().map((t) => {
      const e = [t.x, t.y]
      return (
        void 0 === t.z || Number.isNaN(t.z) || e.push(t.z),
        void 0 === t.m || Number.isNaN(t.m) || e.push(t.m),
        e
      )
    }),
    n = []
  for (let t = 0, i = e.length; t < i; ++t) n.push(e[t].join(' '))
  return n.join(', ')
}
function rd(t) {
  const e = []
  e.push('(' + sd(t.getExteriorRing()) + ')')
  for (let n = 0, i = t.getNumInteriorRing(); n < i; ++n)
    e.push('(' + sd(t.getInteriorRingN(n)) + ')')
  return e.join(', ')
}
const od = {
  Point: id,
  LineString: sd,
  LinearRing: sd,
  Polygon: rd,
  MultiPoint: function (t) {
    const e = []
    for (let n = 0, i = t.getNumGeometries(); n < i; ++n) e.push('(' + id(t.getGeometryN(n)) + ')')
    return e.join(', ')
  },
  MultiLineString: function (t) {
    const e = []
    for (let n = 0, i = t.getNumGeometries(); n < i; ++n) e.push('(' + sd(t.getGeometryN(n)) + ')')
    return e.join(', ')
  },
  MultiPolygon: function (t) {
    const e = []
    for (let n = 0, i = t.getNumGeometries(); n < i; ++n) e.push('(' + rd(t.getGeometryN(n)) + ')')
    return e.join(', ')
  },
  GeometryCollection: function (t) {
    const e = []
    for (let n = 0, i = t.getNumGeometries(); n < i; ++n) e.push(ad(t.getGeometryN(n)))
    return e.join(', ')
  }
}
function ad(t) {
  let e = t.getGeometryType()
  const n = od[e]
  e = e.toUpperCase()
  const i = (function (t) {
    let e = ''
    if (t.isEmpty()) return e
    const n = t.getCoordinate()
    return (
      void 0 === n.z || Number.isNaN(n.z) || (e += 'Z'),
      void 0 === n.m || Number.isNaN(n.m) || (e += 'M'),
      e
    )
  })(t)
  if ((i.length > 0 && (e += ' ' + i), t.isEmpty())) return e + ' EMPTY'
  return e + ' (' + n(t) + ')'
}
class ld {
  constructor(t) {
    ;(this.geometryFactory = t || new ku()),
      (this.precisionModel = this.geometryFactory.getPrecisionModel())
  }
  read(t) {
    const e = new ed(t)
    return new nd(e, this.geometryFactory).parse()
  }
  write(t) {
    return ad(t)
  }
}
class hd {
  constructor(t) {
    this.parser = new ld(t)
  }
  write(t) {
    return this.parser.write(t)
  }
  static toLineString(t, e) {
    if (2 !== arguments.length) throw new Error('Not implemented')
    return 'LINESTRING ( ' + t.x + ' ' + t.y + ', ' + e.x + ' ' + e.y + ' )'
  }
}
class cd {
  constructor() {
    cd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._result = null),
      (this._inputLines = Array(2)
        .fill()
        .map(() => Array(2))),
      (this._intPt = new Array(2).fill(null)),
      (this._intLineIndex = null),
      (this._isProper = null),
      (this._pa = null),
      (this._pb = null),
      (this._precisionModel = null),
      (this._intPt[0] = new Oc()),
      (this._intPt[1] = new Oc()),
      (this._pa = this._intPt[0]),
      (this._pb = this._intPt[1]),
      (this._result = 0)
  }
  static computeEdgeDistance(t, e, n) {
    const i = Math.abs(n.x - e.x),
      s = Math.abs(n.y - e.y)
    let r = -1
    if (t.equals(e)) r = 0
    else if (t.equals(n)) r = i > s ? i : s
    else {
      const n = Math.abs(t.x - e.x),
        o = Math.abs(t.y - e.y)
      ;(r = i > s ? n : o), 0 !== r || t.equals(e) || (r = Math.max(n, o))
    }
    return Cc.isTrue(!(0 === r && !t.equals(e)), 'Bad distance calculation'), r
  }
  static nonRobustComputeEdgeDistance(t, e, n) {
    const i = t.x - e.x,
      s = t.y - e.y,
      r = Math.sqrt(i * i + s * s)
    return Cc.isTrue(!(0 === r && !t.equals(e)), 'Invalid distance calculation'), r
  }
  getIndexAlongSegment(t, e) {
    return this.computeIntLineIndex(), this._intLineIndex[t][e]
  }
  getTopologySummary() {
    const t = new Nu()
    return (
      this.isEndPoint() && t.append(' endpoint'),
      this._isProper && t.append(' proper'),
      this.isCollinear() && t.append(' collinear'),
      t.toString()
    )
  }
  computeIntersection(t, e, n, i) {
    ;(this._inputLines[0][0] = t),
      (this._inputLines[0][1] = e),
      (this._inputLines[1][0] = n),
      (this._inputLines[1][1] = i),
      (this._result = this.computeIntersect(t, e, n, i))
  }
  getIntersectionNum() {
    return this._result
  }
  computeIntLineIndex() {
    if (0 === arguments.length)
      null === this._intLineIndex &&
        ((this._intLineIndex = Array(2)
          .fill()
          .map(() => Array(2))),
        this.computeIntLineIndex(0),
        this.computeIntLineIndex(1))
    else if (1 === arguments.length) {
      const t = arguments[0]
      this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1)
        ? ((this._intLineIndex[t][0] = 0), (this._intLineIndex[t][1] = 1))
        : ((this._intLineIndex[t][0] = 1), (this._intLineIndex[t][1] = 0))
    }
  }
  isProper() {
    return this.hasIntersection() && this._isProper
  }
  setPrecisionModel(t) {
    this._precisionModel = t
  }
  isInteriorIntersection() {
    if (0 === arguments.length)
      return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1)
    if (1 === arguments.length) {
      const t = arguments[0]
      for (let e = 0; e < this._result; e++)
        if (
          !this._intPt[e].equals2D(this._inputLines[t][0]) &&
          !this._intPt[e].equals2D(this._inputLines[t][1])
        )
          return !0
      return !1
    }
  }
  getIntersection(t) {
    return this._intPt[t]
  }
  isEndPoint() {
    return this.hasIntersection() && !this._isProper
  }
  hasIntersection() {
    return this._result !== cd.NO_INTERSECTION
  }
  getEdgeDistance(t, e) {
    return cd.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1])
  }
  isCollinear() {
    return this._result === cd.COLLINEAR_INTERSECTION
  }
  toString() {
    return (
      hd.toLineString(this._inputLines[0][0], this._inputLines[0][1]) +
      ' - ' +
      hd.toLineString(this._inputLines[1][0], this._inputLines[1][1]) +
      this.getTopologySummary()
    )
  }
  getEndpoint(t, e) {
    return this._inputLines[t][e]
  }
  isIntersection(t) {
    for (let e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0
    return !1
  }
  getIntersectionAlongSegment(t, e) {
    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
  }
}
;(cd.DONT_INTERSECT = 0),
  (cd.DO_INTERSECT = 1),
  (cd.COLLINEAR = 2),
  (cd.NO_INTERSECTION = 0),
  (cd.POINT_INTERSECTION = 1),
  (cd.COLLINEAR_INTERSECTION = 2)
class ud extends cd {
  constructor() {
    super()
  }
  static nearestEndpoint(t, e, n, i) {
    let s = t,
      r = ou.pointToSegment(t, n, i),
      o = ou.pointToSegment(e, n, i)
    return (
      o < r && ((r = o), (s = e)),
      (o = ou.pointToSegment(n, t, e)),
      o < r && ((r = o), (s = n)),
      (o = ou.pointToSegment(i, t, e)),
      o < r && ((r = o), (s = i)),
      s
    )
  }
  isInSegmentEnvelopes(t) {
    const e = new Xc(this._inputLines[0][0], this._inputLines[0][1]),
      n = new Xc(this._inputLines[1][0], this._inputLines[1][1])
    return e.contains(t) && n.contains(t)
  }
  computeIntersection() {
    if (3 !== arguments.length) return super.computeIntersection.apply(this, arguments)
    {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (
        ((this._isProper = !1),
        Xc.intersects(e, n, t) && 0 === nu.index(e, n, t) && 0 === nu.index(n, e, t))
      )
        return (
          (this._isProper = !0),
          (t.equals(e) || t.equals(n)) && (this._isProper = !1),
          (this._result = cd.POINT_INTERSECTION),
          null
        )
      this._result = cd.NO_INTERSECTION
    }
  }
  intersection(t, e, n, i) {
    let s = this.intersectionSafe(t, e, n, i)
    return (
      this.isInSegmentEnvelopes(s) || (s = new Oc(ud.nearestEndpoint(t, e, n, i))),
      null !== this._precisionModel && this._precisionModel.makePrecise(s),
      s
    )
  }
  checkDD(t, e, n, i, s) {
    const r = tu.intersection(t, e, n, i),
      o = this.isInSegmentEnvelopes(r)
    su.out.println('DD in env = ' + o + '  --------------------- ' + r),
      s.distance(r) > 1e-4 && su.out.println('Distance = ' + s.distance(r))
  }
  intersectionSafe(t, e, n, i) {
    let s = iu.intersection(t, e, n, i)
    return null === s && (s = ud.nearestEndpoint(t, e, n, i)), s
  }
  computeCollinearIntersection(t, e, n, i) {
    const s = Xc.intersects(t, e, n),
      r = Xc.intersects(t, e, i),
      o = Xc.intersects(n, i, t),
      a = Xc.intersects(n, i, e)
    return s && r
      ? ((this._intPt[0] = n), (this._intPt[1] = i), cd.COLLINEAR_INTERSECTION)
      : o && a
        ? ((this._intPt[0] = t), (this._intPt[1] = e), cd.COLLINEAR_INTERSECTION)
        : s && o
          ? ((this._intPt[0] = n),
            (this._intPt[1] = t),
            !n.equals(t) || r || a ? cd.COLLINEAR_INTERSECTION : cd.POINT_INTERSECTION)
          : s && a
            ? ((this._intPt[0] = n),
              (this._intPt[1] = e),
              !n.equals(e) || r || o ? cd.COLLINEAR_INTERSECTION : cd.POINT_INTERSECTION)
            : r && o
              ? ((this._intPt[0] = i),
                (this._intPt[1] = t),
                !i.equals(t) || s || a ? cd.COLLINEAR_INTERSECTION : cd.POINT_INTERSECTION)
              : r && a
                ? ((this._intPt[0] = i),
                  (this._intPt[1] = e),
                  !i.equals(e) || s || o ? cd.COLLINEAR_INTERSECTION : cd.POINT_INTERSECTION)
                : cd.NO_INTERSECTION
  }
  computeIntersect(t, e, n, i) {
    if (((this._isProper = !1), !Xc.intersects(t, e, n, i))) return cd.NO_INTERSECTION
    const s = nu.index(t, e, n),
      r = nu.index(t, e, i)
    if ((s > 0 && r > 0) || (s < 0 && r < 0)) return cd.NO_INTERSECTION
    const o = nu.index(n, i, t),
      a = nu.index(n, i, e)
    if ((o > 0 && a > 0) || (o < 0 && a < 0)) return cd.NO_INTERSECTION
    return 0 === s && 0 === r && 0 === o && 0 === a
      ? this.computeCollinearIntersection(t, e, n, i)
      : (0 === s || 0 === r || 0 === o || 0 === a
          ? ((this._isProper = !1),
            t.equals2D(n) || t.equals2D(i)
              ? (this._intPt[0] = t)
              : e.equals2D(n) || e.equals2D(i)
                ? (this._intPt[0] = e)
                : 0 === s
                  ? (this._intPt[0] = new Oc(n))
                  : 0 === r
                    ? (this._intPt[0] = new Oc(i))
                    : 0 === o
                      ? (this._intPt[0] = new Oc(t))
                      : 0 === a && (this._intPt[0] = new Oc(e)))
          : ((this._isProper = !0), (this._intPt[0] = this.intersection(t, e, n, i))),
        cd.POINT_INTERSECTION)
  }
}
class dd {
  constructor() {
    dd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.p0 = null), (this.p1 = null), 0 === arguments.length))
      dd.constructor_.call(this, new Oc(), new Oc())
    else if (1 === arguments.length) {
      const t = arguments[0]
      dd.constructor_.call(this, t.p0, t.p1)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this.p0 = t), (this.p1 = e)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      dd.constructor_.call(this, new Oc(t, e), new Oc(n, i))
    }
  }
  static midPoint(t, e) {
    return new Oc((t.x + e.x) / 2, (t.y + e.y) / 2)
  }
  minX() {
    return Math.min(this.p0.x, this.p1.x)
  }
  orientationIndex() {
    if (arguments[0] instanceof dd) {
      const t = arguments[0],
        e = nu.index(this.p0, this.p1, t.p0),
        n = nu.index(this.p0, this.p1, t.p1)
      return (e >= 0 && n >= 0) || (e <= 0 && n <= 0) ? Math.max(e, n) : 0
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      return nu.index(this.p0, this.p1, t)
    }
  }
  toGeometry(t) {
    return t.createLineString([this.p0, this.p1])
  }
  isVertical() {
    return this.p0.x === this.p1.x
  }
  equals(t) {
    if (!(t instanceof dd)) return !1
    const e = t
    return this.p0.equals(e.p0) && this.p1.equals(e.p1)
  }
  intersection(t) {
    const e = new ud()
    return (
      e.computeIntersection(this.p0, this.p1, t.p0, t.p1),
      e.hasIntersection() ? e.getIntersection(0) : null
    )
  }
  project() {
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      if (t.equals(this.p0) || t.equals(this.p1)) return new Oc(t)
      const e = this.projectionFactor(t),
        n = new Oc()
      return (
        (n.x = this.p0.x + e * (this.p1.x - this.p0.x)),
        (n.y = this.p0.y + e * (this.p1.y - this.p0.y)),
        n
      )
    }
    if (arguments[0] instanceof dd) {
      const t = arguments[0],
        e = this.projectionFactor(t.p0),
        n = this.projectionFactor(t.p1)
      if (e >= 1 && n >= 1) return null
      if (e <= 0 && n <= 0) return null
      let i = this.project(t.p0)
      e < 0 && (i = this.p0), e > 1 && (i = this.p1)
      let s = this.project(t.p1)
      return n < 0 && (s = this.p0), n > 1 && (s = this.p1), new dd(i, s)
    }
  }
  normalize() {
    this.p1.compareTo(this.p0) < 0 && this.reverse()
  }
  angle() {
    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
  }
  getCoordinate(t) {
    return 0 === t ? this.p0 : this.p1
  }
  distancePerpendicular(t) {
    return ou.pointToLinePerpendicular(t, this.p0, this.p1)
  }
  minY() {
    return Math.min(this.p0.y, this.p1.y)
  }
  midPoint() {
    return dd.midPoint(this.p0, this.p1)
  }
  projectionFactor(t) {
    if (t.equals(this.p0)) return 0
    if (t.equals(this.p1)) return 1
    const e = this.p1.x - this.p0.x,
      n = this.p1.y - this.p0.y,
      i = e * e + n * n
    if (i <= 0) return Mc.NaN
    return ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i
  }
  closestPoints(t) {
    const e = this.intersection(t)
    if (null !== e) return [e, e]
    const n = new Array(2).fill(null)
    let i = Mc.MAX_VALUE,
      s = null
    const r = this.closestPoint(t.p0)
    ;(i = r.distance(t.p0)), (n[0] = r), (n[1] = t.p0)
    const o = this.closestPoint(t.p1)
    ;(s = o.distance(t.p1)), s < i && ((i = s), (n[0] = o), (n[1] = t.p1))
    const a = t.closestPoint(this.p0)
    ;(s = a.distance(this.p0)), s < i && ((i = s), (n[0] = this.p0), (n[1] = a))
    const l = t.closestPoint(this.p1)
    return (s = l.distance(this.p1)), s < i && ((i = s), (n[0] = this.p1), (n[1] = l)), n
  }
  closestPoint(t) {
    const e = this.projectionFactor(t)
    if (e > 0 && e < 1) return this.project(t)
    return this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
  }
  maxX() {
    return Math.max(this.p0.x, this.p1.x)
  }
  getLength() {
    return this.p0.distance(this.p1)
  }
  compareTo(t) {
    const e = t,
      n = this.p0.compareTo(e.p0)
    return 0 !== n ? n : this.p1.compareTo(e.p1)
  }
  reverse() {
    const t = this.p0
    ;(this.p0 = this.p1), (this.p1 = t)
  }
  equalsTopo(t) {
    return (
      (this.p0.equals(t.p0) && this.p1.equals(t.p1)) ||
      (this.p0.equals(t.p1) && this.p1.equals(t.p0))
    )
  }
  lineIntersection(t) {
    return iu.intersection(this.p0, this.p1, t.p0, t.p1)
  }
  maxY() {
    return Math.max(this.p0.y, this.p1.y)
  }
  pointAlongOffset(t, e) {
    const n = this.p0.x + t * (this.p1.x - this.p0.x),
      i = this.p0.y + t * (this.p1.y - this.p0.y),
      s = this.p1.x - this.p0.x,
      r = this.p1.y - this.p0.y,
      o = Math.sqrt(s * s + r * r)
    let a = 0,
      l = 0
    if (0 !== e) {
      if (o <= 0)
        throw new IllegalStateException('Cannot compute offset from zero-length line segment')
      ;(a = (e * s) / o), (l = (e * r) / o)
    }
    return new Oc(n - l, i + a)
  }
  setCoordinates() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.setCoordinates(t.p0, t.p1)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this.p0.x = t.x), (this.p0.y = t.y), (this.p1.x = e.x), (this.p1.y = e.y)
    }
  }
  segmentFraction(t) {
    let e = this.projectionFactor(t)
    return e < 0 ? (e = 0) : (e > 1 || Mc.isNaN(e)) && (e = 1), e
  }
  toString() {
    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'
  }
  isHorizontal() {
    return this.p0.y === this.p1.y
  }
  reflect(t) {
    const e = this.p1.getY() - this.p0.getY(),
      n = this.p0.getX() - this.p1.getX(),
      i =
        this.p0.getY() * (this.p1.getX() - this.p0.getX()) -
        this.p0.getX() * (this.p1.getY() - this.p0.getY()),
      s = e * e + n * n,
      r = e * e - n * n,
      o = t.getX(),
      a = t.getY()
    return new Oc((-r * o - 2 * e * n * a - 2 * e * i) / s, (r * a - 2 * e * n * o - 2 * n * i) / s)
  }
  distance() {
    if (arguments[0] instanceof dd) {
      const t = arguments[0]
      return ou.segmentToSegment(this.p0, this.p1, t.p0, t.p1)
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      return ou.pointToSegment(t, this.p0, this.p1)
    }
  }
  pointAlong(t) {
    const e = new Oc()
    return (
      (e.x = this.p0.x + t * (this.p1.x - this.p0.x)),
      (e.y = this.p0.y + t * (this.p1.y - this.p0.y)),
      e
    )
  }
  hashCode() {
    let t = Mc.doubleToLongBits(this.p0.x)
    t ^= 31 * Mc.doubleToLongBits(this.p0.y)
    const e = Math.trunc(t) ^ Math.trunc(t >> 32)
    let n = Mc.doubleToLongBits(this.p1.x)
    n ^= 31 * Mc.doubleToLongBits(this.p1.y)
    return e ^ (Math.trunc(n) ^ Math.trunc(n >> 32))
  }
  get interfaces_() {
    return [Sc, Ic]
  }
}
class pd {
  static toLocationSymbol(t) {
    switch (t) {
      case pd.EXTERIOR:
        return 'e'
      case pd.BOUNDARY:
        return 'b'
      case pd.INTERIOR:
        return 'i'
      case pd.NONE:
        return '-'
    }
    throw new Ec('Unknown location value: ' + t)
  }
}
;(pd.INTERIOR = 0), (pd.BOUNDARY = 1), (pd.EXTERIOR = 2), (pd.NONE = -1)
class gd {
  constructor() {
    gd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._matrix = null), 0 === arguments.length))
      (this._matrix = Array(3)
        .fill()
        .map(() => Array(3))),
        this.setAll(gu.FALSE)
    else if (1 === arguments.length)
      if ('string' == typeof arguments[0]) {
        const t = arguments[0]
        gd.constructor_.call(this), this.set(t)
      } else if (arguments[0] instanceof gd) {
        const t = arguments[0]
        gd.constructor_.call(this),
          (this._matrix[pd.INTERIOR][pd.INTERIOR] = t._matrix[pd.INTERIOR][pd.INTERIOR]),
          (this._matrix[pd.INTERIOR][pd.BOUNDARY] = t._matrix[pd.INTERIOR][pd.BOUNDARY]),
          (this._matrix[pd.INTERIOR][pd.EXTERIOR] = t._matrix[pd.INTERIOR][pd.EXTERIOR]),
          (this._matrix[pd.BOUNDARY][pd.INTERIOR] = t._matrix[pd.BOUNDARY][pd.INTERIOR]),
          (this._matrix[pd.BOUNDARY][pd.BOUNDARY] = t._matrix[pd.BOUNDARY][pd.BOUNDARY]),
          (this._matrix[pd.BOUNDARY][pd.EXTERIOR] = t._matrix[pd.BOUNDARY][pd.EXTERIOR]),
          (this._matrix[pd.EXTERIOR][pd.INTERIOR] = t._matrix[pd.EXTERIOR][pd.INTERIOR]),
          (this._matrix[pd.EXTERIOR][pd.BOUNDARY] = t._matrix[pd.EXTERIOR][pd.BOUNDARY]),
          (this._matrix[pd.EXTERIOR][pd.EXTERIOR] = t._matrix[pd.EXTERIOR][pd.EXTERIOR])
      }
  }
  static matches() {
    if (Number.isInteger(arguments[0]) && 'string' == typeof arguments[1]) {
      const t = arguments[0],
        e = arguments[1]
      return (
        e === gu.SYM_DONTCARE ||
        (e === gu.SYM_TRUE && (t >= 0 || t === gu.TRUE)) ||
        (e === gu.SYM_FALSE && t === gu.FALSE) ||
        (e === gu.SYM_P && t === gu.P) ||
        (e === gu.SYM_L && t === gu.L) ||
        (e === gu.SYM_A && t === gu.A)
      )
    }
    if ('string' == typeof arguments[0] && 'string' == typeof arguments[1]) {
      const t = arguments[1]
      return new gd(arguments[0]).matches(t)
    }
  }
  static isTrue(t) {
    return t >= 0 || t === gu.TRUE
  }
  isIntersects() {
    return !this.isDisjoint()
  }
  isCovers() {
    return (
      (gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) ||
        gd.isTrue(this._matrix[pd.INTERIOR][pd.BOUNDARY]) ||
        gd.isTrue(this._matrix[pd.BOUNDARY][pd.INTERIOR]) ||
        gd.isTrue(this._matrix[pd.BOUNDARY][pd.BOUNDARY])) &&
      this._matrix[pd.EXTERIOR][pd.INTERIOR] === gu.FALSE &&
      this._matrix[pd.EXTERIOR][pd.BOUNDARY] === gu.FALSE
    )
  }
  isCoveredBy() {
    return (
      (gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) ||
        gd.isTrue(this._matrix[pd.INTERIOR][pd.BOUNDARY]) ||
        gd.isTrue(this._matrix[pd.BOUNDARY][pd.INTERIOR]) ||
        gd.isTrue(this._matrix[pd.BOUNDARY][pd.BOUNDARY])) &&
      this._matrix[pd.INTERIOR][pd.EXTERIOR] === gu.FALSE &&
      this._matrix[pd.BOUNDARY][pd.EXTERIOR] === gu.FALSE
    )
  }
  set() {
    if (1 === arguments.length) {
      const t = arguments[0]
      for (let e = 0; e < t.length; e++) {
        const n = Math.trunc(e / 3),
          i = e % 3
        this._matrix[n][i] = gu.toDimensionValue(t.charAt(e))
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this._matrix[t][e] = n
    }
  }
  isContains() {
    return (
      gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
      this._matrix[pd.EXTERIOR][pd.INTERIOR] === gu.FALSE &&
      this._matrix[pd.EXTERIOR][pd.BOUNDARY] === gu.FALSE
    )
  }
  setAtLeast() {
    if (1 === arguments.length) {
      const t = arguments[0]
      for (let e = 0; e < t.length; e++) {
        const n = Math.trunc(e / 3),
          i = e % 3
        this.setAtLeast(n, i, gu.toDimensionValue(t.charAt(e)))
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this._matrix[t][e] < n && (this._matrix[t][e] = n)
    }
  }
  setAtLeastIfValid(t, e, n) {
    t >= 0 && e >= 0 && this.setAtLeast(t, e, n)
  }
  isWithin() {
    return (
      gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
      this._matrix[pd.INTERIOR][pd.EXTERIOR] === gu.FALSE &&
      this._matrix[pd.BOUNDARY][pd.EXTERIOR] === gu.FALSE
    )
  }
  isTouches(t, e) {
    return t > e
      ? this.isTouches(e, t)
      : ((t === gu.A && e === gu.A) ||
          (t === gu.L && e === gu.L) ||
          (t === gu.L && e === gu.A) ||
          (t === gu.P && e === gu.A) ||
          (t === gu.P && e === gu.L)) &&
          this._matrix[pd.INTERIOR][pd.INTERIOR] === gu.FALSE &&
          (gd.isTrue(this._matrix[pd.INTERIOR][pd.BOUNDARY]) ||
            gd.isTrue(this._matrix[pd.BOUNDARY][pd.INTERIOR]) ||
            gd.isTrue(this._matrix[pd.BOUNDARY][pd.BOUNDARY]))
  }
  isOverlaps(t, e) {
    return (t === gu.P && e === gu.P) || (t === gu.A && e === gu.A)
      ? gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
          gd.isTrue(this._matrix[pd.INTERIOR][pd.EXTERIOR]) &&
          gd.isTrue(this._matrix[pd.EXTERIOR][pd.INTERIOR])
      : t === gu.L &&
          e === gu.L &&
          1 === this._matrix[pd.INTERIOR][pd.INTERIOR] &&
          gd.isTrue(this._matrix[pd.INTERIOR][pd.EXTERIOR]) &&
          gd.isTrue(this._matrix[pd.EXTERIOR][pd.INTERIOR])
  }
  isEquals(t, e) {
    return (
      t === e &&
      gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
      this._matrix[pd.INTERIOR][pd.EXTERIOR] === gu.FALSE &&
      this._matrix[pd.BOUNDARY][pd.EXTERIOR] === gu.FALSE &&
      this._matrix[pd.EXTERIOR][pd.INTERIOR] === gu.FALSE &&
      this._matrix[pd.EXTERIOR][pd.BOUNDARY] === gu.FALSE
    )
  }
  toString() {
    const t = new Nu('123456789')
    for (let e = 0; e < 3; e++)
      for (let n = 0; n < 3; n++) t.setCharAt(3 * e + n, gu.toDimensionSymbol(this._matrix[e][n]))
    return t.toString()
  }
  setAll(t) {
    for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) this._matrix[e][n] = t
  }
  get(t, e) {
    return this._matrix[t][e]
  }
  transpose() {
    let t = this._matrix[1][0]
    return (
      (this._matrix[1][0] = this._matrix[0][1]),
      (this._matrix[0][1] = t),
      (t = this._matrix[2][0]),
      (this._matrix[2][0] = this._matrix[0][2]),
      (this._matrix[0][2] = t),
      (t = this._matrix[2][1]),
      (this._matrix[2][1] = this._matrix[1][2]),
      (this._matrix[1][2] = t),
      this
    )
  }
  matches(t) {
    if (9 !== t.length) throw new Ec('Should be length 9: ' + t)
    for (let e = 0; e < 3; e++)
      for (let n = 0; n < 3; n++)
        if (!gd.matches(this._matrix[e][n], t.charAt(3 * e + n))) return !1
    return !0
  }
  add(t) {
    for (let e = 0; e < 3; e++) for (let n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n))
  }
  isDisjoint() {
    return (
      this._matrix[pd.INTERIOR][pd.INTERIOR] === gu.FALSE &&
      this._matrix[pd.INTERIOR][pd.BOUNDARY] === gu.FALSE &&
      this._matrix[pd.BOUNDARY][pd.INTERIOR] === gu.FALSE &&
      this._matrix[pd.BOUNDARY][pd.BOUNDARY] === gu.FALSE
    )
  }
  isCrosses(t, e) {
    return (t === gu.P && e === gu.L) || (t === gu.P && e === gu.A) || (t === gu.L && e === gu.A)
      ? gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
          gd.isTrue(this._matrix[pd.INTERIOR][pd.EXTERIOR])
      : (t === gu.L && e === gu.P) || (t === gu.A && e === gu.P) || (t === gu.A && e === gu.L)
        ? gd.isTrue(this._matrix[pd.INTERIOR][pd.INTERIOR]) &&
          gd.isTrue(this._matrix[pd.EXTERIOR][pd.INTERIOR])
        : t === gu.L && e === gu.L && 0 === this._matrix[pd.INTERIOR][pd.INTERIOR]
  }
  get interfaces_() {
    return [Ac]
  }
}
class fd {
  static toDegrees(t) {
    return (180 * t) / Math.PI
  }
  static normalize(t) {
    for (; t > Math.PI; ) t -= fd.PI_TIMES_2
    for (; t <= -Math.PI; ) t += fd.PI_TIMES_2
    return t
  }
  static angle() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Math.atan2(t.y, t.x)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = e.x - t.x,
        i = e.y - t.y
      return Math.atan2(i, n)
    }
  }
  static isAcute(t, e, n) {
    const i = t.x - e.x,
      s = t.y - e.y
    return i * (n.x - e.x) + s * (n.y - e.y) > 0
  }
  static isObtuse(t, e, n) {
    const i = t.x - e.x,
      s = t.y - e.y
    return i * (n.x - e.x) + s * (n.y - e.y) < 0
  }
  static interiorAngle(t, e, n) {
    const i = fd.angle(e, t),
      s = fd.angle(e, n)
    return Math.abs(s - i)
  }
  static normalizePositive(t) {
    if (t < 0) {
      for (; t < 0; ) t += fd.PI_TIMES_2
      t >= fd.PI_TIMES_2 && (t = 0)
    } else {
      for (; t >= fd.PI_TIMES_2; ) t -= fd.PI_TIMES_2
      t < 0 && (t = 0)
    }
    return t
  }
  static angleBetween(t, e, n) {
    const i = fd.angle(e, t),
      s = fd.angle(e, n)
    return fd.diff(i, s)
  }
  static diff(t, e) {
    let n = null
    return (n = t < e ? e - t : t - e), n > Math.PI && (n = 2 * Math.PI - n), n
  }
  static toRadians(t) {
    return (t * Math.PI) / 180
  }
  static getTurn(t, e) {
    const n = Math.sin(e - t)
    return n > 0 ? fd.COUNTERCLOCKWISE : n < 0 ? fd.CLOCKWISE : fd.NONE
  }
  static angleBetweenOriented(t, e, n) {
    const i = fd.angle(e, t),
      s = fd.angle(e, n) - i
    return s <= -Math.PI ? s + fd.PI_TIMES_2 : s > Math.PI ? s - fd.PI_TIMES_2 : s
  }
}
;(fd.PI_TIMES_2 = 2 * Math.PI),
  (fd.PI_OVER_2 = Math.PI / 2),
  (fd.PI_OVER_4 = Math.PI / 4),
  (fd.COUNTERCLOCKWISE = nu.COUNTERCLOCKWISE),
  (fd.CLOCKWISE = nu.CLOCKWISE),
  (fd.NONE = nu.COLLINEAR)
class md extends wc {
  constructor() {
    super(), md.constructor_.apply(this, arguments)
  }
  static constructor_() {
    wc.constructor_.call(this, 'Projective point not representable on the Cartesian plane.')
  }
}
class yd {
  constructor() {
    yd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.x = null), (this.y = null), (this.w = null), 0 === arguments.length))
      (this.x = 0), (this.y = 0), (this.w = 1)
    else if (1 === arguments.length) {
      const t = arguments[0]
      ;(this.x = t.x), (this.y = t.y), (this.w = 1)
    } else if (2 === arguments.length) {
      if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
        const t = arguments[0],
          e = arguments[1]
        ;(this.x = t), (this.y = e), (this.w = 1)
      } else if (arguments[0] instanceof yd && arguments[1] instanceof yd) {
        const t = arguments[0],
          e = arguments[1]
        ;(this.x = t.y * e.w - e.y * t.w),
          (this.y = e.x * t.w - t.x * e.w),
          (this.w = t.x * e.y - e.x * t.y)
      } else if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
        const t = arguments[0],
          e = arguments[1]
        ;(this.x = t.y - e.y), (this.y = e.x - t.x), (this.w = t.x * e.y - e.x * t.y)
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this.x = t), (this.y = e), (this.w = n)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = t.y - e.y,
        r = e.x - t.x,
        o = t.x * e.y - e.x * t.y,
        a = n.y - i.y,
        l = i.x - n.x,
        h = n.x * i.y - i.x * n.y
      ;(this.x = r * h - l * o), (this.y = a * o - s * h), (this.w = s * l - a * r)
    }
  }
  getY() {
    const t = this.y / this.w
    if (Mc.isNaN(t) || Mc.isInfinite(t)) throw new md()
    return t
  }
  getX() {
    const t = this.x / this.w
    if (Mc.isNaN(t) || Mc.isInfinite(t)) throw new md()
    return t
  }
  getCoordinate() {
    const t = new Oc()
    return (t.x = this.getX()), (t.y = this.getY()), t
  }
}
class xd {
  constructor() {
    xd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.p0 = null), (this.p1 = null), (this.p2 = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this.p0 = t), (this.p1 = e), (this.p2 = n)
  }
  static area(t, e, n) {
    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
  }
  static signedArea(t, e, n) {
    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
  }
  static det(t, e, n, i) {
    return t * i - e * n
  }
  static interpolateZ(t, e, n, i) {
    const s = e.x,
      r = e.y,
      o = n.x - s,
      a = i.x - s,
      l = n.y - r,
      h = i.y - r,
      c = o * h - a * l,
      u = t.x - s,
      d = t.y - r,
      p = (h * u - a * d) / c,
      g = (-l * u + o * d) / c
    return e.getZ() + p * (n.getZ() - e.getZ()) + g * (i.getZ() - e.getZ())
  }
  static longestSideLength(t, e, n) {
    const i = t.distance(e),
      s = e.distance(n),
      r = n.distance(t)
    let o = i
    return s > o && (o = s), r > o && (o = r), o
  }
  static circumcentreDD(t, e, n) {
    const i = $c.valueOf(t.x).subtract(n.x),
      s = $c.valueOf(t.y).subtract(n.y),
      r = $c.valueOf(e.x).subtract(n.x),
      o = $c.valueOf(e.y).subtract(n.y),
      a = $c.determinant(i, s, r, o).multiply(2),
      l = i.sqr().add(s.sqr()),
      h = r.sqr().add(o.sqr()),
      c = $c.determinant(s, l, o, h),
      u = $c.determinant(i, l, r, h),
      d = $c.valueOf(n.x).subtract(c.divide(a)).doubleValue(),
      p = $c.valueOf(n.y).add(u.divide(a)).doubleValue()
    return new Oc(d, p)
  }
  static isAcute(t, e, n) {
    return !!fd.isAcute(t, e, n) && !!fd.isAcute(e, n, t) && !!fd.isAcute(n, t, e)
  }
  static circumcentre(t, e, n) {
    const i = n.x,
      s = n.y,
      r = t.x - i,
      o = t.y - s,
      a = e.x - i,
      l = e.y - s,
      h = 2 * xd.det(r, o, a, l),
      c = xd.det(o, r * r + o * o, l, a * a + l * l),
      u = xd.det(r, r * r + o * o, a, a * a + l * l)
    return new Oc(i - c / h, s + u / h)
  }
  static perpendicularBisector(t, e) {
    const n = e.x - t.x,
      i = e.y - t.y,
      s = new yd(t.x + n / 2, t.y + i / 2, 1),
      r = new yd(t.x - i + n / 2, t.y + n + i / 2, 1)
    return new yd(s, r)
  }
  static angleBisector(t, e, n) {
    const i = e.distance(t),
      s = i / (i + e.distance(n)),
      r = n.x - t.x,
      o = n.y - t.y
    return new Oc(t.x + s * r, t.y + s * o)
  }
  static area3D(t, e, n) {
    const i = e.x - t.x,
      s = e.y - t.y,
      r = e.getZ() - t.getZ(),
      o = n.x - t.x,
      a = n.y - t.y,
      l = n.getZ() - t.getZ(),
      h = s * l - r * a,
      c = r * o - i * l,
      u = i * a - s * o,
      d = h * h + c * c + u * u
    return Math.sqrt(d) / 2
  }
  static centroid(t, e, n) {
    const i = (t.x + e.x + n.x) / 3,
      s = (t.y + e.y + n.y) / 3
    return new Oc(i, s)
  }
  static inCentre(t, e, n) {
    const i = e.distance(n),
      s = t.distance(n),
      r = t.distance(e),
      o = i + s + r,
      a = (i * t.x + s * e.x + r * n.x) / o,
      l = (i * t.y + s * e.y + r * n.y) / o
    return new Oc(a, l)
  }
  area() {
    return xd.area(this.p0, this.p1, this.p2)
  }
  signedArea() {
    return xd.signedArea(this.p0, this.p1, this.p2)
  }
  interpolateZ(t) {
    if (null === t) throw new Ec('Supplied point is null.')
    return xd.interpolateZ(t, this.p0, this.p1, this.p2)
  }
  longestSideLength() {
    return xd.longestSideLength(this.p0, this.p1, this.p2)
  }
  isAcute() {
    return xd.isAcute(this.p0, this.p1, this.p2)
  }
  circumcentre() {
    return xd.circumcentre(this.p0, this.p1, this.p2)
  }
  area3D() {
    return xd.area3D(this.p0, this.p1, this.p2)
  }
  centroid() {
    return xd.centroid(this.p0, this.p1, this.p2)
  }
  inCentre() {
    return xd.inCentre(this.p0, this.p1, this.p2)
  }
}
class vd extends wc {
  constructor() {
    super(), vd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (0 === arguments.length) wc.constructor_.call(this)
    else if (1 === arguments.length) {
      const t = arguments[0]
      wc.constructor_.call(this, t)
    }
  }
}
class _d {
  constructor() {
    _d.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._m00 = null),
      (this._m01 = null),
      (this._m02 = null),
      (this._m10 = null),
      (this._m11 = null),
      (this._m12 = null),
      0 === arguments.length)
    )
      this.setToIdentity()
    else if (1 === arguments.length) {
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        ;(this._m00 = t[0]),
          (this._m01 = t[1]),
          (this._m02 = t[2]),
          (this._m10 = t[3]),
          (this._m11 = t[4]),
          (this._m12 = t[5])
      } else if (arguments[0] instanceof _d) {
        const t = arguments[0]
        this.setTransformation(t)
      }
    } else if (
      6 === arguments.length &&
      'number' == typeof arguments[5] &&
      'number' == typeof arguments[4] &&
      'number' == typeof arguments[3] &&
      'number' == typeof arguments[2] &&
      'number' == typeof arguments[0] &&
      'number' == typeof arguments[1]
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5]
      this.setTransformation(t, e, n, i, s, r)
    }
  }
  static translationInstance(t, e) {
    const n = new _d()
    return n.setToTranslation(t, e), n
  }
  static shearInstance(t, e) {
    const n = new _d()
    return n.setToShear(t, e), n
  }
  static reflectionInstance() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new _d()
      return n.setToReflection(t, e), n
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = new _d()
      return s.setToReflection(t, e, n, i), s
    }
  }
  static rotationInstance() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return _d.rotationInstance(Math.sin(t), Math.cos(t))
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new _d()
      return n.setToRotation(t, e), n
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return _d.rotationInstance(Math.sin(t), Math.cos(t), e, n)
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = new _d()
      return s.setToRotation(t, e, n, i), s
    }
  }
  static scaleInstance() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new _d()
      return n.setToScale(t, e), n
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = new _d()
      return s.translate(-n, -i), s.scale(t, e), s.translate(n, i), s
    }
  }
  setToReflectionBasic(t, e, n, i) {
    if (t === n && e === i) throw new Ec('Reflection line points must be distinct')
    const s = n - t,
      r = i - e,
      o = Math.sqrt(s * s + r * r),
      a = r / o,
      l = s / o,
      h = 2 * a * l,
      c = l * l - a * a
    return (
      (this._m00 = c),
      (this._m01 = h),
      (this._m02 = 0),
      (this._m10 = h),
      (this._m11 = -c),
      (this._m12 = 0),
      this
    )
  }
  getInverse() {
    const t = this.getDeterminant()
    if (0 === t) throw new vd('Transformation is non-invertible')
    const e = this._m11 / t,
      n = -this._m10 / t,
      i = -this._m01 / t,
      s = this._m00 / t,
      r = (this._m01 * this._m12 - this._m02 * this._m11) / t,
      o = (-this._m00 * this._m12 + this._m10 * this._m02) / t
    return new _d(e, i, r, n, s, o)
  }
  compose(t) {
    const e = t._m00 * this._m00 + t._m01 * this._m10,
      n = t._m00 * this._m01 + t._m01 * this._m11,
      i = t._m00 * this._m02 + t._m01 * this._m12 + t._m02,
      s = t._m10 * this._m00 + t._m11 * this._m10,
      r = t._m10 * this._m01 + t._m11 * this._m11,
      o = t._m10 * this._m02 + t._m11 * this._m12 + t._m12
    return (
      (this._m00 = e),
      (this._m01 = n),
      (this._m02 = i),
      (this._m10 = s),
      (this._m11 = r),
      (this._m12 = o),
      this
    )
  }
  equals(t) {
    if (null === t) return !1
    if (!(t instanceof _d)) return !1
    const e = t
    return (
      this._m00 === e._m00 &&
      this._m01 === e._m01 &&
      this._m02 === e._m02 &&
      this._m10 === e._m10 &&
      this._m11 === e._m11 &&
      this._m12 === e._m12
    )
  }
  setToScale(t, e) {
    return (
      (this._m00 = t),
      (this._m01 = 0),
      (this._m02 = 0),
      (this._m10 = 0),
      (this._m11 = e),
      (this._m12 = 0),
      this
    )
  }
  isIdentity() {
    return (
      1 === this._m00 &&
      0 === this._m01 &&
      0 === this._m02 &&
      0 === this._m10 &&
      1 === this._m11 &&
      0 === this._m12
    )
  }
  scale(t, e) {
    return this.compose(_d.scaleInstance(t, e)), this
  }
  setToIdentity() {
    return (
      (this._m00 = 1),
      (this._m01 = 0),
      (this._m02 = 0),
      (this._m10 = 0),
      (this._m11 = 1),
      (this._m12 = 0),
      this
    )
  }
  isGeometryChanged() {
    return !0
  }
  setTransformation() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return (
        (this._m00 = t._m00),
        (this._m01 = t._m01),
        (this._m02 = t._m02),
        (this._m10 = t._m10),
        (this._m11 = t._m11),
        (this._m12 = t._m12),
        this
      )
    }
    if (6 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5]
      return (
        (this._m00 = t),
        (this._m01 = e),
        (this._m02 = n),
        (this._m10 = i),
        (this._m11 = s),
        (this._m12 = r),
        this
      )
    }
  }
  setToRotation() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.setToRotation(Math.sin(t), Math.cos(t)), this
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return (
        (this._m00 = e),
        (this._m01 = -t),
        (this._m02 = 0),
        (this._m10 = t),
        (this._m11 = e),
        (this._m12 = 0),
        this
      )
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return this.setToRotation(Math.sin(t), Math.cos(t), e, n), this
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      return (
        (this._m00 = e),
        (this._m01 = -t),
        (this._m02 = n - n * e + i * t),
        (this._m10 = t),
        (this._m11 = e),
        (this._m12 = i - n * t - i * e),
        this
      )
    }
  }
  getMatrixEntries() {
    return [this._m00, this._m01, this._m02, this._m10, this._m11, this._m12]
  }
  filter(t, e) {
    this.transform(t, e)
  }
  rotate() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.compose(_d.rotationInstance(t)), this
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.compose(_d.rotationInstance(t, e)), this
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return this.compose(_d.rotationInstance(t, e, n)), this
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      return this.compose(_d.rotationInstance(t, e, n, i)), this
    }
  }
  getDeterminant() {
    return this._m00 * this._m11 - this._m01 * this._m10
  }
  composeBefore(t) {
    const e = this._m00 * t._m00 + this._m01 * t._m10,
      n = this._m00 * t._m01 + this._m01 * t._m11,
      i = this._m00 * t._m02 + this._m01 * t._m12 + this._m02,
      s = this._m10 * t._m00 + this._m11 * t._m10,
      r = this._m10 * t._m01 + this._m11 * t._m11,
      o = this._m10 * t._m02 + this._m11 * t._m12 + this._m12
    return (
      (this._m00 = e),
      (this._m01 = n),
      (this._m02 = i),
      (this._m10 = s),
      (this._m11 = r),
      (this._m12 = o),
      this
    )
  }
  setToShear(t, e) {
    return (
      (this._m00 = 1),
      (this._m01 = t),
      (this._m02 = 0),
      (this._m10 = e),
      (this._m11 = 1),
      (this._m12 = 0),
      this
    )
  }
  isDone() {
    return !1
  }
  clone() {
    try {
      return null
    } catch (t) {
      if (!(t instanceof wc)) throw t
      Cc.shouldNeverReachHere()
    }
    return null
  }
  translate(t, e) {
    return this.compose(_d.translationInstance(t, e)), this
  }
  setToReflection() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (0 === t && 0 === e) throw new Ec('Reflection vector must be non-zero')
      if (t === e)
        return (
          (this._m00 = 0),
          (this._m01 = 1),
          (this._m02 = 0),
          (this._m10 = 1),
          (this._m11 = 0),
          (this._m12 = 0),
          this
        )
      const n = Math.sqrt(t * t + e * e),
        i = e / n,
        s = t / n
      return this.rotate(-i, s), this.scale(1, -1), this.rotate(i, s), this
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      if (t === n && e === i) throw new Ec('Reflection line points must be distinct')
      this.setToTranslation(-t, -e)
      const s = n - t,
        r = i - e,
        o = Math.sqrt(s * s + r * r),
        a = r / o,
        l = s / o
      return this.rotate(-a, l), this.scale(1, -1), this.rotate(a, l), this.translate(t, e), this
    }
  }
  toString() {
    return (
      'AffineTransformation[[' +
      this._m00 +
      ', ' +
      this._m01 +
      ', ' +
      this._m02 +
      '], [' +
      this._m10 +
      ', ' +
      this._m11 +
      ', ' +
      this._m12 +
      ']]'
    )
  }
  setToTranslation(t, e) {
    return (
      (this._m00 = 1),
      (this._m01 = 0),
      (this._m02 = t),
      (this._m10 = 0),
      (this._m11 = 1),
      (this._m12 = e),
      this
    )
  }
  shear(t, e) {
    return this.compose(_d.shearInstance(t, e)), this
  }
  transform() {
    if (1 === arguments.length) {
      const t = arguments[0].copy()
      return t.apply(this), t
    }
    if (2 === arguments.length) {
      if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
        const t = arguments[0],
          e = arguments[1],
          n = this._m00 * t.x + this._m01 * t.y + this._m02,
          i = this._m10 * t.x + this._m11 * t.y + this._m12
        return (e.x = n), (e.y = i), e
      }
      if (Uc(arguments[0], eu) && Number.isInteger(arguments[1])) {
        const t = arguments[0],
          e = arguments[1],
          n = this._m00 * t.getOrdinate(e, 0) + this._m01 * t.getOrdinate(e, 1) + this._m02,
          i = this._m10 * t.getOrdinate(e, 0) + this._m11 * t.getOrdinate(e, 1) + this._m12
        t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i)
      }
    }
  }
  reflect() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.compose(_d.reflectionInstance(t, e)), this
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      return this.compose(_d.reflectionInstance(t, e, n, i)), this
    }
  }
  get interfaces_() {
    return [Ac, Zc]
  }
}
class wd {
  static solve(t, e) {
    const n = e.length
    if (t.length !== n || t[0].length !== n) throw new Ec('Matrix A is incorrectly sized')
    for (let i = 0; i < n; i++) {
      let s = i
      for (let e = i + 1; e < n; e++) Math.abs(t[e][i]) > Math.abs(t[s][i]) && (s = e)
      if (0 === t[s][i]) return null
      wd.swapRows(t, i, s), wd.swapRows(e, i, s)
      for (let s = i + 1; s < n; s++) {
        const r = t[s][i] / t[i][i]
        for (let e = n - 1; e >= i; e--) t[s][e] -= t[i][e] * r
        e[s] -= e[i] * r
      }
    }
    const i = new Array(n).fill(null)
    for (let s = n - 1; s >= 0; s--) {
      let r = 0
      for (let e = s + 1; e < n; e++) r += t[s][e] * i[e]
      i[s] = (e[s] - r) / t[s][s]
    }
    return i
  }
  static swapRows() {
    if (
      Number.isInteger(arguments[2]) &&
      arguments[0] instanceof Array &&
      Number.isInteger(arguments[1])
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (e === n) return null
      for (let i = 0; i < t[0].length; i++) {
        const s = t[e][i]
        ;(t[e][i] = t[n][i]), (t[n][i] = s)
      }
    } else if (
      Number.isInteger(arguments[2]) &&
      arguments[0] instanceof Array &&
      Number.isInteger(arguments[1])
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (e === n) return null
      const i = t[e]
      ;(t[e] = t[n]), (t[n] = i)
    }
  }
}
class Ed {
  constructor() {
    Ed.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._src0 = null),
      (this._src1 = null),
      (this._src2 = null),
      (this._dest0 = null),
      (this._dest1 = null),
      (this._dest2 = null),
      (this._m00 = null),
      (this._m01 = null),
      (this._m02 = null),
      (this._m10 = null),
      (this._m11 = null),
      (this._m12 = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2],
      i = arguments[3],
      s = arguments[4],
      r = arguments[5]
    ;(this._src0 = t),
      (this._src1 = e),
      (this._src2 = n),
      (this._dest0 = i),
      (this._dest1 = s),
      (this._dest2 = r)
  }
  solve(t) {
    const e = [
      [this._src0.x, this._src0.y, 1],
      [this._src1.x, this._src1.y, 1],
      [this._src2.x, this._src2.y, 1]
    ]
    return wd.solve(e, t)
  }
  compute() {
    const t = [this._dest0.x, this._dest1.x, this._dest2.x],
      e = this.solve(t)
    if (null === e) return !1
    ;(this._m00 = e[0]), (this._m01 = e[1]), (this._m02 = e[2])
    const n = [this._dest0.y, this._dest1.y, this._dest2.y],
      i = this.solve(n)
    return null !== i && ((this._m10 = i[0]), (this._m11 = i[1]), (this._m12 = i[2]), !0)
  }
  getTransformation() {
    return this.compute()
      ? new _d(this._m00, this._m01, this._m02, this._m10, this._m11, this._m12)
      : null
  }
}
class bd {
  static createFromBaseLines(t, e, n, i) {
    const s = new Oc(t.x + i.x - n.x, t.y + i.y - n.y),
      r = fd.angleBetweenOriented(e, t, s),
      o = e.distance(t),
      a = i.distance(n)
    if (0 === o) return new _d()
    const l = a / o,
      h = _d.translationInstance(-t.x, -t.y)
    return h.rotate(r), h.scale(l, l), h.translate(n.x, n.y), h
  }
  static createFromControlVectors() {
    if (2 === arguments.length) {
      if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
        const t = arguments[0],
          e = arguments[1],
          n = e.x - t.x,
          i = e.y - t.y
        return _d.translationInstance(n, i)
      }
      if (arguments[0] instanceof Array && arguments[1] instanceof Array) {
        const t = arguments[0],
          e = arguments[1]
        if (t.length !== e.length) throw new Ec('Src and Dest arrays are not the same length')
        if (t.length <= 0) throw new Ec('Too few control points')
        if (t.length > 3) throw new Ec('Too many control points')
        return 1 === t.length
          ? bd.createFromControlVectors(t[0], e[0])
          : 2 === t.length
            ? bd.createFromControlVectors(t[0], t[1], e[0], e[1])
            : bd.createFromControlVectors(t[0], t[1], t[2], e[0], e[1], e[2])
      }
    } else {
      if (4 === arguments.length) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = arguments[3],
          s = new Oc(i.x - n.x, i.y - n.y),
          r = fd.angleBetweenOriented(e, t, s),
          o = e.distance(t),
          a = i.distance(n)
        if (0 === o) return null
        const l = a / o,
          h = _d.translationInstance(-t.x, -t.y)
        return h.rotate(r), h.scale(l, l), h.translate(n.x, n.y), h
      }
      if (6 === arguments.length) {
        return new Ed(
          arguments[0],
          arguments[1],
          arguments[2],
          arguments[3],
          arguments[4],
          arguments[5]
        ).getTransformation()
      }
    }
  }
}
class Md {
  constructor() {
    Md.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._coords = null
    const t = arguments[0]
    this._coords = t
  }
  static getCoordinates(t) {
    const e = new Yc()
    return t.apply(new Md(e)), e
  }
  filter(t) {
    ;(t instanceof mu || t instanceof xu) && this._coords.add(t.getCoordinate())
  }
  get interfaces_() {
    return [lu]
  }
}
class Sd {
  constructor() {
    Sd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._mapOp = null
    const t = arguments[0]
    this._mapOp = t
  }
  static map(t, e) {
    return new Sd(e).map(t)
  }
  map(t) {
    const e = new Yc()
    for (let n = 0; n < t.getNumGeometries(); n++) {
      const i = this._mapOp.map(t.getGeometryN(n))
      i.isEmpty() || e.add(i)
    }
    return t.getFactory().createGeometryCollection(ku.toGeometryArray(e))
  }
}
class Ad {
  constructor() {
    Ad.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geomFactory = null), (this._skipEmpty = !1), (this._inputGeoms = null)
    const t = arguments[0]
    ;(this._geomFactory = Ad.extractFactory(t)), (this._inputGeoms = t)
  }
  static combine() {
    if (1 === arguments.length) {
      return new Ad(arguments[0]).combine()
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return new Ad(Ad.createList(t, e)).combine()
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return new Ad(Ad.createList(t, e, n)).combine()
    }
  }
  static extractFactory(t) {
    return t.isEmpty() ? null : t.iterator().next().getFactory()
  }
  static createList() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new Yc()
      return n.add(t), n.add(e), n
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = new Yc()
      return i.add(t), i.add(e), i.add(n), i
    }
  }
  extractElements(t, e) {
    if (null === t) return null
    for (let n = 0; n < t.getNumGeometries(); n++) {
      const i = t.getGeometryN(n)
      ;(this._skipEmpty && i.isEmpty()) || e.add(i)
    }
  }
  combine() {
    const t = new Yc()
    for (let e = this._inputGeoms.iterator(); e.hasNext(); ) {
      const n = e.next()
      this.extractElements(n, t)
    }
    return 0 === t.size()
      ? null !== this._geomFactory
        ? this._geomFactory.createGeometryCollection()
        : null
      : this._geomFactory.buildGeometry(t)
  }
}
class Td {
  constructor() {
    Td.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._factory = null), (this._isUserDataCopied = !1), 0 === arguments.length));
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._factory = t
    }
  }
  setCopyUserData(t) {
    this._isUserDataCopied = t
  }
  edit(t, e) {
    if (null === t) return null
    const n = this.editInternal(t, e)
    return this._isUserDataCopied && n.setUserData(t.getUserData()), n
  }
  editInternal(t, e) {
    return (
      null === this._factory && (this._factory = t.getFactory()),
      t instanceof Tu
        ? this.editGeometryCollection(t, e)
        : t instanceof Eu
          ? this.editPolygon(t, e)
          : t instanceof xu || t instanceof mu
            ? e.edit(t, this._factory)
            : (Cc.shouldNeverReachHere('Unsupported Geometry type: ' + t.getGeometryType()), null)
    )
  }
  editGeometryCollection(t, e) {
    const n = e.edit(t, this._factory),
      i = new Yc()
    for (let t = 0; t < n.getNumGeometries(); t++) {
      const s = this.edit(n.getGeometryN(t), e)
      null === s || s.isEmpty() || i.add(s)
    }
    return n.getGeometryType() === hu.TYPENAME_MULTIPOINT
      ? this._factory.createMultiPoint(i.toArray([]))
      : n.getGeometryType() === hu.TYPENAME_MULTILINESTRING
        ? this._factory.createMultiLineString(i.toArray([]))
        : n.getGeometryType() === hu.TYPENAME_MULTIPOLYGON
          ? this._factory.createMultiPolygon(i.toArray([]))
          : this._factory.createGeometryCollection(i.toArray([]))
  }
  editPolygon(t, e) {
    let n = e.edit(t, this._factory)
    if ((null === n && (n = this._factory.createPolygon()), n.isEmpty())) return n
    const i = this.edit(n.getExteriorRing(), e)
    if (null === i || i.isEmpty()) return this._factory.createPolygon()
    const s = new Yc()
    for (let t = 0; t < n.getNumInteriorRing(); t++) {
      const i = this.edit(n.getInteriorRingN(t), e)
      null === i || i.isEmpty() || s.add(i)
    }
    return this._factory.createPolygon(i, s.toArray([]))
  }
}
function Id() {}
Td.GeometryEditorOperation = Id
;(Td.NoOpGeometryOperation = class {
  edit(t, e) {
    return t
  }
  get interfaces_() {
    return [Id]
  }
}),
  (Td.CoordinateOperation = class {
    edit(t, e) {
      const n = this.edit(t.getCoordinates(), t)
      return t instanceof Ru
        ? null === n
          ? e.createLinearRing()
          : e.createLinearRing(n)
        : t instanceof mu
          ? null === n
            ? e.createLineString()
            : e.createLineString(n)
          : t instanceof xu
            ? null === n || 0 === n.length
              ? e.createPoint()
              : e.createPoint(n[0])
            : t
    }
    get interfaces_() {
      return [Id]
    }
  }),
  (Td.CoordinateSequenceOperation = class {
    edit(t, e) {
      return t instanceof Ru
        ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t))
        : t instanceof mu
          ? e.createLineString(this.edit(t.getCoordinateSequence(), t))
          : t instanceof xu
            ? e.createPoint(this.edit(t.getCoordinateSequence(), t))
            : t
    }
    get interfaces_() {
      return [Id]
    }
  })
class Rd {
  constructor() {
    Rd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geometryType = null), (this._comps = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._geometryType = t), (this._comps = e)
  }
  static isOfType(t, e) {
    return (
      t.getGeometryType() === e ||
      (e === hu.TYPENAME_LINESTRING && t.getGeometryType() === hu.TYPENAME_LINEARRING)
    )
  }
  static extract() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return Rd.extract(t, e, new Yc())
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return t.getGeometryType() === e ? n.add(t) : t instanceof Tu && t.apply(new Rd(e, n)), n
    }
  }
  filter(t) {
    ;(null === this._geometryType || Rd.isOfType(t, this._geometryType)) && this._comps.add(t)
  }
  get interfaces_() {
    return [fu]
  }
}
class Ld {
  static map() {
    if (arguments[0] instanceof hu && Uc(arguments[1], Cd)) {
      const t = arguments[0],
        e = arguments[1],
        n = new Yc()
      for (let i = 0; i < t.getNumGeometries(); i++) {
        const s = e.map(t.getGeometryN(i))
        null !== s && n.add(s)
      }
      return t.getFactory().buildGeometry(n)
    }
    if (Uc(arguments[0], Vc) && Uc(arguments[1], Cd)) {
      const t = arguments[0],
        e = arguments[1],
        n = new Yc()
      for (let i = t.iterator(); i.hasNext(); ) {
        const t = i.next(),
          s = e.map(t)
        null !== s && n.add(s)
      }
      return n
    }
  }
}
function Cd() {}
Ld.MapOp = Cd
class Nd {
  constructor() {
    Nd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null),
      (this._factory = null),
      (this._pruneEmptyGeometry = !0),
      (this._preserveGeometryCollectionType = !0),
      (this._preserveCollections = !1),
      (this._preserveType = !1)
  }
  transformPoint(t, e) {
    return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
  }
  transformPolygon(t, e) {
    let n = !0
    const i = this.transformLinearRing(t.getExteriorRing(), t)
    ;(null !== i && i instanceof Ru && !i.isEmpty()) || (n = !1)
    const s = new Yc()
    for (let e = 0; e < t.getNumInteriorRing(); e++) {
      const i = this.transformLinearRing(t.getInteriorRingN(e), t)
      null === i || i.isEmpty() || (i instanceof Ru || (n = !1), s.add(i))
    }
    if (n) return this._factory.createPolygon(i, s.toArray([]))
    {
      const t = new Yc()
      return null !== i && t.add(i), t.addAll(s), this._factory.buildGeometry(t)
    }
  }
  createCoordinateSequence(t) {
    return this._factory.getCoordinateSequenceFactory().create(t)
  }
  getInputGeometry() {
    return this._inputGeom
  }
  transformMultiLineString(t, e) {
    const n = new Yc()
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const i = this.transformLineString(t.getGeometryN(e), t)
      null !== i && (i.isEmpty() || n.add(i))
    }
    return this._factory.buildGeometry(n)
  }
  transformCoordinates(t, e) {
    return this.copy(t)
  }
  transformLineString(t, e) {
    return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
  }
  transformMultiPoint(t, e) {
    const n = new Yc()
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const i = this.transformPoint(t.getGeometryN(e), t)
      null !== i && (i.isEmpty() || n.add(i))
    }
    return this._factory.buildGeometry(n)
  }
  transformMultiPolygon(t, e) {
    const n = new Yc()
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const i = this.transformPolygon(t.getGeometryN(e), t)
      null !== i && (i.isEmpty() || n.add(i))
    }
    return this._factory.buildGeometry(n)
  }
  copy(t) {
    return t.copy()
  }
  transformGeometryCollection(t, e) {
    const n = new Yc()
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const i = this.transform(t.getGeometryN(e))
      null !== i && ((this._pruneEmptyGeometry && i.isEmpty()) || n.add(i))
    }
    return this._preserveGeometryCollectionType
      ? this._factory.createGeometryCollection(ku.toGeometryArray(n))
      : this._factory.buildGeometry(n)
  }
  transform(t) {
    if (((this._inputGeom = t), (this._factory = t.getFactory()), t instanceof xu))
      return this.transformPoint(t, null)
    if (t instanceof Iu) return this.transformMultiPoint(t, null)
    if (t instanceof Ru) return this.transformLinearRing(t, null)
    if (t instanceof mu) return this.transformLineString(t, null)
    if (t instanceof Hu) return this.transformMultiLineString(t, null)
    if (t instanceof Eu) return this.transformPolygon(t, null)
    if (t instanceof Ou) return this.transformMultiPolygon(t, null)
    if (t instanceof Tu) return this.transformGeometryCollection(t, null)
    throw new Ec('Unknown Geometry subtype: ' + t.getGeometryType())
  }
  transformLinearRing(t, e) {
    const n = this.transformCoordinates(t.getCoordinateSequence(), t)
    if (null === n) return this._factory.createLinearRing(null)
    const i = n.size()
    return i > 0 && i < 4 && !this._preserveType
      ? this._factory.createLineString(n)
      : this._factory.createLinearRing(n)
  }
}
class Pd {
  constructor() {
    Pd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._comps = null
    const t = arguments[0]
    this._comps = t
  }
  static getGeometry(t) {
    return t.getFactory().buildGeometry(Pd.getLines(t))
  }
  static getLines() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Pd.getLines(t, new Yc())
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return t instanceof mu ? e.add(t) : t instanceof Tu && t.apply(new Pd(e)), e
    }
  }
  filter(t) {
    t instanceof mu && this._comps.add(t)
  }
  get interfaces_() {
    return [fu]
  }
}
class Dd {
  constructor() {
    Dd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._lines = null), (this._isForcedToLineString = !1), 1 === arguments.length)) {
      const t = arguments[0]
      this._lines = t
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._lines = t), (this._isForcedToLineString = e)
    }
  }
  static getGeometry() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return t.getFactory().buildGeometry(Dd.getLines(t))
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return t.getFactory().buildGeometry(Dd.getLines(t, e))
    }
  }
  static getLines() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Dd.getLines(t, !1)
    }
    if (2 === arguments.length) {
      if (Uc(arguments[0], Vc) && Uc(arguments[1], Vc)) {
        const t = arguments[1]
        for (let e = arguments[0].iterator(); e.hasNext(); ) {
          const n = e.next()
          Dd.getLines(n, t)
        }
        return t
      }
      if (arguments[0] instanceof hu && 'boolean' == typeof arguments[1]) {
        const t = arguments[0],
          e = arguments[1],
          n = new Yc()
        return t.apply(new Dd(n, e)), n
      }
      if (arguments[0] instanceof hu && Uc(arguments[1], Vc)) {
        const t = arguments[0],
          e = arguments[1]
        return t instanceof mu ? e.add(t) : t.apply(new Dd(e)), e
      }
    } else if (3 === arguments.length) {
      if ('boolean' == typeof arguments[2] && Uc(arguments[0], Vc) && Uc(arguments[1], Vc)) {
        const t = arguments[1],
          e = arguments[2]
        for (let n = arguments[0].iterator(); n.hasNext(); ) {
          const i = n.next()
          Dd.getLines(i, t, e)
        }
        return t
      }
      if ('boolean' == typeof arguments[2] && arguments[0] instanceof hu && Uc(arguments[1], Vc)) {
        const t = arguments[1],
          e = arguments[2]
        return arguments[0].apply(new Dd(t, e)), t
      }
    }
  }
  filter(t) {
    if (this._isForcedToLineString && t instanceof Ru) {
      const e = t.getFactory().createLineString(t.getCoordinateSequence())
      return this._lines.add(e), null
    }
    t instanceof mu && this._lines.add(t)
  }
  setForceToLineString(t) {
    this._isForcedToLineString = t
  }
  get interfaces_() {
    return [lu]
  }
}
const Od = {
  reverseOrder: function () {
    return { compare: (t, e) => e.compareTo(t) }
  },
  min: function (t) {
    return Od.sort(t), t.get(0)
  },
  sort: function (t, e) {
    const n = t.toArray()
    e ? _u.sort(n, e) : _u.sort(n)
    const i = t.iterator()
    for (let t = 0, e = n.length; t < e; t++) i.next(), i.set(n[t])
  },
  singletonList: function (t) {
    const e = new Yc()
    return e.add(t), e
  }
}
class Fd {
  constructor() {
    Fd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._pts = null
    const t = arguments[0]
    this._pts = t
  }
  static getPoints() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return t instanceof xu ? Od.singletonList(t) : Fd.getPoints(t, new Yc())
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return t instanceof xu ? e.add(t) : t instanceof Tu && t.apply(new Fd(e)), e
    }
  }
  filter(t) {
    t instanceof xu && this._pts.add(t)
  }
  get interfaces_() {
    return [fu]
  }
}
class Gd {
  constructor() {
    Gd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._comps = null
    const t = arguments[0]
    this._comps = t
  }
  static getPolygons() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Gd.getPolygons(t, new Yc())
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return t instanceof Eu ? e.add(t) : t instanceof Tu && t.apply(new Gd(e)), e
    }
  }
  filter(t) {
    t instanceof Eu && this._comps.add(t)
  }
  get interfaces_() {
    return [fu]
  }
}
class zd {
  constructor() {
    zd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._isDone = !1
  }
  applyTo(t) {
    for (let e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
      const n = t.getGeometryN(e)
      if (n instanceof Tu) this.applyTo(n)
      else if ((this.visit(n), this.isDone())) return (this._isDone = !0), null
    }
  }
}
class Bd {
  constructor() {
    Bd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._geomFact = null),
      (this._precModel = null),
      (this._dim = new Ud()),
      (this._nPts = 100),
      (this._rotationAngle = 0),
      0 === arguments.length)
    )
      Bd.constructor_.call(this, new ku())
    else if (1 === arguments.length) {
      const t = arguments[0]
      ;(this._geomFact = t), (this._precModel = t.getPrecisionModel())
    }
  }
  createSupercircle(t) {
    const e = 1 / t,
      n = this._dim.getMinSize() / 2,
      i = this._dim.getCentre(),
      s = Math.pow(n, t),
      r = n,
      o = Math.pow(s / 2, e),
      a = Math.trunc(this._nPts / 8),
      l = new Array(8 * a + 1).fill(null),
      h = o / a
    for (let n = 0; n <= a; n++) {
      let o = 0,
        c = r
      if (0 !== n) {
        o = h * n
        const i = Math.pow(o, t)
        c = Math.pow(s - i, e)
      }
      ;(l[n] = this.coordTrans(o, c, i)),
        (l[2 * a - n] = this.coordTrans(c, o, i)),
        (l[2 * a + n] = this.coordTrans(c, -o, i)),
        (l[4 * a - n] = this.coordTrans(o, -c, i)),
        (l[4 * a + n] = this.coordTrans(-o, -c, i)),
        (l[6 * a - n] = this.coordTrans(-c, -o, i)),
        (l[6 * a + n] = this.coordTrans(-c, o, i)),
        (l[8 * a - n] = this.coordTrans(-o, c, i))
    }
    l[l.length - 1] = new Oc(l[0])
    const c = this._geomFact.createLinearRing(l),
      u = this._geomFact.createPolygon(c)
    return this.rotate(u)
  }
  setNumPoints(t) {
    this._nPts = t
  }
  setBase(t) {
    this._dim.setBase(t)
  }
  setRotation(t) {
    this._rotationAngle = t
  }
  setWidth(t) {
    this._dim.setWidth(t)
  }
  createEllipse() {
    const t = this._dim.getEnvelope(),
      e = t.getWidth() / 2,
      n = t.getHeight() / 2,
      i = t.getMinX() + e,
      s = t.getMinY() + n,
      r = new Array(this._nPts + 1).fill(null)
    let o = 0
    for (let t = 0; t < this._nPts; t++) {
      const a = t * ((2 * Math.PI) / this._nPts),
        l = e * Math.cos(a) + i,
        h = n * Math.sin(a) + s
      r[o++] = this.coord(l, h)
    }
    r[o] = new Oc(r[0])
    const a = this._geomFact.createLinearRing(r),
      l = this._geomFact.createPolygon(a)
    return this.rotate(l)
  }
  coordTrans(t, e, n) {
    return this.coord(t + n.x, e + n.y)
  }
  createSquircle() {
    return this.createSupercircle(4)
  }
  setEnvelope(t) {
    this._dim.setEnvelope(t)
  }
  setCentre(t) {
    this._dim.setCentre(t)
  }
  createArc(t, e) {
    const n = this._dim.getEnvelope(),
      i = n.getWidth() / 2,
      s = n.getHeight() / 2,
      r = n.getMinX() + i,
      o = n.getMinY() + s
    let a = e
    ;(a <= 0 || a > 2 * Math.PI) && (a = 2 * Math.PI)
    const l = a / (this._nPts - 1),
      h = new Array(this._nPts).fill(null)
    let c = 0
    for (let e = 0; e < this._nPts; e++) {
      const n = t + e * l,
        a = i * Math.cos(n) + r,
        u = s * Math.sin(n) + o
      h[c++] = this.coord(a, u)
    }
    const u = this._geomFact.createLineString(h)
    return this.rotate(u)
  }
  rotate(t) {
    if (0 !== this._rotationAngle) {
      const e = _d.rotationInstance(
        this._rotationAngle,
        this._dim.getCentre().x,
        this._dim.getCentre().y
      )
      t.apply(e)
    }
    return t
  }
  coord(t, e) {
    const n = new Oc(t, e)
    return this._precModel.makePrecise(n), n
  }
  createArcPolygon(t, e) {
    const n = this._dim.getEnvelope(),
      i = n.getWidth() / 2,
      s = n.getHeight() / 2,
      r = n.getMinX() + i,
      o = n.getMinY() + s
    let a = e
    ;(a <= 0 || a > 2 * Math.PI) && (a = 2 * Math.PI)
    const l = a / (this._nPts - 1),
      h = new Array(this._nPts + 2).fill(null)
    let c = 0
    h[c++] = this.coord(r, o)
    for (let e = 0; e < this._nPts; e++) {
      const n = t + l * e,
        a = i * Math.cos(n) + r,
        u = s * Math.sin(n) + o
      h[c++] = this.coord(a, u)
    }
    h[c++] = this.coord(r, o)
    const u = this._geomFact.createLinearRing(h),
      d = this._geomFact.createPolygon(u)
    return this.rotate(d)
  }
  createRectangle() {
    let t = null,
      e = 0,
      n = Math.trunc(this._nPts / 4)
    n < 1 && (n = 1)
    const i = this._dim.getEnvelope().getWidth() / n,
      s = this._dim.getEnvelope().getHeight() / n,
      r = new Array(4 * n + 1).fill(null),
      o = this._dim.getEnvelope()
    for (t = 0; t < n; t++) {
      const n = o.getMinX() + t * i,
        s = o.getMinY()
      r[e++] = this.coord(n, s)
    }
    for (t = 0; t < n; t++) {
      const n = o.getMaxX(),
        i = o.getMinY() + t * s
      r[e++] = this.coord(n, i)
    }
    for (t = 0; t < n; t++) {
      const n = o.getMaxX() - t * i,
        s = o.getMaxY()
      r[e++] = this.coord(n, s)
    }
    for (t = 0; t < n; t++) {
      const n = o.getMinX(),
        i = o.getMaxY() - t * s
      r[e++] = this.coord(n, i)
    }
    r[e++] = new Oc(r[0])
    const a = this._geomFact.createLinearRing(r),
      l = this._geomFact.createPolygon(a)
    return this.rotate(l)
  }
  createCircle() {
    return this.createEllipse()
  }
  setHeight(t) {
    this._dim.setHeight(t)
  }
  setSize(t) {
    this._dim.setSize(t)
  }
}
class Ud {
  constructor() {
    Ud.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.base = null), (this.centre = null), (this.width = null), (this.height = null)
  }
  setBase(t) {
    this.base = t
  }
  setWidth(t) {
    this.width = t
  }
  getBase() {
    return this.base
  }
  getWidth() {
    return this.width
  }
  setEnvelope(t) {
    ;(this.width = t.getWidth()),
      (this.height = t.getHeight()),
      (this.base = new Oc(t.getMinX(), t.getMinY())),
      (this.centre = new Oc(t.centre()))
  }
  setCentre(t) {
    this.centre = t
  }
  getMinSize() {
    return Math.min(this.width, this.height)
  }
  getEnvelope() {
    return null !== this.base
      ? new Xc(this.base.x, this.base.x + this.width, this.base.y, this.base.y + this.height)
      : null !== this.centre
        ? new Xc(
            this.centre.x - this.width / 2,
            this.centre.x + this.width / 2,
            this.centre.y - this.height / 2,
            this.centre.y + this.height / 2
          )
        : new Xc(0, this.width, 0, this.height)
  }
  getCentre() {
    return (
      null === this.centre &&
        (this.centre = new Oc(this.base.x + this.width / 2, this.base.y + this.height / 2)),
      this.centre
    )
  }
  getHeight() {
    return this.height
  }
  setHeight(t) {
    this.height = t
  }
  setSize(t) {
    ;(this.height = t), (this.width = t)
  }
}
Bd.Dimensions = Ud
class Vd extends Bd {
  constructor() {
    super(), Vd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._numArms = 8), (this._armLengthRatio = 0.5), 0 === arguments.length))
      Bd.constructor_.call(this)
    else if (1 === arguments.length) {
      const t = arguments[0]
      Bd.constructor_.call(this, t)
    }
  }
  static create(t, e, n, i, s) {
    const r = new Vd()
    r.setCentre(t), r.setSize(e), r.setNumPoints(n), r.setArmLengthRatio(s), r.setNumArms(i)
    return r.createSineStar()
  }
  setNumArms(t) {
    this._numArms = t
  }
  setArmLengthRatio(t) {
    this._armLengthRatio = t
  }
  createSineStar() {
    const t = this._dim.getEnvelope(),
      e = t.getWidth() / 2
    let n = this._armLengthRatio
    n < 0 && (n = 0), n > 1 && (n = 1)
    const i = n * e,
      s = (1 - n) * e,
      r = t.getMinX() + e,
      o = t.getMinY() + e,
      a = new Array(this._nPts + 1).fill(null)
    let l = 0
    for (let t = 0; t < this._nPts; t++) {
      const e = (t / this._nPts) * this._numArms,
        n = e - Math.floor(e),
        h = 2 * Math.PI * n,
        c = s + i * ((Math.cos(h) + 1) / 2),
        u = t * ((2 * Math.PI) / this._nPts),
        d = c * Math.cos(u) + r,
        p = c * Math.sin(u) + o
      a[l++] = this.coord(d, p)
    }
    a[l] = new Oc(a[0])
    const h = this._geomFact.createLinearRing(a)
    return this._geomFact.createPolygon(h)
  }
}
var Hd = Object.freeze({
    __proto__: null,
    AffineTransformation: _d,
    AffineTransformationBuilder: Ed,
    AffineTransformationFactory: bd,
    ComponentCoordinateExtracter: Md,
    GeometryCollectionMapper: Sd,
    GeometryCombiner: Ad,
    GeometryEditor: Td,
    GeometryExtracter: Rd,
    GeometryMapper: Ld,
    GeometryTransformer: Nd,
    LineStringExtracter: Pd,
    LinearComponentExtracter: Dd,
    PointExtracter: Fd,
    PolygonExtracter: Gd,
    ShortCircuitedGeometryVisitor: zd,
    SineStarFactory: Vd
  }),
  kd = Object.freeze({
    __proto__: null,
    Coordinate: Oc,
    CoordinateXY: Gc,
    CoordinateXYM: zc,
    CoordinateXYZM: Bc,
    CoordinateList: qc,
    CoordinateSequenceFilter: Zc,
    Envelope: Xc,
    LineSegment: dd,
    GeometryFactory: ku,
    Geometry: hu,
    Point: xu,
    LineString: mu,
    LinearRing: Ru,
    Polygon: Eu,
    GeometryCollection: Tu,
    MultiPoint: Iu,
    MultiLineString: Hu,
    MultiPolygon: Ou,
    Dimension: gu,
    IntersectionMatrix: gd,
    PrecisionModel: Uu,
    Location: pd,
    Triangle: xd,
    util: Hd
  })
class Wd {
  constructor() {
    Wd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pt = [new Oc(), new Oc()]), (this._distance = Mc.NaN), (this._isNull = !0)
  }
  getCoordinates() {
    return this._pt
  }
  getCoordinate(t) {
    return this._pt[t]
  }
  setMinimum() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.setMinimum(t._pt[0], t._pt[1])
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (this._isNull) return this.initialize(t, e), null
      const n = t.distance(e)
      n < this._distance && this.initialize(t, e, n)
    }
  }
  initialize() {
    if (0 === arguments.length) this._isNull = !0
    else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this._pt[0].setCoordinate(t),
        this._pt[1].setCoordinate(e),
        (this._distance = t.distance(e)),
        (this._isNull = !1)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this._pt[0].setCoordinate(t),
        this._pt[1].setCoordinate(e),
        (this._distance = n),
        (this._isNull = !1)
    }
  }
  toString() {
    return hd.toLineString(this._pt[0], this._pt[1])
  }
  getDistance() {
    return this._distance
  }
  setMaximum() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.setMaximum(t._pt[0], t._pt[1])
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (this._isNull) return this.initialize(t, e), null
      const n = t.distance(e)
      n > this._distance && this.initialize(t, e, n)
    }
  }
}
class Yd {
  static computeDistance() {
    if (arguments[2] instanceof Wd && arguments[0] instanceof mu && arguments[1] instanceof Oc) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = new dd(),
        s = t.getCoordinates()
      for (let t = 0; t < s.length - 1; t++) {
        i.setCoordinates(s[t], s[t + 1])
        const r = i.closestPoint(e)
        n.setMinimum(r, e)
      }
    } else if (
      arguments[2] instanceof Wd &&
      arguments[0] instanceof Eu &&
      arguments[1] instanceof Oc
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      Yd.computeDistance(t.getExteriorRing(), e, n)
      for (let i = 0; i < t.getNumInteriorRing(); i++)
        Yd.computeDistance(t.getInteriorRingN(i), e, n)
    } else if (
      arguments[2] instanceof Wd &&
      arguments[0] instanceof hu &&
      arguments[1] instanceof Oc
    ) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (t instanceof mu) Yd.computeDistance(t, e, n)
      else if (t instanceof Eu) Yd.computeDistance(t, e, n)
      else if (t instanceof Tu) {
        const i = t
        for (let t = 0; t < i.getNumGeometries(); t++) {
          const s = i.getGeometryN(t)
          Yd.computeDistance(s, e, n)
        }
      } else n.setMinimum(t.getCoordinate(), e)
    } else if (
      arguments[2] instanceof Wd &&
      arguments[0] instanceof dd &&
      arguments[1] instanceof Oc
    ) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[0].closestPoint(t)
      e.setMinimum(n, t)
    }
  }
}
class jd {
  constructor() {
    jd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._g0 = null), (this._g1 = null), (this._ptDist = new Wd()), (this._densifyFrac = 0)
    const t = arguments[0],
      e = arguments[1]
    ;(this._g0 = t), (this._g1 = e)
  }
  static distance() {
    if (2 === arguments.length) {
      return new jd(arguments[0], arguments[1]).distance()
    }
    if (3 === arguments.length) {
      const t = arguments[2],
        e = new jd(arguments[0], arguments[1])
      return e.setDensifyFraction(t), e.distance()
    }
  }
  getCoordinates() {
    return this._ptDist.getCoordinates()
  }
  setDensifyFraction(t) {
    if (t > 1 || t <= 0) throw new Ec('Fraction is not in range (0.0 - 1.0]')
    this._densifyFrac = t
  }
  compute(t, e) {
    this.computeOrientedDistance(t, e, this._ptDist),
      this.computeOrientedDistance(e, t, this._ptDist)
  }
  distance() {
    return this.compute(this._g0, this._g1), this._ptDist.getDistance()
  }
  computeOrientedDistance(t, e, n) {
    const i = new qd(e)
    if ((t.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0)) {
      const i = new Zd(e, this._densifyFrac)
      t.apply(i), n.setMaximum(i.getMaxPointDistance())
    }
  }
  orientedDistance() {
    return (
      this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance()
    )
  }
}
class qd {
  constructor() {
    qd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._maxPtDist = new Wd()),
      (this._minPtDist = new Wd()),
      (this._euclideanDist = new Yd()),
      (this._geom = null)
    const t = arguments[0]
    this._geom = t
  }
  filter(t) {
    this._minPtDist.initialize(),
      Yd.computeDistance(this._geom, t, this._minPtDist),
      this._maxPtDist.setMaximum(this._minPtDist)
  }
  getMaxPointDistance() {
    return this._maxPtDist
  }
  get interfaces_() {
    return [cu]
  }
}
class Zd {
  constructor() {
    Zd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._maxPtDist = new Wd()),
      (this._minPtDist = new Wd()),
      (this._geom = null),
      (this._numSubSegs = 0)
    const t = arguments[0],
      e = arguments[1]
    ;(this._geom = t), (this._numSubSegs = Math.trunc(Math.round(1 / e)))
  }
  filter(t, e) {
    if (0 === e) return null
    const n = t.getCoordinate(e - 1),
      i = t.getCoordinate(e),
      s = (i.x - n.x) / this._numSubSegs,
      r = (i.y - n.y) / this._numSubSegs
    for (let t = 0; t < this._numSubSegs; t++) {
      const e = n.x + t * s,
        i = n.y + t * r,
        o = new Oc(e, i)
      this._minPtDist.initialize(),
        Yd.computeDistance(this._geom, o, this._minPtDist),
        this._maxPtDist.setMaximum(this._minPtDist)
    }
  }
  isDone() {
    return !1
  }
  isGeometryChanged() {
    return !1
  }
  getMaxPointDistance() {
    return this._maxPtDist
  }
  get interfaces_() {
    return [Zc]
  }
}
;(jd.MaxPointDistanceFilter = qd), (jd.MaxDensifiedByFractionDistanceFilter = Zd)
class Xd {
  visitItem(t) {}
}
class Kd {
  locate(t) {}
}
class Jd {
  constructor() {
    Jd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._min = Mc.POSITIVE_INFINITY), (this._max = Mc.NEGATIVE_INFINITY)
  }
  getMin() {
    return this._min
  }
  intersects(t, e) {
    return !(this._min > e || this._max < t)
  }
  getMax() {
    return this._max
  }
  toString() {
    return hd.toLineString(new Oc(this._min, 0), new Oc(this._max, 0))
  }
}
Jd.NodeComparator = class {
  compare(t, e) {
    const n = t,
      i = e,
      s = (n._min + n._max) / 2,
      r = (i._min + i._max) / 2
    return s < r ? -1 : s > r ? 1 : 0
  }
  get interfaces_() {
    return [Tc]
  }
}
class Qd extends Jd {
  constructor() {
    super(), Qd.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._item = null
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._min = t), (this._max = e), (this._item = n)
  }
  query(t, e, n) {
    if (!this.intersects(t, e)) return null
    n.visitItem(this._item)
  }
}
class $d extends Jd {
  constructor() {
    super(), $d.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._node1 = null), (this._node2 = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._node1 = t), (this._node2 = e), this.buildExtent(this._node1, this._node2)
  }
  buildExtent(t, e) {
    ;(this._min = Math.min(t._min, e._min)), (this._max = Math.max(t._max, e._max))
  }
  query(t, e, n) {
    if (!this.intersects(t, e)) return null
    null !== this._node1 && this._node1.query(t, e, n),
      null !== this._node2 && this._node2.query(t, e, n)
  }
}
class tp {
  constructor() {
    tp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._leaves = new Yc()), (this._root = null), (this._level = 0)
  }
  buildTree() {
    Od.sort(this._leaves, new Jd.NodeComparator())
    let t = this._leaves,
      e = null,
      n = new Yc()
    for (;;) {
      if ((this.buildLevel(t, n), 1 === n.size())) return n.get(0)
      ;(e = t), (t = n), (n = e)
    }
  }
  insert(t, e, n) {
    if (null !== this._root)
      throw new IllegalStateException('Index cannot be added to once it has been queried')
    this._leaves.add(new Qd(t, e, n))
  }
  query(t, e, n) {
    if ((this.init(), null === this._root)) return null
    this._root.query(t, e, n)
  }
  buildRoot() {
    if (null !== this._root) return null
    this._root = this.buildTree()
  }
  printNode(t) {
    su.out.println(hd.toLineString(new Oc(t._min, this._level), new Oc(t._max, this._level)))
  }
  init() {
    return null !== this._root || 0 === this._leaves.size() ? null : void this.buildRoot()
  }
  buildLevel(t, e) {
    this._level++, e.clear()
    for (let n = 0; n < t.size(); n += 2) {
      const i = t.get(n)
      if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i)
      else {
        const i = new $d(t.get(n), t.get(n + 1))
        e.add(i)
      }
    }
  }
}
class ep {
  constructor() {
    ep.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._items = new Yc()
  }
  visitItem(t) {
    this._items.add(t)
  }
  getItems() {
    return this._items
  }
  get interfaces_() {
    return [Xd]
  }
}
class np {
  constructor() {
    np.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._p = null), (this._crossingCount = 0), (this._isPointOnSegment = !1)
    const t = arguments[0]
    this._p = t
  }
  static locatePointInRing() {
    if (arguments[0] instanceof Oc && Uc(arguments[1], eu)) {
      const t = arguments[1],
        e = new np(arguments[0]),
        n = new Oc(),
        i = new Oc()
      for (let s = 1; s < t.size(); s++)
        if (
          (t.getCoordinate(s, n), t.getCoordinate(s - 1, i), e.countSegment(n, i), e.isOnSegment())
        )
          return e.getLocation()
      return e.getLocation()
    }
    if (arguments[0] instanceof Oc && arguments[1] instanceof Array) {
      const t = arguments[1],
        e = new np(arguments[0])
      for (let n = 1; n < t.length; n++) {
        const i = t[n],
          s = t[n - 1]
        if ((e.countSegment(i, s), e.isOnSegment())) return e.getLocation()
      }
      return e.getLocation()
    }
  }
  countSegment(t, e) {
    if (t.x < this._p.x && e.x < this._p.x) return null
    if (this._p.x === e.x && this._p.y === e.y) return (this._isPointOnSegment = !0), null
    if (t.y === this._p.y && e.y === this._p.y) {
      let n = t.x,
        i = e.x
      return (
        n > i && ((n = e.x), (i = t.x)),
        this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0),
        null
      )
    }
    if ((t.y > this._p.y && e.y <= this._p.y) || (e.y > this._p.y && t.y <= this._p.y)) {
      let n = nu.index(t, e, this._p)
      if (n === nu.COLLINEAR) return (this._isPointOnSegment = !0), null
      e.y < t.y && (n = -n), n === nu.LEFT && this._crossingCount++
    }
  }
  isPointInPolygon() {
    return this.getLocation() !== pd.EXTERIOR
  }
  getLocation() {
    return this._isPointOnSegment
      ? pd.BOUNDARY
      : this._crossingCount % 2 == 1
        ? pd.INTERIOR
        : pd.EXTERIOR
  }
  isOnSegment() {
    return this._isPointOnSegment
  }
}
class ip {
  constructor() {
    ip.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geom = null), (this._index = null)
    const t = arguments[0]
    if (!(Uc(t, wu) || t instanceof Ru)) throw new Ec('Argument must be Polygonal or LinearRing')
    this._geom = t
  }
  locate(t) {
    null === this._index && ((this._index = new rp(this._geom)), (this._geom = null))
    const e = new np(t),
      n = new sp(e)
    return this._index.query(t.y, t.y, n), e.getLocation()
  }
  get interfaces_() {
    return [Kd]
  }
}
class sp {
  constructor() {
    sp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._counter = null
    const t = arguments[0]
    this._counter = t
  }
  visitItem(t) {
    const e = t
    this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
  }
  get interfaces_() {
    return [Xd]
  }
}
class rp {
  constructor() {
    rp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isEmpty = !1), (this._index = new tp())
    const t = arguments[0]
    t.isEmpty() ? (this._isEmpty = !0) : this.init(t)
  }
  init(t) {
    for (let e = Dd.getLines(t).iterator(); e.hasNext(); ) {
      const t = e.next().getCoordinates()
      this.addLine(t)
    }
  }
  addLine(t) {
    for (let e = 1; e < t.length; e++) {
      const n = new dd(t[e - 1], t[e]),
        i = Math.min(n.p0.y, n.p1.y),
        s = Math.max(n.p0.y, n.p1.y)
      this._index.insert(i, s, n)
    }
  }
  query() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (this._isEmpty) return new Yc()
      const n = new ep()
      return this._index.query(t, e, n), n.getItems()
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (this._isEmpty) return null
      this._index.query(t, e, n)
    }
  }
}
;(ip.SegmentVisitor = sp), (ip.IntervalIndexedGeometry = rp)
class op {
  static isOnLine() {
    if (arguments[0] instanceof Oc && Uc(arguments[1], eu)) {
      const t = arguments[0],
        e = arguments[1],
        n = new ud(),
        i = new Oc(),
        s = new Oc(),
        r = e.size()
      for (let o = 1; o < r; o++)
        if (
          (e.getCoordinate(o - 1, i),
          e.getCoordinate(o, s),
          n.computeIntersection(t, i, s),
          n.hasIntersection())
        )
          return !0
      return !1
    }
    if (arguments[0] instanceof Oc && arguments[1] instanceof Array) {
      const t = arguments[0],
        e = arguments[1],
        n = new ud()
      for (let i = 1; i < e.length; i++) {
        const s = e[i - 1],
          r = e[i]
        if ((n.computeIntersection(t, s, r), n.hasIntersection())) return !0
      }
      return !1
    }
  }
  static locateInRing(t, e) {
    return np.locatePointInRing(t, e)
  }
  static isInRing(t, e) {
    return op.locateInRing(t, e) !== pd.EXTERIOR
  }
}
class ap {
  hasNext() {}
  next() {}
  remove() {}
}
class lp {
  constructor() {
    lp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._parent = null),
      (this._atStart = null),
      (this._max = null),
      (this._index = null),
      (this._subcollectionIterator = null)
    const t = arguments[0]
    ;(this._parent = t), (this._atStart = !0), (this._index = 0), (this._max = t.getNumGeometries())
  }
  static isAtomic(t) {
    return !(t instanceof Tu)
  }
  next() {
    if (this._atStart)
      return (this._atStart = !1), lp.isAtomic(this._parent) && this._index++, this._parent
    if (null !== this._subcollectionIterator) {
      if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next()
      this._subcollectionIterator = null
    }
    if (this._index >= this._max) throw new Wc()
    const t = this._parent.getGeometryN(this._index++)
    return t instanceof Tu
      ? ((this._subcollectionIterator = new lp(t)), this._subcollectionIterator.next())
      : t
  }
  remove() {
    throw new pu(this.getClass().getName())
  }
  hasNext() {
    if (this._atStart) return !0
    if (null !== this._subcollectionIterator) {
      if (this._subcollectionIterator.hasNext()) return !0
      this._subcollectionIterator = null
    }
    return !(this._index >= this._max)
  }
  get interfaces_() {
    return [ap]
  }
}
class hp {
  constructor() {
    hp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._geom = null
    const t = arguments[0]
    this._geom = t
  }
  static locatePointInPolygon(t, e) {
    if (e.isEmpty()) return pd.EXTERIOR
    const n = e.getExteriorRing(),
      i = hp.locatePointInRing(t, n)
    if (i !== pd.INTERIOR) return i
    for (let n = 0; n < e.getNumInteriorRing(); n++) {
      const i = e.getInteriorRingN(n),
        s = hp.locatePointInRing(t, i)
      if (s === pd.BOUNDARY) return pd.BOUNDARY
      if (s === pd.INTERIOR) return pd.EXTERIOR
    }
    return pd.INTERIOR
  }
  static locatePointInRing(t, e) {
    return e.getEnvelopeInternal().intersects(t)
      ? op.locateInRing(t, e.getCoordinates())
      : pd.EXTERIOR
  }
  static containsPointInPolygon(t, e) {
    return pd.EXTERIOR !== hp.locatePointInPolygon(t, e)
  }
  static locateInGeometry(t, e) {
    if (e instanceof Eu) return hp.locatePointInPolygon(t, e)
    if (e instanceof Tu) {
      const n = new lp(e)
      for (; n.hasNext(); ) {
        const i = n.next()
        if (i !== e) {
          const e = hp.locateInGeometry(t, i)
          if (e !== pd.EXTERIOR) return e
        }
      }
    }
    return pd.EXTERIOR
  }
  static isContained(t, e) {
    return pd.EXTERIOR !== hp.locate(t, e)
  }
  static locate(t, e) {
    return e.isEmpty()
      ? pd.EXTERIOR
      : e.getEnvelopeInternal().intersects(t)
        ? hp.locateInGeometry(t, e)
        : pd.EXTERIOR
  }
  locate(t) {
    return hp.locate(t, this._geom)
  }
  get interfaces_() {
    return [Kd]
  }
}
class cp {
  measure(t, e) {}
}
class up {
  static diagonalSize(t) {
    if (t.isNull()) return 0
    const e = t.getWidth(),
      n = t.getHeight()
    return Math.sqrt(e * e + n * n)
  }
  measure(t, e) {
    const n = jd.distance(t, e, up.DENSIFY_FRACTION),
      i = new Xc(t.getEnvelopeInternal())
    i.expandToInclude(e.getEnvelopeInternal())
    return 1 - n / up.diagonalSize(i)
  }
  get interfaces_() {
    return [cp]
  }
}
up.DENSIFY_FRACTION = 0.25
class dp extends wc {
  constructor(t) {
    super(t), (this.name = Object.keys({ EmptyStackException: dp })[0])
  }
}
class pp extends kc {
  constructor() {
    super(), (this.array = [])
  }
  add(t) {
    return this.array.push(t), !0
  }
  get(t) {
    if (t < 0 || t >= this.size()) throw new Hc()
    return this.array[t]
  }
  push(t) {
    return this.array.push(t), t
  }
  pop() {
    if (0 === this.array.length) throw new dp()
    return this.array.pop()
  }
  peek() {
    if (0 === this.array.length) throw new dp()
    return this.array[this.array.length - 1]
  }
  empty() {
    return 0 === this.array.length
  }
  isEmpty() {
    return this.empty()
  }
  search(t) {
    return this.array.indexOf(t)
  }
  size() {
    return this.array.length
  }
  toArray() {
    return this.array.slice()
  }
}
class gp {
  constructor() {
    gp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._coordSet = new Gu()), (this._list = new Yc())
  }
  static filterCoordinates(t) {
    const e = new gp()
    for (let n = 0; n < t.length; n++) e.filter(t[n])
    return e.getCoordinates()
  }
  filter(t) {
    this._coordSet.add(t) && this._list.add(t)
  }
  getCoordinates() {
    const t = new Array(this._list.size()).fill(null)
    return this._list.toArray(t)
  }
  get interfaces_() {
    return [cu]
  }
}
class fp {
  constructor() {
    fp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._geomFactory = null), (this._inputPts = null), 1 === arguments.length)) {
      const t = arguments[0]
      fp.constructor_.call(this, fp.extractCoordinates(t), t.getFactory())
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._inputPts = gp.filterCoordinates(t)), (this._geomFactory = e)
    }
  }
  static extractCoordinates(t) {
    const e = new gp()
    return t.apply(e), e.getCoordinates()
  }
  preSort(t) {
    let e = null
    for (let n = 1; n < t.length; n++)
      (t[n].y < t[0].y || (t[n].y === t[0].y && t[n].x < t[0].x)) &&
        ((e = t[0]), (t[0] = t[n]), (t[n] = e))
    return _u.sort(t, 1, t.length, new mp(t[0])), t
  }
  computeOctRing(t) {
    const e = this.computeOctPts(t),
      n = new qc()
    return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray())
  }
  lineOrPolygon(t) {
    if (3 === (t = this.cleanRing(t)).length)
      return this._geomFactory.createLineString([t[0], t[1]])
    const e = this._geomFactory.createLinearRing(t)
    return this._geomFactory.createPolygon(e)
  }
  cleanRing(t) {
    Cc.equals(t[0], t[t.length - 1])
    const e = new Yc()
    let n = null
    for (let i = 0; i <= t.length - 2; i++) {
      const s = t[i],
        r = t[i + 1]
      s.equals(r) || (null !== n && this.isBetween(n, s, r)) || (e.add(s), (n = s))
    }
    e.add(t[t.length - 1])
    const i = new Array(e.size()).fill(null)
    return e.toArray(i)
  }
  isBetween(t, e, n) {
    if (0 !== nu.index(t, e, n)) return !1
    if (t.x !== n.x) {
      if (t.x <= e.x && e.x <= n.x) return !0
      if (n.x <= e.x && e.x <= t.x) return !0
    }
    if (t.y !== n.y) {
      if (t.y <= e.y && e.y <= n.y) return !0
      if (n.y <= e.y && e.y <= t.y) return !0
    }
    return !1
  }
  reduce(t) {
    const e = this.computeOctRing(t)
    if (null === e) return t
    const n = new Su()
    for (let t = 0; t < e.length; t++) n.add(e[t])
    for (let i = 0; i < t.length; i++) op.isInRing(t[i], e) || n.add(t[i])
    const i = Cu.toCoordinateArray(n)
    return i.length < 3 ? this.padArray3(i) : i
  }
  getConvexHull() {
    if (0 === this._inputPts.length) return this._geomFactory.createGeometryCollection()
    if (1 === this._inputPts.length) return this._geomFactory.createPoint(this._inputPts[0])
    if (2 === this._inputPts.length) return this._geomFactory.createLineString(this._inputPts)
    let t = this._inputPts
    this._inputPts.length > 50 && (t = this.reduce(this._inputPts))
    const e = this.preSort(t),
      n = this.grahamScan(e),
      i = this.toCoordinateArray(n)
    return this.lineOrPolygon(i)
  }
  padArray3(t) {
    const e = new Array(3).fill(null)
    for (let n = 0; n < e.length; n++) n < t.length ? (e[n] = t[n]) : (e[n] = t[0])
    return e
  }
  computeOctPts(t) {
    const e = new Array(8).fill(null)
    for (let n = 0; n < e.length; n++) e[n] = t[0]
    for (let n = 1; n < t.length; n++)
      t[n].x < e[0].x && (e[0] = t[n]),
        t[n].x - t[n].y < e[1].x - e[1].y && (e[1] = t[n]),
        t[n].y > e[2].y && (e[2] = t[n]),
        t[n].x + t[n].y > e[3].x + e[3].y && (e[3] = t[n]),
        t[n].x > e[4].x && (e[4] = t[n]),
        t[n].x - t[n].y > e[5].x - e[5].y && (e[5] = t[n]),
        t[n].y < e[6].y && (e[6] = t[n]),
        t[n].x + t[n].y < e[7].x + e[7].y && (e[7] = t[n])
    return e
  }
  toCoordinateArray(t) {
    const e = new Array(t.size()).fill(null)
    for (let n = 0; n < t.size(); n++) {
      const i = t.get(n)
      e[n] = i
    }
    return e
  }
  grahamScan(t) {
    let e = null
    const n = new pp()
    n.push(t[0]), n.push(t[1]), n.push(t[2])
    for (let i = 3; i < t.length; i++) {
      for (e = n.pop(); !n.empty() && nu.index(n.peek(), e, t[i]) > 0; ) e = n.pop()
      n.push(e), n.push(t[i])
    }
    return n.push(t[0]), n
  }
}
class mp {
  constructor() {
    mp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._origin = null
    const t = arguments[0]
    this._origin = t
  }
  static polarCompare(t, e, n) {
    const i = e.x - t.x,
      s = e.y - t.y,
      r = n.x - t.x,
      o = n.y - t.y,
      a = nu.index(t, e, n)
    if (a === nu.COUNTERCLOCKWISE) return 1
    if (a === nu.CLOCKWISE) return -1
    const l = i * i + s * s,
      h = r * r + o * o
    return l < h ? -1 : l > h ? 1 : 0
  }
  compare(t, e) {
    const n = t,
      i = e
    return mp.polarCompare(this._origin, n, i)
  }
  get interfaces_() {
    return [Tc]
  }
}
fp.RadialComparator = mp
class yp {
  constructor() {
    yp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._interiorPoint = null), (this._maxWidth = -1)
    const t = arguments[0]
    this.process(t)
  }
  static getInteriorPoint(t) {
    return new yp(t).getInteriorPoint()
  }
  static avg(t, e) {
    return (t + e) / 2
  }
  getInteriorPoint() {
    return this._interiorPoint
  }
  process(t) {
    if (t.isEmpty()) return null
    if (t instanceof Eu) this.processPolygon(t)
    else if (t instanceof Tu) {
      const e = t
      for (let t = 0; t < e.getNumGeometries(); t++) this.process(e.getGeometryN(t))
    }
  }
  processPolygon(t) {
    const e = new xp(t)
    e.process()
    const n = e.getWidth()
    n > this._maxWidth && ((this._maxWidth = n), (this._interiorPoint = e.getInteriorPoint()))
  }
}
class xp {
  constructor() {
    xp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._polygon = null),
      (this._interiorPointY = null),
      (this._interiorSectionWidth = 0),
      (this._interiorPoint = null)
    const t = arguments[0]
    ;(this._polygon = t), (this._interiorPointY = _p.getScanLineY(t))
  }
  static isEdgeCrossingCounted(t, e, n) {
    const i = t.getY(),
      s = e.getY()
    return i !== s && !(i === n && s < n) && !(s === n && i < n)
  }
  static intersectsHorizontalLine() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return !(e < t.getMinY()) && !(e > t.getMaxY())
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return !(t.getY() > n && e.getY() > n) && !(t.getY() < n && e.getY() < n)
    }
  }
  static intersection(t, e, n) {
    const i = t.getX(),
      s = e.getX()
    if (i === s) return i
    const r = s - i,
      o = (e.getY() - t.getY()) / r
    return i + (n - t.getY()) / o
  }
  findBestMidpoint(t) {
    if (0 === t.size()) return null
    Cc.isTrue(
      0 == t.size() % 2,
      'Interior Point robustness failure: odd number of scanline crossings'
    ),
      t.sort(new vp())
    for (let e = 0; e < t.size(); e += 2) {
      const n = t.get(e),
        i = t.get(e + 1),
        s = i - n
      if (s > this._interiorSectionWidth) {
        this._interiorSectionWidth = s
        const t = yp.avg(n, i)
        this._interiorPoint = new Oc(t, this._interiorPointY)
      }
    }
  }
  process() {
    if (this._polygon.isEmpty()) return null
    this._interiorPoint = new Oc(this._polygon.getCoordinate())
    const t = new Yc()
    this.scanRing(this._polygon.getExteriorRing(), t)
    for (let e = 0; e < this._polygon.getNumInteriorRing(); e++)
      this.scanRing(this._polygon.getInteriorRingN(e), t)
    this.findBestMidpoint(t)
  }
  scanRing(t, e) {
    if (!xp.intersectsHorizontalLine(t.getEnvelopeInternal(), this._interiorPointY)) return null
    const n = t.getCoordinateSequence()
    for (let t = 1; t < n.size(); t++) {
      const i = n.getCoordinate(t - 1),
        s = n.getCoordinate(t)
      this.addEdgeCrossing(i, s, this._interiorPointY, e)
    }
  }
  getWidth() {
    return this._interiorSectionWidth
  }
  getInteriorPoint() {
    return this._interiorPoint
  }
  addEdgeCrossing(t, e, n, i) {
    if (!xp.intersectsHorizontalLine(t, e, n)) return null
    if (!xp.isEdgeCrossingCounted(t, e, n)) return null
    const s = xp.intersection(t, e, n)
    i.add(s)
  }
}
class vp {
  compare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
  }
  get interfaces_() {
    return [Tc]
  }
}
xp.DoubleComparator = vp
class _p {
  constructor() {
    _p.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._poly = null),
      (this._centreY = null),
      (this._hiY = Mc.MAX_VALUE),
      (this._loY = -Mc.MAX_VALUE)
    const t = arguments[0]
    ;(this._poly = t),
      (this._hiY = t.getEnvelopeInternal().getMaxY()),
      (this._loY = t.getEnvelopeInternal().getMinY()),
      (this._centreY = yp.avg(this._loY, this._hiY))
  }
  static getScanLineY(t) {
    return new _p(t).getScanLineY()
  }
  updateInterval(t) {
    t <= this._centreY
      ? t > this._loY && (this._loY = t)
      : t > this._centreY && t < this._hiY && (this._hiY = t)
  }
  getScanLineY() {
    this.process(this._poly.getExteriorRing())
    for (let t = 0; t < this._poly.getNumInteriorRing(); t++)
      this.process(this._poly.getInteriorRingN(t))
    return yp.avg(this._hiY, this._loY)
  }
  process(t) {
    const e = t.getCoordinateSequence()
    for (let t = 0; t < e.size(); t++) {
      const n = e.getY(t)
      this.updateInterval(n)
    }
  }
}
;(yp.InteriorPointPolygon = xp), (yp.ScanLineYOrdinateFinder = _p)
class wp {
  isInBoundary(t) {}
}
class Ep {
  isInBoundary(t) {
    return t % 2 == 1
  }
  get interfaces_() {
    return [wp]
  }
}
class bp {
  isInBoundary(t) {
    return t > 0
  }
  get interfaces_() {
    return [wp]
  }
}
class Mp {
  isInBoundary(t) {
    return t > 1
  }
  get interfaces_() {
    return [wp]
  }
}
class Sp {
  isInBoundary(t) {
    return 1 === t
  }
  get interfaces_() {
    return [wp]
  }
}
;(wp.Mod2BoundaryNodeRule = Ep),
  (wp.EndPointBoundaryNodeRule = bp),
  (wp.MultiValentEndPointBoundaryNodeRule = Mp),
  (wp.MonoValentEndPointBoundaryNodeRule = Sp),
  (wp.MOD2_BOUNDARY_RULE = new Ep()),
  (wp.ENDPOINT_BOUNDARY_RULE = new bp()),
  (wp.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new Mp()),
  (wp.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new Sp()),
  (wp.OGC_SFS_BOUNDARY_RULE = wp.MOD2_BOUNDARY_RULE)
class Ap {
  constructor() {
    Ap.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._boundaryRule = wp.OGC_SFS_BOUNDARY_RULE),
      (this._isIn = null),
      (this._numBoundaries = null),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      const t = arguments[0]
      if (null === t) throw new Ec('Rule must be non-null')
      this._boundaryRule = t
    }
  }
  locateInPolygonRing(t, e) {
    return e.getEnvelopeInternal().intersects(t)
      ? op.locateInRing(t, e.getCoordinates())
      : pd.EXTERIOR
  }
  intersects(t, e) {
    return this.locate(t, e) !== pd.EXTERIOR
  }
  updateLocationInfo(t) {
    t === pd.INTERIOR && (this._isIn = !0), t === pd.BOUNDARY && this._numBoundaries++
  }
  computeLocation(t, e) {
    if ((e instanceof xu && this.updateLocationInfo(this.locateOnPoint(t, e)), e instanceof mu))
      this.updateLocationInfo(this.locateOnLineString(t, e))
    else if (e instanceof Eu) this.updateLocationInfo(this.locateInPolygon(t, e))
    else if (e instanceof Hu) {
      const n = e
      for (let e = 0; e < n.getNumGeometries(); e++) {
        const i = n.getGeometryN(e)
        this.updateLocationInfo(this.locateOnLineString(t, i))
      }
    } else if (e instanceof Ou) {
      const n = e
      for (let e = 0; e < n.getNumGeometries(); e++) {
        const i = n.getGeometryN(e)
        this.updateLocationInfo(this.locateInPolygon(t, i))
      }
    } else if (e instanceof Tu) {
      const n = new lp(e)
      for (; n.hasNext(); ) {
        const i = n.next()
        i !== e && this.computeLocation(t, i)
      }
    }
  }
  locateOnPoint(t, e) {
    return e.getCoordinate().equals2D(t) ? pd.INTERIOR : pd.EXTERIOR
  }
  locateOnLineString(t, e) {
    if (!e.getEnvelopeInternal().intersects(t)) return pd.EXTERIOR
    const n = e.getCoordinateSequence()
    return e.isClosed() ||
      (!t.equals(n.getCoordinate(0)) && !t.equals(n.getCoordinate(n.size() - 1)))
      ? op.isOnLine(t, n)
        ? pd.INTERIOR
        : pd.EXTERIOR
      : pd.BOUNDARY
  }
  locateInPolygon(t, e) {
    if (e.isEmpty()) return pd.EXTERIOR
    const n = e.getExteriorRing(),
      i = this.locateInPolygonRing(t, n)
    if (i === pd.EXTERIOR) return pd.EXTERIOR
    if (i === pd.BOUNDARY) return pd.BOUNDARY
    for (let n = 0; n < e.getNumInteriorRing(); n++) {
      const i = e.getInteriorRingN(n),
        s = this.locateInPolygonRing(t, i)
      if (s === pd.INTERIOR) return pd.EXTERIOR
      if (s === pd.BOUNDARY) return pd.BOUNDARY
    }
    return pd.INTERIOR
  }
  locate(t, e) {
    return e.isEmpty()
      ? pd.EXTERIOR
      : e instanceof mu
        ? this.locateOnLineString(t, e)
        : e instanceof Eu
          ? this.locateInPolygon(t, e)
          : ((this._isIn = !1),
            (this._numBoundaries = 0),
            this.computeLocation(t, e),
            this._boundaryRule.isInBoundary(this._numBoundaries)
              ? pd.BOUNDARY
              : this._numBoundaries > 0 || this._isIn
                ? pd.INTERIOR
                : pd.EXTERIOR)
  }
}
class Tp {
  constructor() {
    Tp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._distanceTolerance = null)
    const t = arguments[0]
    this._inputGeom = t
  }
  static densifyPoints(t, e, n) {
    const i = new dd(),
      s = new qc()
    for (let r = 0; r < t.length - 1; r++) {
      ;(i.p0 = t[r]), (i.p1 = t[r + 1]), s.add(i.p0, !1)
      const o = i.getLength(),
        a = Math.trunc(o / e) + 1
      if (a > 1) {
        const t = o / a
        for (let e = 1; e < a; e++) {
          const r = (e * t) / o,
            a = i.pointAlong(r)
          n.makePrecise(a), s.add(a, !1)
        }
      }
    }
    return s.add(t[t.length - 1], !1), s.toCoordinateArray()
  }
  static densify(t, e) {
    const n = new Tp(t)
    return n.setDistanceTolerance(e), n.getResultGeometry()
  }
  getResultGeometry() {
    return new Ip(this._distanceTolerance).transform(this._inputGeom)
  }
  setDistanceTolerance(t) {
    if (t <= 0) throw new Ec('Tolerance must be positive')
    this._distanceTolerance = t
  }
}
class Ip extends Nd {
  constructor() {
    super(), Ip.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.distanceTolerance = null
    const t = arguments[0]
    this.distanceTolerance = t
  }
  transformMultiPolygon(t, e) {
    const n = super.transformMultiPolygon.call(this, t, e)
    return this.createValidArea(n)
  }
  transformPolygon(t, e) {
    const n = super.transformPolygon.call(this, t, e)
    return e instanceof Ou ? n : this.createValidArea(n)
  }
  transformCoordinates(t, e) {
    const n = t.toCoordinateArray()
    let i = Tp.densifyPoints(n, this.distanceTolerance, e.getPrecisionModel())
    return (
      e instanceof mu && 1 === i.length && (i = new Array(0).fill(null)),
      this._factory.getCoordinateSequenceFactory().create(i)
    )
  }
  createValidArea(t) {
    return t.buffer(0)
  }
}
Tp.DensifyTransformer = Ip
class Rp {
  static isNorthern(t) {
    return t === Rp.NE || t === Rp.NW
  }
  static isOpposite(t, e) {
    if (t === e) return !1
    return 2 === (t - e + 4) % 4
  }
  static commonHalfPlane(t, e) {
    if (t === e) return t
    if (2 === (t - e + 4) % 4) return -1
    const n = t < e ? t : e
    return 0 === n && 3 === (t > e ? t : e) ? 3 : n
  }
  static isInHalfPlane(t, e) {
    return e === Rp.SE ? t === Rp.SE || t === Rp.SW : t === e || t === e + 1
  }
  static quadrant() {
    if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
      const t = arguments[0],
        e = arguments[1]
      if (0 === t && 0 === e)
        throw new Ec('Cannot compute the quadrant for point ( ' + t + ', ' + e + ' )')
      return t >= 0 ? (e >= 0 ? Rp.NE : Rp.SE) : e >= 0 ? Rp.NW : Rp.SW
    }
    if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
      const t = arguments[0],
        e = arguments[1]
      if (e.x === t.x && e.y === t.y)
        throw new Ec('Cannot compute the quadrant for two identical points ' + t)
      return e.x >= t.x ? (e.y >= t.y ? Rp.NE : Rp.SE) : e.y >= t.y ? Rp.NW : Rp.SW
    }
  }
}
;(Rp.NE = 0), (Rp.NW = 1), (Rp.SW = 2), (Rp.SE = 3)
class Lp {
  static opposite(t) {
    return t === Lp.LEFT ? Lp.RIGHT : t === Lp.RIGHT ? Lp.LEFT : t
  }
}
;(Lp.ON = 0), (Lp.LEFT = 1), (Lp.RIGHT = 2)
class Cp {
  constructor() {
    Cp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.mce = null), (this.chainIndex = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this.mce = t), (this.chainIndex = e)
  }
  computeIntersections(t, e) {
    this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
  }
}
class Np {
  constructor() {
    Np.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._label = null),
      (this._xValue = null),
      (this._eventType = null),
      (this._insertEvent = null),
      (this._deleteEventIndex = null),
      (this._obj = null),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._eventType = Np.DELETE), (this._xValue = t), (this._insertEvent = e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._eventType = Np.INSERT), (this._label = t), (this._xValue = e), (this._obj = n)
    }
  }
  isDelete() {
    return this._eventType === Np.DELETE
  }
  setDeleteEventIndex(t) {
    this._deleteEventIndex = t
  }
  getObject() {
    return this._obj
  }
  compareTo(t) {
    const e = t
    return this._xValue < e._xValue
      ? -1
      : this._xValue > e._xValue
        ? 1
        : this._eventType < e._eventType
          ? -1
          : this._eventType > e._eventType
            ? 1
            : 0
  }
  getInsertEvent() {
    return this._insertEvent
  }
  isInsert() {
    return this._eventType === Np.INSERT
  }
  isSameLabel(t) {
    return null !== this._label && this._label === t._label
  }
  getDeleteEventIndex() {
    return this._deleteEventIndex
  }
  get interfaces_() {
    return [Sc]
  }
}
;(Np.INSERT = 1), (Np.DELETE = 2)
class Pp {
  constructor() {
    Pp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._hasIntersection = !1),
      (this._hasProper = !1),
      (this._hasProperInterior = !1),
      (this._properIntersectionPoint = null),
      (this._li = null),
      (this._includeProper = null),
      (this._recordIsolated = null),
      (this._isSelfIntersection = null),
      (this._numIntersections = 0),
      (this.numTests = 0),
      (this._bdyNodes = null),
      (this._isDone = !1),
      (this._isDoneWhenProperInt = !1)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._li = t), (this._includeProper = e), (this._recordIsolated = n)
  }
  static isAdjacentSegments(t, e) {
    return 1 === Math.abs(t - e)
  }
  isTrivialIntersection(t, e, n, i) {
    if (t === n && 1 === this._li.getIntersectionNum()) {
      if (Pp.isAdjacentSegments(e, i)) return !0
      if (t.isClosed()) {
        const n = t.getNumPoints() - 1
        if ((0 === e && i === n) || (0 === i && e === n)) return !0
      }
    }
    return !1
  }
  getProperIntersectionPoint() {
    return this._properIntersectionPoint
  }
  setIsDoneIfProperInt(t) {
    this._isDoneWhenProperInt = t
  }
  hasProperInteriorIntersection() {
    return this._hasProperInterior
  }
  isBoundaryPointInternal(t, e) {
    for (let n = e.iterator(); n.hasNext(); ) {
      const e = n.next().getCoordinate()
      if (t.isIntersection(e)) return !0
    }
    return !1
  }
  hasProperIntersection() {
    return this._hasProper
  }
  hasIntersection() {
    return this._hasIntersection
  }
  isDone() {
    return this._isDone
  }
  isBoundaryPoint(t, e) {
    return (
      null !== e &&
      (!!this.isBoundaryPointInternal(t, e[0]) || !!this.isBoundaryPointInternal(t, e[1]))
    )
  }
  setBoundaryNodes(t, e) {
    ;(this._bdyNodes = new Array(2).fill(null)), (this._bdyNodes[0] = t), (this._bdyNodes[1] = e)
  }
  addIntersections(t, e, n, i) {
    if (t === n && e === i) return null
    this.numTests++
    const s = t.getCoordinates()[e],
      r = t.getCoordinates()[e + 1],
      o = n.getCoordinates()[i],
      a = n.getCoordinates()[i + 1]
    this._li.computeIntersection(s, r, o, a),
      this._li.hasIntersection() &&
        (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)),
        this._numIntersections++,
        this.isTrivialIntersection(t, e, n, i) ||
          ((this._hasIntersection = !0),
          (!this._includeProper && this._li.isProper()) ||
            (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)),
          this._li.isProper() &&
            ((this._properIntersectionPoint = this._li.getIntersection(0).copy()),
            (this._hasProper = !0),
            this._isDoneWhenProperInt && (this._isDone = !0),
            this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))))
  }
}
class Dp extends class {} {
  constructor() {
    super(), Dp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.events = new Yc()), (this.nOverlaps = null)
  }
  prepareEvents() {
    Od.sort(this.events)
    for (let t = 0; t < this.events.size(); t++) {
      const e = this.events.get(t)
      e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
    }
  }
  computeIntersections() {
    if (1 === arguments.length) {
      const t = arguments[0]
      ;(this.nOverlaps = 0), this.prepareEvents()
      for (let e = 0; e < this.events.size(); e++) {
        const n = this.events.get(e)
        if ((n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()))
          break
      }
    } else if (3 === arguments.length)
      if (arguments[2] instanceof Pp && Uc(arguments[0], kc) && Uc(arguments[1], kc)) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        this.addEdges(t, t), this.addEdges(e, e), this.computeIntersections(n)
      } else if (
        'boolean' == typeof arguments[2] &&
        Uc(arguments[0], kc) &&
        arguments[1] instanceof Pp
      ) {
        const t = arguments[0],
          e = arguments[1]
        arguments[2] ? this.addEdges(t, null) : this.addEdges(t), this.computeIntersections(e)
      }
  }
  addEdge(t, e) {
    const n = t.getMonotoneChainEdge(),
      i = n.getStartIndexes()
    for (let t = 0; t < i.length - 1; t++) {
      const i = new Cp(n, t),
        s = new Np(e, n.getMinX(t), i)
      this.events.add(s), this.events.add(new Np(n.getMaxX(t), s))
    }
  }
  processOverlaps(t, e, n, i) {
    const s = n.getObject()
    for (let r = t; r < e; r++) {
      const t = this.events.get(r)
      if (t.isInsert()) {
        const e = t.getObject()
        n.isSameLabel(t) || (s.computeIntersections(e, i), this.nOverlaps++)
      }
    }
  }
  addEdges() {
    if (1 === arguments.length) {
      for (let t = arguments[0].iterator(); t.hasNext(); ) {
        const e = t.next()
        this.addEdge(e, e)
      }
    } else if (2 === arguments.length) {
      const t = arguments[1]
      for (let e = arguments[0].iterator(); e.hasNext(); ) {
        const n = e.next()
        this.addEdge(n, t)
      }
    }
  }
}
class Op {
  constructor() {
    Op.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.location = null), 1 === arguments.length)) {
      if (arguments[0] instanceof Array) {
        const t = arguments[0]
        this.init(t.length)
      } else if (Number.isInteger(arguments[0])) {
        const t = arguments[0]
        this.init(1), (this.location[Lp.ON] = t)
      } else if (arguments[0] instanceof Op) {
        const t = arguments[0]
        if ((this.init(t.location.length), null !== t))
          for (let e = 0; e < this.location.length; e++) this.location[e] = t.location[e]
      }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this.init(3),
        (this.location[Lp.ON] = t),
        (this.location[Lp.LEFT] = e),
        (this.location[Lp.RIGHT] = n)
    }
  }
  setAllLocations(t) {
    for (let e = 0; e < this.location.length; e++) this.location[e] = t
  }
  isNull() {
    for (let t = 0; t < this.location.length; t++) if (this.location[t] !== pd.NONE) return !1
    return !0
  }
  setAllLocationsIfNull(t) {
    for (let e = 0; e < this.location.length; e++)
      this.location[e] === pd.NONE && (this.location[e] = t)
  }
  isLine() {
    return 1 === this.location.length
  }
  merge(t) {
    if (t.location.length > this.location.length) {
      const t = new Array(3).fill(null)
      ;(t[Lp.ON] = this.location[Lp.ON]),
        (t[Lp.LEFT] = pd.NONE),
        (t[Lp.RIGHT] = pd.NONE),
        (this.location = t)
    }
    for (let e = 0; e < this.location.length; e++)
      this.location[e] === pd.NONE && e < t.location.length && (this.location[e] = t.location[e])
  }
  getLocations() {
    return this.location
  }
  flip() {
    if (this.location.length <= 1) return null
    const t = this.location[Lp.LEFT]
    ;(this.location[Lp.LEFT] = this.location[Lp.RIGHT]), (this.location[Lp.RIGHT] = t)
  }
  toString() {
    const t = new Kc()
    return (
      this.location.length > 1 && t.append(pd.toLocationSymbol(this.location[Lp.LEFT])),
      t.append(pd.toLocationSymbol(this.location[Lp.ON])),
      this.location.length > 1 && t.append(pd.toLocationSymbol(this.location[Lp.RIGHT])),
      t.toString()
    )
  }
  setLocations(t, e, n) {
    ;(this.location[Lp.ON] = t), (this.location[Lp.LEFT] = e), (this.location[Lp.RIGHT] = n)
  }
  get(t) {
    return t < this.location.length ? this.location[t] : pd.NONE
  }
  isArea() {
    return this.location.length > 1
  }
  isAnyNull() {
    for (let t = 0; t < this.location.length; t++) if (this.location[t] === pd.NONE) return !0
    return !1
  }
  setLocation() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.setLocation(Lp.ON, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.location[t] = e
    }
  }
  init(t) {
    ;(this.location = new Array(t).fill(null)), this.setAllLocations(pd.NONE)
  }
  isEqualOnSide(t, e) {
    return this.location[e] === t.location[e]
  }
  allPositionsEqual(t) {
    for (let e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1
    return !0
  }
}
class Fp {
  constructor() {
    Fp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.elt = new Array(2).fill(null)), 1 === arguments.length)) {
      if (Number.isInteger(arguments[0])) {
        const t = arguments[0]
        ;(this.elt[0] = new Op(t)), (this.elt[1] = new Op(t))
      } else if (arguments[0] instanceof Fp) {
        const t = arguments[0]
        ;(this.elt[0] = new Op(t.elt[0])), (this.elt[1] = new Op(t.elt[1]))
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this.elt[0] = new Op(pd.NONE)), (this.elt[1] = new Op(pd.NONE)), this.elt[t].setLocation(e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this.elt[0] = new Op(t, e, n)), (this.elt[1] = new Op(t, e, n))
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      ;(this.elt[0] = new Op(pd.NONE, pd.NONE, pd.NONE)),
        (this.elt[1] = new Op(pd.NONE, pd.NONE, pd.NONE)),
        this.elt[t].setLocations(e, n, i)
    }
  }
  static toLineLabel(t) {
    const e = new Fp(pd.NONE)
    for (let n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n))
    return e
  }
  getGeometryCount() {
    let t = 0
    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
  }
  setAllLocations(t, e) {
    this.elt[t].setAllLocations(e)
  }
  isNull(t) {
    return this.elt[t].isNull()
  }
  setAllLocationsIfNull() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.elt[t].setAllLocationsIfNull(e)
    }
  }
  isLine(t) {
    return this.elt[t].isLine()
  }
  merge(t) {
    for (let e = 0; e < 2; e++)
      null === this.elt[e] && null !== t.elt[e]
        ? (this.elt[e] = new Op(t.elt[e]))
        : this.elt[e].merge(t.elt[e])
  }
  flip() {
    this.elt[0].flip(), this.elt[1].flip()
  }
  getLocation() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.elt[t].get(Lp.ON)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.elt[t].get(e)
    }
  }
  toString() {
    const t = new Kc()
    return (
      null !== this.elt[0] && (t.append('A:'), t.append(this.elt[0].toString())),
      null !== this.elt[1] && (t.append(' B:'), t.append(this.elt[1].toString())),
      t.toString()
    )
  }
  isArea() {
    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea()
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.elt[t].isArea()
    }
  }
  isAnyNull(t) {
    return this.elt[t].isAnyNull()
  }
  setLocation() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.elt[t].setLocation(Lp.ON, e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this.elt[t].setLocation(e, n)
    }
  }
  isEqualOnSide(t, e) {
    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
  }
  allPositionsEqual(t, e) {
    return this.elt[t].allPositionsEqual(e)
  }
  toLine(t) {
    this.elt[t].isArea() && (this.elt[t] = new Op(this.elt[t].location[0]))
  }
}
class Gp {
  constructor() {
    Gp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.coord = null), (this.segmentIndex = null), (this.dist = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this.coord = new Oc(t)), (this.segmentIndex = e), (this.dist = n)
  }
  getSegmentIndex() {
    return this.segmentIndex
  }
  getCoordinate() {
    return this.coord
  }
  print(t) {
    t.print(this.coord), t.print(' seg # = ' + this.segmentIndex), t.println(' dist = ' + this.dist)
  }
  compareTo(t) {
    const e = t
    return this.compare(e.segmentIndex, e.dist)
  }
  isEndPoint(t) {
    return (0 === this.segmentIndex && 0 === this.dist) || this.segmentIndex === t
  }
  toString() {
    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist
  }
  getDistance() {
    return this.dist
  }
  compare(t, e) {
    return this.segmentIndex < t
      ? -1
      : this.segmentIndex > t
        ? 1
        : this.dist < e
          ? -1
          : this.dist > e
            ? 1
            : 0
  }
  get interfaces_() {
    return [Sc]
  }
}
class zp extends Fu {}
function Bp(t) {
  return null == t ? 0 : t.color
}
function Up(t) {
  return null == t ? null : t.parent
}
function Vp(t, e) {
  null !== t && (t.color = e)
}
function Hp(t) {
  return null == t ? null : t.left
}
function kp(t) {
  return null == t ? null : t.right
}
class Wp extends zp {
  constructor() {
    super(), (this.root_ = null), (this.size_ = 0)
  }
  get(t) {
    let e = this.root_
    for (; null !== e; ) {
      const n = t.compareTo(e.key)
      if (n < 0) e = e.left
      else {
        if (!(n > 0)) return e.value
        e = e.right
      }
    }
    return null
  }
  put(t, e) {
    if (null === this.root_)
      return (
        (this.root_ = {
          key: t,
          value: e,
          left: null,
          right: null,
          parent: null,
          color: 0,
          getValue() {
            return this.value
          },
          getKey() {
            return this.key
          }
        }),
        (this.size_ = 1),
        null
      )
    let n,
      i,
      s = this.root_
    do {
      if (((n = s), (i = t.compareTo(s.key)), i < 0)) s = s.left
      else {
        if (!(i > 0)) {
          const t = s.value
          return (s.value = e), t
        }
        s = s.right
      }
    } while (null !== s)
    const r = {
      key: t,
      left: null,
      right: null,
      value: e,
      parent: n,
      color: 0,
      getValue() {
        return this.value
      },
      getKey() {
        return this.key
      }
    }
    return i < 0 ? (n.left = r) : (n.right = r), this.fixAfterInsertion(r), this.size_++, null
  }
  fixAfterInsertion(t) {
    let e
    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color; )
      Up(t) === Hp(Up(Up(t)))
        ? ((e = kp(Up(Up(t)))),
          1 === Bp(e)
            ? (Vp(Up(t), 0), Vp(e, 0), Vp(Up(Up(t)), 1), (t = Up(Up(t))))
            : (t === kp(Up(t)) && ((t = Up(t)), this.rotateLeft(t)),
              Vp(Up(t), 0),
              Vp(Up(Up(t)), 1),
              this.rotateRight(Up(Up(t)))))
        : ((e = Hp(Up(Up(t)))),
          1 === Bp(e)
            ? (Vp(Up(t), 0), Vp(e, 0), Vp(Up(Up(t)), 1), (t = Up(Up(t))))
            : (t === Hp(Up(t)) && ((t = Up(t)), this.rotateRight(t)),
              Vp(Up(t), 0),
              Vp(Up(Up(t)), 1),
              this.rotateLeft(Up(Up(t)))))
    this.root_.color = 0
  }
  values() {
    const t = new Yc()
    let e = this.getFirstEntry()
    if (null !== e) for (t.add(e.value); null !== (e = Wp.successor(e)); ) t.add(e.value)
    return t
  }
  entrySet() {
    const t = new Gu()
    let e = this.getFirstEntry()
    if (null !== e) for (t.add(e); null !== (e = Wp.successor(e)); ) t.add(e)
    return t
  }
  rotateLeft(t) {
    if (null != t) {
      const e = t.right
      ;(t.right = e.left),
        null != e.left && (e.left.parent = t),
        (e.parent = t.parent),
        null == t.parent
          ? (this.root_ = e)
          : t.parent.left === t
            ? (t.parent.left = e)
            : (t.parent.right = e),
        (e.left = t),
        (t.parent = e)
    }
  }
  rotateRight(t) {
    if (null != t) {
      const e = t.left
      ;(t.left = e.right),
        null != e.right && (e.right.parent = t),
        (e.parent = t.parent),
        null == t.parent
          ? (this.root_ = e)
          : t.parent.right === t
            ? (t.parent.right = e)
            : (t.parent.left = e),
        (e.right = t),
        (t.parent = e)
    }
  }
  getFirstEntry() {
    let t = this.root_
    if (null != t) for (; null != t.left; ) t = t.left
    return t
  }
  static successor(t) {
    let e
    if (null === t) return null
    if (null !== t.right) {
      for (e = t.right; null !== e.left; ) e = e.left
      return e
    }
    {
      e = t.parent
      let n = t
      for (; null !== e && n === e.right; ) (n = e), (e = e.parent)
      return e
    }
  }
  size() {
    return this.size_
  }
  containsKey(t) {
    let e = this.root_
    for (; null !== e; ) {
      const n = t.compareTo(e.key)
      if (n < 0) e = e.left
      else {
        if (!(n > 0)) return !0
        e = e.right
      }
    }
    return !1
  }
}
class Yp {
  constructor() {
    Yp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._nodeMap = new Wp()), (this.edge = null)
    const t = arguments[0]
    this.edge = t
  }
  print(t) {
    t.println('Intersections:')
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().print(t)
    }
  }
  iterator() {
    return this._nodeMap.values().iterator()
  }
  addSplitEdges(t) {
    this.addEndpoints()
    const e = this.iterator()
    let n = e.next()
    for (; e.hasNext(); ) {
      const i = e.next(),
        s = this.createSplitEdge(n, i)
      t.add(s), (n = i)
    }
  }
  addEndpoints() {
    const t = this.edge.pts.length - 1
    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
  }
  createSplitEdge(t, e) {
    let n = e.segmentIndex - t.segmentIndex + 2
    const i = this.edge.pts[e.segmentIndex],
      s = e.dist > 0 || !e.coord.equals2D(i)
    s || n--
    const r = new Array(n).fill(null)
    let o = 0
    r[o++] = new Oc(t.coord)
    for (let n = t.segmentIndex + 1; n <= e.segmentIndex; n++) r[o++] = this.edge.pts[n]
    return s && (r[o] = e.coord), new Jp(r, new Fp(this.edge._label))
  }
  add(t, e, n) {
    const i = new Gp(t, e, n),
      s = this._nodeMap.get(i)
    return null !== s ? s : (this._nodeMap.put(i, i), i)
  }
  isIntersection(t) {
    for (let e = this.iterator(); e.hasNext(); ) {
      if (e.next().coord.equals(t)) return !0
    }
    return !1
  }
}
class jp {
  constructor() {
    jp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._data = null), (this._size = 0), 0 === arguments.length))
      jp.constructor_.call(this, 10)
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._data = new Array(t).fill(null)
    }
  }
  size() {
    return this._size
  }
  addAll(t) {
    return null === t || 0 === t.length
      ? null
      : (this.ensureCapacity(this._size + t.length),
        su.arraycopy(t, 0, this._data, this._size, t.length),
        void (this._size += t.length))
  }
  ensureCapacity(t) {
    if (t <= this._data.length) return null
    const e = Math.max(t, 2 * this._data.length)
    this._data = _u.copyOf(this._data, e)
  }
  toArray() {
    const t = new Array(this._size).fill(null)
    return su.arraycopy(this._data, 0, t, 0, this._size), t
  }
  add(t) {
    this.ensureCapacity(this._size + 1), (this._data[this._size] = t), ++this._size
  }
}
class qp {
  static toIntArray(t) {
    const e = new Array(t.size()).fill(null)
    for (let n = 0; n < e.length; n++) e[n] = t.get(n).intValue()
    return e
  }
  getChainStartIndices(t) {
    let e = 0
    const n = new jp(Math.trunc(t.length / 2))
    n.add(e)
    do {
      const i = this.findChainEnd(t, e)
      n.add(i), (e = i)
    } while (e < t.length - 1)
    return n.toArray()
  }
  findChainEnd(t, e) {
    const n = Rp.quadrant(t[e], t[e + 1])
    let i = e + 1
    for (; i < t.length; ) {
      if (Rp.quadrant(t[i - 1], t[i]) !== n) break
      i++
    }
    return i - 1
  }
  OLDgetChainStartIndices(t) {
    let e = 0
    const n = new Yc()
    n.add(e)
    do {
      const i = this.findChainEnd(t, e)
      n.add(i), (e = i)
    } while (e < t.length - 1)
    return qp.toIntArray(n)
  }
}
class Zp {
  constructor() {
    Zp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.e = null), (this.pts = null), (this.startIndex = null)
    const t = arguments[0]
    ;(this.e = t), (this.pts = t.getCoordinates())
    const e = new qp()
    this.startIndex = e.getChainStartIndices(this.pts)
  }
  getCoordinates() {
    return this.pts
  }
  getMaxX(t) {
    const e = this.pts[this.startIndex[t]].x,
      n = this.pts[this.startIndex[t + 1]].x
    return e > n ? e : n
  }
  getMinX(t) {
    const e = this.pts[this.startIndex[t]].x,
      n = this.pts[this.startIndex[t + 1]].x
    return e < n ? e : n
  }
  computeIntersectsForChain() {
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      this.computeIntersectsForChain(
        this.startIndex[t],
        this.startIndex[t + 1],
        e,
        e.startIndex[n],
        e.startIndex[n + 1],
        i
      )
    } else if (6 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5]
      if (e - t == 1 && s - i == 1) return r.addIntersections(this.e, t, n.e, i), null
      if (!this.overlaps(t, e, n, i, s)) return null
      const o = Math.trunc((t + e) / 2),
        a = Math.trunc((i + s) / 2)
      t < o &&
        (i < a && this.computeIntersectsForChain(t, o, n, i, a, r),
        a < s && this.computeIntersectsForChain(t, o, n, a, s, r)),
        o < e &&
          (i < a && this.computeIntersectsForChain(o, e, n, i, a, r),
          a < s && this.computeIntersectsForChain(o, e, n, a, s, r))
    }
  }
  overlaps(t, e, n, i, s) {
    return Xc.intersects(this.pts[t], this.pts[e], n.pts[i], n.pts[s])
  }
  getStartIndexes() {
    return this.startIndex
  }
  computeIntersects(t, e) {
    for (let n = 0; n < this.startIndex.length - 1; n++)
      for (let i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e)
  }
}
class Xp {
  constructor() {
    Xp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._depth = Array(2)
      .fill()
      .map(() => Array(3))
    for (let t = 0; t < 2; t++) for (let e = 0; e < 3; e++) this._depth[t][e] = Xp.NULL_VALUE
  }
  static depthAtLocation(t) {
    return t === pd.EXTERIOR ? 0 : t === pd.INTERIOR ? 1 : Xp.NULL_VALUE
  }
  getDepth(t, e) {
    return this._depth[t][e]
  }
  setDepth(t, e, n) {
    this._depth[t][e] = n
  }
  isNull() {
    if (0 === arguments.length) {
      for (let t = 0; t < 2; t++)
        for (let e = 0; e < 3; e++) if (this._depth[t][e] !== Xp.NULL_VALUE) return !1
      return !0
    }
    if (1 === arguments.length) {
      const t = arguments[0]
      return this._depth[t][1] === Xp.NULL_VALUE
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this._depth[t][e] === Xp.NULL_VALUE
    }
  }
  normalize() {
    for (let t = 0; t < 2; t++)
      if (!this.isNull(t)) {
        let e = this._depth[t][1]
        this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0)
        for (let n = 1; n < 3; n++) {
          let i = 0
          this._depth[t][n] > e && (i = 1), (this._depth[t][n] = i)
        }
      }
  }
  getDelta(t) {
    return this._depth[t][Lp.RIGHT] - this._depth[t][Lp.LEFT]
  }
  getLocation(t, e) {
    return this._depth[t][e] <= 0 ? pd.EXTERIOR : pd.INTERIOR
  }
  toString() {
    return (
      'A: ' +
      this._depth[0][1] +
      ',' +
      this._depth[0][2] +
      ' B: ' +
      this._depth[1][1] +
      ',' +
      this._depth[1][2]
    )
  }
  add() {
    if (1 === arguments.length) {
      const t = arguments[0]
      for (let e = 0; e < 2; e++)
        for (let n = 1; n < 3; n++) {
          const i = t.getLocation(e, n)
          ;(i !== pd.EXTERIOR && i !== pd.INTERIOR) ||
            (this.isNull(e, n)
              ? (this._depth[e][n] = Xp.depthAtLocation(i))
              : (this._depth[e][n] += Xp.depthAtLocation(i)))
        }
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      arguments[2] === pd.INTERIOR && this._depth[t][e]++
    }
  }
}
Xp.NULL_VALUE = -1
class Kp {
  constructor() {
    Kp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._label = null),
      (this._isInResult = !1),
      (this._isCovered = !1),
      (this._isCoveredSet = !1),
      (this._isVisited = !1),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._label = t
    }
  }
  setVisited(t) {
    this._isVisited = t
  }
  setInResult(t) {
    this._isInResult = t
  }
  isCovered() {
    return this._isCovered
  }
  isCoveredSet() {
    return this._isCoveredSet
  }
  setLabel(t) {
    this._label = t
  }
  getLabel() {
    return this._label
  }
  setCovered(t) {
    ;(this._isCovered = t), (this._isCoveredSet = !0)
  }
  updateIM(t) {
    Cc.isTrue(this._label.getGeometryCount() >= 2, 'found partial label'), this.computeIM(t)
  }
  isInResult() {
    return this._isInResult
  }
  isVisited() {
    return this._isVisited
  }
}
class Jp extends Kp {
  constructor() {
    super(), Jp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this.pts = null),
      (this._env = null),
      (this.eiList = new Yp(this)),
      (this._name = null),
      (this._mce = null),
      (this._isIsolated = !0),
      (this._depth = new Xp()),
      (this._depthDelta = 0),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      Jp.constructor_.call(this, t, null)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this.pts = t), (this._label = e)
    }
  }
  static updateIM() {
    if (!(2 === arguments.length && arguments[1] instanceof gd && arguments[0] instanceof Fp))
      return super.updateIM.apply(this, arguments)
    {
      const t = arguments[0],
        e = arguments[1]
      e.setAtLeastIfValid(t.getLocation(0, Lp.ON), t.getLocation(1, Lp.ON), 1),
        t.isArea() &&
          (e.setAtLeastIfValid(t.getLocation(0, Lp.LEFT), t.getLocation(1, Lp.LEFT), 2),
          e.setAtLeastIfValid(t.getLocation(0, Lp.RIGHT), t.getLocation(1, Lp.RIGHT), 2))
    }
  }
  getDepth() {
    return this._depth
  }
  getCollapsedEdge() {
    const t = new Array(2).fill(null)
    ;(t[0] = this.pts[0]), (t[1] = this.pts[1])
    return new Jp(t, Fp.toLineLabel(this._label))
  }
  isIsolated() {
    return this._isIsolated
  }
  getCoordinates() {
    return this.pts
  }
  setIsolated(t) {
    this._isIsolated = t
  }
  setName(t) {
    this._name = t
  }
  equals(t) {
    if (!(t instanceof Jp)) return !1
    const e = t
    if (this.pts.length !== e.pts.length) return !1
    let n = !0,
      i = !0,
      s = this.pts.length
    for (let t = 0; t < this.pts.length; t++)
      if (
        (this.pts[t].equals2D(e.pts[t]) || (n = !1),
        this.pts[t].equals2D(e.pts[--s]) || (i = !1),
        !n && !i)
      )
        return !1
    return !0
  }
  getCoordinate() {
    if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.pts[t]
    }
  }
  print(t) {
    t.print('edge ' + this._name + ': '), t.print('LINESTRING (')
    for (let e = 0; e < this.pts.length; e++)
      e > 0 && t.print(','), t.print(this.pts[e].x + ' ' + this.pts[e].y)
    t.print(')  ' + this._label + ' ' + this._depthDelta)
  }
  computeIM(t) {
    Jp.updateIM(this._label, t)
  }
  isCollapsed() {
    return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
  }
  isClosed() {
    return this.pts[0].equals(this.pts[this.pts.length - 1])
  }
  getMaximumSegmentIndex() {
    return this.pts.length - 1
  }
  getDepthDelta() {
    return this._depthDelta
  }
  getNumPoints() {
    return this.pts.length
  }
  printReverse(t) {
    t.print('edge ' + this._name + ': ')
    for (let e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + ' ')
    t.println('')
  }
  getMonotoneChainEdge() {
    return null === this._mce && (this._mce = new Zp(this)), this._mce
  }
  getEnvelope() {
    if (null === this._env) {
      this._env = new Xc()
      for (let t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t])
    }
    return this._env
  }
  addIntersection(t, e, n, i) {
    const s = new Oc(t.getIntersection(i))
    let r = e,
      o = t.getEdgeDistance(n, i)
    const a = r + 1
    if (a < this.pts.length) {
      const t = this.pts[a]
      s.equals2D(t) && ((r = a), (o = 0))
    }
    this.eiList.add(s, r, o)
  }
  toString() {
    const t = new Nu()
    t.append('edge ' + this._name + ': '), t.append('LINESTRING (')
    for (let e = 0; e < this.pts.length; e++)
      e > 0 && t.append(','), t.append(this.pts[e].x + ' ' + this.pts[e].y)
    return t.append(')  ' + this._label + ' ' + this._depthDelta), t.toString()
  }
  isPointwiseEqual(t) {
    if (this.pts.length !== t.pts.length) return !1
    for (let e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1
    return !0
  }
  setDepthDelta(t) {
    this._depthDelta = t
  }
  getEdgeIntersectionList() {
    return this.eiList
  }
  addIntersections(t, e, n) {
    for (let i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
  }
}
class Qp extends Kp {
  constructor() {
    super(), Qp.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._coord = null), (this._edges = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._coord = t), (this._edges = e), (this._label = new Fp(0, pd.NONE))
  }
  isIncidentEdgeInResult() {
    for (let t = this.getEdges().getEdges().iterator(); t.hasNext(); ) {
      if (t.next().getEdge().isInResult()) return !0
    }
    return !1
  }
  isIsolated() {
    return 1 === this._label.getGeometryCount()
  }
  getCoordinate() {
    return this._coord
  }
  print(t) {
    t.println('node ' + this._coord + ' lbl: ' + this._label)
  }
  computeIM(t) {}
  computeMergedLocation(t, e) {
    let n = pd.NONE
    if (((n = this._label.getLocation(e)), !t.isNull(e))) {
      const i = t.getLocation(e)
      n !== pd.BOUNDARY && (n = i)
    }
    return n
  }
  setLabel() {
    if (
      2 !== arguments.length ||
      !Number.isInteger(arguments[1]) ||
      !Number.isInteger(arguments[0])
    )
      return super.setLabel.apply(this, arguments)
    {
      const t = arguments[0],
        e = arguments[1]
      null === this._label ? (this._label = new Fp(t, e)) : this._label.setLocation(t, e)
    }
  }
  getEdges() {
    return this._edges
  }
  mergeLabel() {
    if (arguments[0] instanceof Qp) {
      const t = arguments[0]
      this.mergeLabel(t._label)
    } else if (arguments[0] instanceof Fp) {
      const t = arguments[0]
      for (let e = 0; e < 2; e++) {
        const n = this.computeMergedLocation(t, e)
        this._label.getLocation(e) === pd.NONE && this._label.setLocation(e, n)
      }
    }
  }
  add(t) {
    this._edges.insert(t), t.setNode(this)
  }
  setLabelBoundary(t) {
    if (null === this._label) return null
    let e = pd.NONE
    null !== this._label && (e = this._label.getLocation(t))
    let n = null
    switch (e) {
      case pd.BOUNDARY:
        n = pd.INTERIOR
        break
      case pd.INTERIOR:
      default:
        n = pd.BOUNDARY
    }
    this._label.setLocation(t, n)
  }
}
class $p {
  constructor() {
    $p.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.nodeMap = new Wp()), (this.nodeFact = null)
    const t = arguments[0]
    this.nodeFact = t
  }
  find(t) {
    return this.nodeMap.get(t)
  }
  addNode() {
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      let e = this.nodeMap.get(t)
      return null === e && ((e = this.nodeFact.createNode(t)), this.nodeMap.put(t, e)), e
    }
    if (arguments[0] instanceof Qp) {
      const t = arguments[0],
        e = this.nodeMap.get(t.getCoordinate())
      return null === e ? (this.nodeMap.put(t.getCoordinate(), t), t) : (e.mergeLabel(t), e)
    }
  }
  print(t) {
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().print(t)
    }
  }
  iterator() {
    return this.nodeMap.values().iterator()
  }
  values() {
    return this.nodeMap.values()
  }
  getBoundaryNodes(t) {
    const e = new Yc()
    for (let n = this.iterator(); n.hasNext(); ) {
      const i = n.next()
      i.getLabel().getLocation(t) === pd.BOUNDARY && e.add(i)
    }
    return e
  }
  add(t) {
    const e = t.getCoordinate()
    this.addNode(e).add(t)
  }
}
class tg {
  constructor() {
    tg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._edge = null),
      (this._label = null),
      (this._node = null),
      (this._p0 = null),
      (this._p1 = null),
      (this._dx = null),
      (this._dy = null),
      (this._quadrant = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      this._edge = t
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      tg.constructor_.call(this, t, e, n, null)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      tg.constructor_.call(this, t), this.init(e, n), (this._label = i)
    }
  }
  compareDirection(t) {
    return this._dx === t._dx && this._dy === t._dy
      ? 0
      : this._quadrant > t._quadrant
        ? 1
        : this._quadrant < t._quadrant
          ? -1
          : nu.index(t._p0, t._p1, this._p1)
  }
  getDy() {
    return this._dy
  }
  getCoordinate() {
    return this._p0
  }
  setNode(t) {
    this._node = t
  }
  print(t) {
    const e = Math.atan2(this._dy, this._dx),
      n = this.getClass().getName(),
      i = n.lastIndexOf('.'),
      s = n.substring(i + 1)
    t.print(
      '  ' +
        s +
        ': ' +
        this._p0 +
        ' - ' +
        this._p1 +
        ' ' +
        this._quadrant +
        ':' +
        e +
        '   ' +
        this._label
    )
  }
  compareTo(t) {
    const e = t
    return this.compareDirection(e)
  }
  getDirectedCoordinate() {
    return this._p1
  }
  getDx() {
    return this._dx
  }
  getLabel() {
    return this._label
  }
  getEdge() {
    return this._edge
  }
  getQuadrant() {
    return this._quadrant
  }
  getNode() {
    return this._node
  }
  toString() {
    const t = Math.atan2(this._dy, this._dx),
      e = this.getClass().getName(),
      n = e.lastIndexOf('.')
    return (
      '  ' +
      e.substring(n + 1) +
      ': ' +
      this._p0 +
      ' - ' +
      this._p1 +
      ' ' +
      this._quadrant +
      ':' +
      t +
      '   ' +
      this._label
    )
  }
  computeLabel(t) {}
  init(t, e) {
    ;(this._p0 = t),
      (this._p1 = e),
      (this._dx = e.x - t.x),
      (this._dy = e.y - t.y),
      (this._quadrant = Rp.quadrant(this._dx, this._dy)),
      Cc.isTrue(!(0 === this._dx && 0 === this._dy), 'EdgeEnd with identical endpoints found')
  }
  get interfaces_() {
    return [Sc]
  }
}
class eg extends Rc {
  constructor(t, e) {
    super(e ? t + ' [ ' + e + ' ]' : t),
      (this.pt = e ? new Oc(e) : void 0),
      (this.name = Object.keys({ TopologyException: eg })[0])
  }
  getCoordinate() {
    return this.pt
  }
}
class ng extends tg {
  constructor() {
    super(), ng.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isForward = null),
      (this._isInResult = !1),
      (this._isVisited = !1),
      (this._sym = null),
      (this._next = null),
      (this._nextMin = null),
      (this._edgeRing = null),
      (this._minEdgeRing = null),
      (this._depth = [0, -999, -999])
    const t = arguments[0],
      e = arguments[1]
    if ((tg.constructor_.call(this, t), (this._isForward = e), e))
      this.init(t.getCoordinate(0), t.getCoordinate(1))
    else {
      const e = t.getNumPoints() - 1
      this.init(t.getCoordinate(e), t.getCoordinate(e - 1))
    }
    this.computeDirectedLabel()
  }
  static depthFactor(t, e) {
    return t === pd.EXTERIOR && e === pd.INTERIOR
      ? 1
      : t === pd.INTERIOR && e === pd.EXTERIOR
        ? -1
        : 0
  }
  getNextMin() {
    return this._nextMin
  }
  getDepth(t) {
    return this._depth[t]
  }
  setVisited(t) {
    this._isVisited = t
  }
  computeDirectedLabel() {
    ;(this._label = new Fp(this._edge.getLabel())), this._isForward || this._label.flip()
  }
  getNext() {
    return this._next
  }
  setDepth(t, e) {
    if (-999 !== this._depth[t] && this._depth[t] !== e)
      throw new eg('assigned depths do not match', this.getCoordinate())
    this._depth[t] = e
  }
  isInteriorAreaEdge() {
    let t = !0
    for (let e = 0; e < 2; e++)
      (this._label.isArea(e) &&
        this._label.getLocation(e, Lp.LEFT) === pd.INTERIOR &&
        this._label.getLocation(e, Lp.RIGHT) === pd.INTERIOR) ||
        (t = !1)
    return t
  }
  setNextMin(t) {
    this._nextMin = t
  }
  print(t) {
    super.print.call(this, t),
      t.print(' ' + this._depth[Lp.LEFT] + '/' + this._depth[Lp.RIGHT]),
      t.print(' (' + this.getDepthDelta() + ')'),
      this._isInResult && t.print(' inResult')
  }
  setMinEdgeRing(t) {
    this._minEdgeRing = t
  }
  isLineEdge() {
    const t = this._label.isLine(0) || this._label.isLine(1),
      e = !this._label.isArea(0) || this._label.allPositionsEqual(0, pd.EXTERIOR),
      n = !this._label.isArea(1) || this._label.allPositionsEqual(1, pd.EXTERIOR)
    return t && e && n
  }
  setEdgeRing(t) {
    this._edgeRing = t
  }
  getMinEdgeRing() {
    return this._minEdgeRing
  }
  getDepthDelta() {
    let t = this._edge.getDepthDelta()
    return this._isForward || (t = -t), t
  }
  setInResult(t) {
    this._isInResult = t
  }
  getSym() {
    return this._sym
  }
  isForward() {
    return this._isForward
  }
  getEdge() {
    return this._edge
  }
  printEdge(t) {
    this.print(t), t.print(' '), this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
  }
  setSym(t) {
    this._sym = t
  }
  setVisitedEdge(t) {
    this.setVisited(t), this._sym.setVisited(t)
  }
  setEdgeDepths(t, e) {
    let n = this.getEdge().getDepthDelta()
    this._isForward || (n = -n)
    let i = 1
    t === Lp.LEFT && (i = -1)
    const s = Lp.opposite(t),
      r = e + n * i
    this.setDepth(t, e), this.setDepth(s, r)
  }
  getEdgeRing() {
    return this._edgeRing
  }
  isInResult() {
    return this._isInResult
  }
  setNext(t) {
    this._next = t
  }
  isVisited() {
    return this._isVisited
  }
}
class ig {
  createNode(t) {
    return new Qp(t, null)
  }
}
class sg {
  constructor() {
    sg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._edges = new Yc()),
      (this._nodes = null),
      (this._edgeEndList = new Yc()),
      0 === arguments.length)
    )
      this._nodes = new $p(new ig())
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._nodes = new $p(t)
    }
  }
  static linkResultDirectedEdges(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      e.next().getEdges().linkResultDirectedEdges()
    }
  }
  printEdges(t) {
    t.println('Edges:')
    for (let e = 0; e < this._edges.size(); e++) {
      t.println('edge ' + e + ':')
      const n = this._edges.get(e)
      n.print(t), n.eiList.print(t)
    }
  }
  find(t) {
    return this._nodes.find(t)
  }
  addNode() {
    if (arguments[0] instanceof Qp) {
      const t = arguments[0]
      return this._nodes.addNode(t)
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      return this._nodes.addNode(t)
    }
  }
  getNodeIterator() {
    return this._nodes.iterator()
  }
  linkResultDirectedEdges() {
    for (let t = this._nodes.iterator(); t.hasNext(); ) {
      t.next().getEdges().linkResultDirectedEdges()
    }
  }
  debugPrintln(t) {
    su.out.println(t)
  }
  isBoundaryNode(t, e) {
    const n = this._nodes.find(e)
    if (null === n) return !1
    const i = n.getLabel()
    return null !== i && i.getLocation(t) === pd.BOUNDARY
  }
  linkAllDirectedEdges() {
    for (let t = this._nodes.iterator(); t.hasNext(); ) {
      t.next().getEdges().linkAllDirectedEdges()
    }
  }
  matchInSameDirection(t, e, n, i) {
    return (
      !!t.equals(n) && nu.index(t, e, i) === nu.COLLINEAR && Rp.quadrant(t, e) === Rp.quadrant(n, i)
    )
  }
  getEdgeEnds() {
    return this._edgeEndList
  }
  debugPrint(t) {
    su.out.print(t)
  }
  getEdgeIterator() {
    return this._edges.iterator()
  }
  findEdgeInSameDirection(t, e) {
    for (let n = 0; n < this._edges.size(); n++) {
      const i = this._edges.get(n),
        s = i.getCoordinates()
      if (this.matchInSameDirection(t, e, s[0], s[1])) return i
      if (this.matchInSameDirection(t, e, s[s.length - 1], s[s.length - 2])) return i
    }
    return null
  }
  insertEdge(t) {
    this._edges.add(t)
  }
  findEdgeEnd(t) {
    for (let e = this.getEdgeEnds().iterator(); e.hasNext(); ) {
      const n = e.next()
      if (n.getEdge() === t) return n
    }
    return null
  }
  addEdges(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this._edges.add(t)
      const n = new ng(t, !0),
        i = new ng(t, !1)
      n.setSym(i), i.setSym(n), this.add(n), this.add(i)
    }
  }
  add(t) {
    this._nodes.add(t), this._edgeEndList.add(t)
  }
  getNodes() {
    return this._nodes.values()
  }
  findEdge(t, e) {
    for (let n = 0; n < this._edges.size(); n++) {
      const i = this._edges.get(n),
        s = i.getCoordinates()
      if (t.equals(s[0]) && e.equals(s[1])) return i
    }
    return null
  }
}
class rg extends sg {
  constructor() {
    super(), rg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._parentGeom = null),
      (this._lineEdgeMap = new Bu()),
      (this._boundaryNodeRule = null),
      (this._useBoundaryDeterminationRule = !0),
      (this._argIndex = null),
      (this._boundaryNodes = null),
      (this._hasTooFewPoints = !1),
      (this._invalidPoint = null),
      (this._areaPtLocator = null),
      (this._ptLocator = new Ap()),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      rg.constructor_.call(this, t, e, wp.OGC_SFS_BOUNDARY_RULE)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._argIndex = t),
        (this._parentGeom = e),
        (this._boundaryNodeRule = n),
        null !== e && this.add(e)
    }
  }
  static determineBoundary(t, e) {
    return t.isInBoundary(e) ? pd.BOUNDARY : pd.INTERIOR
  }
  insertBoundaryPoint(t, e) {
    const n = this._nodes.addNode(e).getLabel()
    let i = 1,
      s = pd.NONE
    ;(s = n.getLocation(t, Lp.ON)), s === pd.BOUNDARY && i++
    const r = rg.determineBoundary(this._boundaryNodeRule, i)
    n.setLocation(t, r)
  }
  computeSelfNodes() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.computeSelfNodes(t, e, !1)
    }
    if (3 === arguments.length) {
      const t = arguments[1],
        e = arguments[2],
        n = new Pp(arguments[0], !0, !1)
      n.setIsDoneIfProperInt(e)
      const i = this.createEdgeSetIntersector(),
        s =
          this._parentGeom instanceof Ru ||
          this._parentGeom instanceof Eu ||
          this._parentGeom instanceof Ou,
        r = t || !s
      return (
        i.computeIntersections(this._edges, n, r), this.addSelfIntersectionNodes(this._argIndex), n
      )
    }
  }
  computeSplitEdges(t) {
    for (let e = this._edges.iterator(); e.hasNext(); ) {
      e.next().eiList.addSplitEdges(t)
    }
  }
  computeEdgeIntersections(t, e, n) {
    const i = new Pp(e, n, !0)
    i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes())
    return this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, i), i
  }
  getGeometry() {
    return this._parentGeom
  }
  getBoundaryNodeRule() {
    return this._boundaryNodeRule
  }
  hasTooFewPoints() {
    return this._hasTooFewPoints
  }
  addPoint() {
    if (arguments[0] instanceof xu) {
      const t = arguments[0].getCoordinate()
      this.insertPoint(this._argIndex, t, pd.INTERIOR)
    } else if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      this.insertPoint(this._argIndex, t, pd.INTERIOR)
    }
  }
  addPolygon(t) {
    this.addPolygonRing(t.getExteriorRing(), pd.EXTERIOR, pd.INTERIOR)
    for (let e = 0; e < t.getNumInteriorRing(); e++) {
      const n = t.getInteriorRingN(e)
      this.addPolygonRing(n, pd.INTERIOR, pd.EXTERIOR)
    }
  }
  addEdge(t) {
    this.insertEdge(t)
    const e = t.getCoordinates()
    this.insertPoint(this._argIndex, e[0], pd.BOUNDARY),
      this.insertPoint(this._argIndex, e[e.length - 1], pd.BOUNDARY)
  }
  addLineString(t) {
    const e = Cu.removeRepeatedPoints(t.getCoordinates())
    if (e.length < 2) return (this._hasTooFewPoints = !0), (this._invalidPoint = e[0]), null
    const n = new Jp(e, new Fp(this._argIndex, pd.INTERIOR))
    this._lineEdgeMap.put(t, n),
      this.insertEdge(n),
      Cc.isTrue(e.length >= 2, 'found LineString with single point'),
      this.insertBoundaryPoint(this._argIndex, e[0]),
      this.insertBoundaryPoint(this._argIndex, e[e.length - 1])
  }
  getInvalidPoint() {
    return this._invalidPoint
  }
  getBoundaryPoints() {
    const t = this.getBoundaryNodes(),
      e = new Array(t.size()).fill(null)
    let n = 0
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      e[n++] = t.getCoordinate().copy()
    }
    return e
  }
  getBoundaryNodes() {
    return (
      null === this._boundaryNodes &&
        (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)),
      this._boundaryNodes
    )
  }
  addSelfIntersectionNode(t, e, n) {
    if (this.isBoundaryNode(t, e)) return null
    n === pd.BOUNDARY && this._useBoundaryDeterminationRule
      ? this.insertBoundaryPoint(t, e)
      : this.insertPoint(t, e, n)
  }
  addPolygonRing(t, e, n) {
    if (t.isEmpty()) return null
    const i = Cu.removeRepeatedPoints(t.getCoordinates())
    if (i.length < 4) return (this._hasTooFewPoints = !0), (this._invalidPoint = i[0]), null
    let s = e,
      r = n
    nu.isCCW(i) && ((s = n), (r = e))
    const o = new Jp(i, new Fp(this._argIndex, pd.BOUNDARY, s, r))
    this._lineEdgeMap.put(t, o),
      this.insertEdge(o),
      this.insertPoint(this._argIndex, i[0], pd.BOUNDARY)
  }
  insertPoint(t, e, n) {
    const i = this._nodes.addNode(e),
      s = i.getLabel()
    null === s ? (i._label = new Fp(t, n)) : s.setLocation(t, n)
  }
  createEdgeSetIntersector() {
    return new Dp()
  }
  addSelfIntersectionNodes(t) {
    for (let e = this._edges.iterator(); e.hasNext(); ) {
      const n = e.next(),
        i = n.getLabel().getLocation(t)
      for (let e = n.eiList.iterator(); e.hasNext(); ) {
        const n = e.next()
        this.addSelfIntersectionNode(t, n.coord, i)
      }
    }
  }
  add() {
    if (!(1 === arguments.length && arguments[0] instanceof hu))
      return super.add.apply(this, arguments)
    {
      const t = arguments[0]
      if (t.isEmpty()) return null
      if ((t instanceof Ou && (this._useBoundaryDeterminationRule = !1), t instanceof Eu))
        this.addPolygon(t)
      else if (t instanceof mu) this.addLineString(t)
      else if (t instanceof xu) this.addPoint(t)
      else if (t instanceof Iu) this.addCollection(t)
      else if (t instanceof Hu) this.addCollection(t)
      else if (t instanceof Ou) this.addCollection(t)
      else {
        if (!(t instanceof Tu)) throw new pu(t.getGeometryType())
        this.addCollection(t)
      }
    }
  }
  addCollection(t) {
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const n = t.getGeometryN(e)
      this.add(n)
    }
  }
  locate(t) {
    return Uc(this._parentGeom, wu) && this._parentGeom.getNumGeometries() > 50
      ? (null === this._areaPtLocator && (this._areaPtLocator = new ip(this._parentGeom)),
        this._areaPtLocator.locate(t))
      : this._ptLocator.locate(t, this._parentGeom)
  }
  findEdge() {
    if (1 === arguments.length && arguments[0] instanceof mu) {
      const t = arguments[0]
      return this._lineEdgeMap.get(t)
    }
    return super.findEdge.apply(this, arguments)
  }
}
class og {
  visit(t) {}
}
class ag {
  constructor() {
    ag.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._p = null),
      (this._data = null),
      (this._left = null),
      (this._right = null),
      (this._count = null),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._p = new Oc(t)),
        (this._left = null),
        (this._right = null),
        (this._count = 1),
        (this._data = e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._p = new Oc(t, e)),
        (this._left = null),
        (this._right = null),
        (this._count = 1),
        (this._data = n)
    }
  }
  isRepeated() {
    return this._count > 1
  }
  getRight() {
    return this._right
  }
  getCoordinate() {
    return this._p
  }
  setLeft(t) {
    this._left = t
  }
  getX() {
    return this._p.x
  }
  getData() {
    return this._data
  }
  getCount() {
    return this._count
  }
  getLeft() {
    return this._left
  }
  getY() {
    return this._p.y
  }
  increment() {
    this._count = this._count + 1
  }
  setRight(t) {
    this._right = t
  }
}
class lg {
  constructor() {
    lg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._root = null),
      (this._numberOfNodes = null),
      (this._tolerance = null),
      0 === arguments.length)
    )
      lg.constructor_.call(this, 0)
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._tolerance = t
    }
  }
  static toCoordinates() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return lg.toCoordinates(t, !1)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new qc()
      for (let i = t.iterator(); i.hasNext(); ) {
        const t = i.next(),
          s = e ? t.getCount() : 1
        for (let e = 0; e < s; e++) n.add(t.getCoordinate(), !0)
      }
      return n.toCoordinateArray()
    }
  }
  insert() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.insert(t, null)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if (null === this._root) return (this._root = new ag(t, e)), this._root
      if (this._tolerance > 0) {
        const e = this.findBestMatchNode(t)
        if (null !== e) return e.increment(), e
      }
      return this.insertExact(t, e)
    }
  }
  query() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      return this.query(t, e), e
    }
    if (2 === arguments.length)
      if (arguments[0] instanceof Xc && Uc(arguments[1], kc)) {
        const t = arguments[0],
          e = arguments[1]
        this.queryNode(
          this._root,
          t,
          !0,
          new (class {
            get interfaces_() {
              return [og]
            }
            visit(t) {
              e.add(t)
            }
          })()
        )
      } else if (arguments[0] instanceof Xc && Uc(arguments[1], og)) {
        const t = arguments[0],
          e = arguments[1]
        this.queryNode(this._root, t, !0, e)
      }
  }
  queryNode(t, e, n, i) {
    if (null === t) return null
    let s = null,
      r = null,
      o = null
    n
      ? ((s = e.getMinX()), (r = e.getMaxX()), (o = t.getX()))
      : ((s = e.getMinY()), (r = e.getMaxY()), (o = t.getY()))
    const a = o <= r
    s < o && this.queryNode(t.getLeft(), e, !n, i),
      e.contains(t.getCoordinate()) && i.visit(t),
      a && this.queryNode(t.getRight(), e, !n, i)
  }
  findBestMatchNode(t) {
    const e = new hg(t, this._tolerance)
    return this.query(e.queryEnvelope(), e), e.getNode()
  }
  isEmpty() {
    return null === this._root
  }
  insertExact(t, e) {
    let n = this._root,
      i = this._root,
      s = !0,
      r = !0
    for (; null !== n; ) {
      if (null !== n) {
        if (t.distance(n.getCoordinate()) <= this._tolerance) return n.increment(), n
      }
      ;(r = s ? t.x < n.getX() : t.y < n.getY()),
        (i = n),
        (n = r ? n.getLeft() : n.getRight()),
        (s = !s)
    }
    this._numberOfNodes = this._numberOfNodes + 1
    const o = new ag(t, e)
    return r ? i.setLeft(o) : i.setRight(o), o
  }
}
class hg {
  constructor() {
    hg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._tolerance = null), (this._matchNode = null), (this._matchDist = 0), (this._p = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._p = t), (this._tolerance = e)
  }
  visit(t) {
    const e = this._p.distance(t.getCoordinate())
    if (!(e <= this._tolerance)) return null
    let n = !1
    ;(null === this._matchNode ||
      e < this._matchDist ||
      (null !== this._matchNode &&
        e === this._matchDist &&
        t.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1)) &&
      (n = !0),
      n && ((this._matchNode = t), (this._matchDist = e))
  }
  queryEnvelope() {
    const t = new Xc(this._p)
    return t.expandBy(this._tolerance), t
  }
  getNode() {
    return this._matchNode
  }
  get interfaces_() {
    return [og]
  }
}
lg.BestMatchVisitor = hg
class cg {
  constructor() {
    cg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._items = new Yc()), (this._subnode = new Array(4).fill(null))
  }
  static getSubnodeIndex(t, e, n) {
    let i = -1
    return (
      t.getMinX() >= e && (t.getMinY() >= n && (i = 3), t.getMaxY() <= n && (i = 1)),
      t.getMaxX() <= e && (t.getMinY() >= n && (i = 2), t.getMaxY() <= n && (i = 0)),
      i
    )
  }
  hasChildren() {
    for (let t = 0; t < 4; t++) if (null !== this._subnode[t]) return !0
    return !1
  }
  isPrunable() {
    return !(this.hasChildren() || this.hasItems())
  }
  addAllItems(t) {
    t.addAll(this._items)
    for (let e = 0; e < 4; e++) null !== this._subnode[e] && this._subnode[e].addAllItems(t)
    return t
  }
  getNodeCount() {
    let t = 0
    for (let e = 0; e < 4; e++) null !== this._subnode[e] && (t += this._subnode[e].size())
    return t + 1
  }
  size() {
    let t = 0
    for (let e = 0; e < 4; e++) null !== this._subnode[e] && (t += this._subnode[e].size())
    return t + this._items.size()
  }
  addAllItemsFromOverlapping(t, e) {
    if (!this.isSearchMatch(t)) return null
    e.addAll(this._items)
    for (let n = 0; n < 4; n++)
      null !== this._subnode[n] && this._subnode[n].addAllItemsFromOverlapping(t, e)
  }
  visitItems(t, e) {
    for (let t = this._items.iterator(); t.hasNext(); ) e.visitItem(t.next())
  }
  hasItems() {
    return !this._items.isEmpty()
  }
  remove(t, e) {
    if (!this.isSearchMatch(t)) return !1
    let n = !1
    for (let i = 0; i < 4; i++)
      if (null !== this._subnode[i] && ((n = this._subnode[i].remove(t, e)), n)) {
        this._subnode[i].isPrunable() && (this._subnode[i] = null)
        break
      }
    return n || ((n = this._items.remove(e)), n)
  }
  visit(t, e) {
    if (!this.isSearchMatch(t)) return null
    this.visitItems(t, e)
    for (let n = 0; n < 4; n++) null !== this._subnode[n] && this._subnode[n].visit(t, e)
  }
  getItems() {
    return this._items
  }
  depth() {
    let t = 0
    for (let e = 0; e < 4; e++)
      if (null !== this._subnode[e]) {
        const n = this._subnode[e].depth()
        n > t && (t = n)
      }
    return t + 1
  }
  isEmpty() {
    let t = !0
    if (this._items.isEmpty()) {
      for (let e = 0; e < 4; e++)
        if (null !== this._subnode[e] && !this._subnode[e].isEmpty()) {
          t = !1
          break
        }
    } else t = !1
    return t
  }
  add(t) {
    this._items.add(t)
  }
  get interfaces_() {
    return [Ic]
  }
}
function ug() {}
;(ug.exponent = function (t) {
  return (
    (function (t, e) {
      let n, i, s, r
      const o = { 32: { d: 127, c: 128, b: 0, a: 0 }, 64: { d: 32752, c: 0, b: 0, a: 0 } },
        a = { 32: 8, 64: 11 }[t]
      r ||
        ((n = e < 0 || 1 / e < 0),
        isFinite(e) ||
          ((r = o[t]), n && (r.d += 1 << (t / 4 - 1)), (i = Math.pow(2, a) - 1), (s = 0)))
      if (!r) {
        for (i = { 32: 127, 64: 1023 }[t], s = Math.abs(e); s >= 2; ) i++, (s /= 2)
        for (; s < 1 && i > 0; ) i--, (s *= 2)
        i <= 0 && (s /= 2),
          32 === t &&
            i > 254 &&
            ((r = { d: n ? 255 : 127, c: 128, b: 0, a: 0 }), (i = Math.pow(2, a) - 1), (s = 0))
      }
      return i
    })(64, t) - 1023
  )
}),
  (ug.powerOf2 = function (t) {
    return Math.pow(2, t)
  })
class dg {
  constructor() {
    dg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pt = new Oc()), (this._level = 0), (this._env = null)
    const t = arguments[0]
    this.computeKey(t)
  }
  static computeQuadLevel(t) {
    const e = t.getWidth(),
      n = t.getHeight(),
      i = e > n ? e : n
    return ug.exponent(i) + 1
  }
  getLevel() {
    return this._level
  }
  computeKey() {
    if (1 === arguments.length) {
      const t = arguments[0]
      for (
        this._level = dg.computeQuadLevel(t), this._env = new Xc(), this.computeKey(this._level, t);
        !this._env.contains(t);

      )
        (this._level += 1), this.computeKey(this._level, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = ug.powerOf2(t)
      ;(this._pt.x = Math.floor(e.getMinX() / n) * n),
        (this._pt.y = Math.floor(e.getMinY() / n) * n),
        this._env.init(this._pt.x, this._pt.x + n, this._pt.y, this._pt.y + n)
    }
  }
  getEnvelope() {
    return this._env
  }
  getCentre() {
    return new Oc(
      (this._env.getMinX() + this._env.getMaxX()) / 2,
      (this._env.getMinY() + this._env.getMaxY()) / 2
    )
  }
  getPoint() {
    return this._pt
  }
}
class pg extends cg {
  constructor() {
    super(), pg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._env = null), (this._centrex = null), (this._centrey = null), (this._level = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._env = t),
      (this._level = e),
      (this._centrex = (t.getMinX() + t.getMaxX()) / 2),
      (this._centrey = (t.getMinY() + t.getMaxY()) / 2)
  }
  static createNode(t) {
    const e = new dg(t)
    return new pg(e.getEnvelope(), e.getLevel())
  }
  static createExpanded(t, e) {
    const n = new Xc(e)
    null !== t && n.expandToInclude(t._env)
    const i = pg.createNode(n)
    return null !== t && i.insertNode(t), i
  }
  find(t) {
    const e = cg.getSubnodeIndex(t, this._centrex, this._centrey)
    if (-1 === e) return this
    if (null !== this._subnode[e]) {
      return this._subnode[e].find(t)
    }
    return this
  }
  isSearchMatch(t) {
    return null !== t && this._env.intersects(t)
  }
  getSubnode(t) {
    return null === this._subnode[t] && (this._subnode[t] = this.createSubnode(t)), this._subnode[t]
  }
  getEnvelope() {
    return this._env
  }
  getNode(t) {
    const e = cg.getSubnodeIndex(t, this._centrex, this._centrey)
    if (-1 !== e) {
      return this.getSubnode(e).getNode(t)
    }
    return this
  }
  createSubnode(t) {
    let e = 0,
      n = 0,
      i = 0,
      s = 0
    switch (t) {
      case 0:
        ;(e = this._env.getMinX()),
          (n = this._centrex),
          (i = this._env.getMinY()),
          (s = this._centrey)
        break
      case 1:
        ;(e = this._centrex),
          (n = this._env.getMaxX()),
          (i = this._env.getMinY()),
          (s = this._centrey)
        break
      case 2:
        ;(e = this._env.getMinX()),
          (n = this._centrex),
          (i = this._centrey),
          (s = this._env.getMaxY())
        break
      case 3:
        ;(e = this._centrex),
          (n = this._env.getMaxX()),
          (i = this._centrey),
          (s = this._env.getMaxY())
    }
    const r = new Xc(e, n, i, s)
    return new pg(r, this._level - 1)
  }
  insertNode(t) {
    Cc.isTrue(null === this._env || this._env.contains(t._env))
    const e = cg.getSubnodeIndex(t._env, this._centrex, this._centrey)
    if (t._level === this._level - 1) this._subnode[e] = t
    else {
      const n = this.createSubnode(e)
      n.insertNode(t), (this._subnode[e] = n)
    }
  }
}
class gg {
  static isZeroWidth(t, e) {
    const n = e - t
    if (0 === n) return !0
    const i = n / Math.max(Math.abs(t), Math.abs(e))
    return ug.exponent(i) <= gg.MIN_BINARY_EXPONENT
  }
}
gg.MIN_BINARY_EXPONENT = -50
class fg extends cg {
  constructor() {
    super()
  }
  insert(t, e) {
    const n = cg.getSubnodeIndex(t, fg.origin.x, fg.origin.y)
    if (-1 === n) return this.add(e), null
    const i = this._subnode[n]
    if (null === i || !i.getEnvelope().contains(t)) {
      const e = pg.createExpanded(i, t)
      this._subnode[n] = e
    }
    this.insertContained(this._subnode[n], t, e)
  }
  isSearchMatch(t) {
    return !0
  }
  insertContained(t, e, n) {
    Cc.isTrue(t.getEnvelope().contains(e))
    const i = gg.isZeroWidth(e.getMinX(), e.getMaxX()),
      s = gg.isZeroWidth(e.getMinY(), e.getMaxY())
    let r = null
    ;(r = i || s ? t.find(e) : t.getNode(e)), r.add(n)
  }
}
fg.origin = new Oc(0, 0)
class mg {
  insert(t, e) {}
  remove(t, e) {}
  query() {}
}
class yg {
  constructor() {
    yg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._root = null), (this._minExtent = 1), (this._root = new fg())
  }
  static ensureExtent(t, e) {
    let n = t.getMinX(),
      i = t.getMaxX(),
      s = t.getMinY(),
      r = t.getMaxY()
    return n !== i && s !== r
      ? t
      : (n === i && ((n -= e / 2), (i += e / 2)),
        s === r && ((s -= e / 2), (r += e / 2)),
        new Xc(n, i, s, r))
  }
  size() {
    return null !== this._root ? this._root.size() : 0
  }
  insert(t, e) {
    this.collectStats(t)
    const n = yg.ensureExtent(t, this._minExtent)
    this._root.insert(n, e)
  }
  query() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new ep()
      return this.query(t, e), e.getItems()
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this._root.visit(t, e)
    }
  }
  queryAll() {
    const t = new Yc()
    return this._root.addAllItems(t), t
  }
  remove(t, e) {
    const n = yg.ensureExtent(t, this._minExtent)
    return this._root.remove(n, e)
  }
  collectStats(t) {
    const e = t.getWidth()
    e < this._minExtent && e > 0 && (this._minExtent = e)
    const n = t.getHeight()
    n < this._minExtent && n > 0 && (this._minExtent = n)
  }
  depth() {
    return null !== this._root ? this._root.depth() : 0
  }
  isEmpty() {
    return null === this._root || this._root.isEmpty()
  }
  get interfaces_() {
    return [mg, Ic]
  }
}
class xg {
  getBounds() {}
}
class vg {
  constructor() {
    vg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._bounds = null), (this._item = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._bounds = t), (this._item = e)
  }
  getItem() {
    return this._item
  }
  getBounds() {
    return this._bounds
  }
  get interfaces_() {
    return [xg, Ic]
  }
}
class _g {
  constructor() {
    _g.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._size = null),
      (this._items = null),
      (this._size = 0),
      (this._items = new Yc()),
      this._items.add(null)
  }
  poll() {
    if (this.isEmpty()) return null
    const t = this._items.get(1)
    return this._items.set(1, this._items.get(this._size)), (this._size -= 1), this.reorder(1), t
  }
  size() {
    return this._size
  }
  reorder(t) {
    let e = null
    const n = this._items.get(t)
    for (
      ;
      2 * t <= this._size &&
      ((e = 2 * t),
      e !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++,
      this._items.get(e).compareTo(n) < 0);
      t = e
    )
      this._items.set(t, this._items.get(e))
    this._items.set(t, n)
  }
  clear() {
    ;(this._size = 0), this._items.clear()
  }
  peek() {
    if (this.isEmpty()) return null
    return this._items.get(1)
  }
  isEmpty() {
    return 0 === this._size
  }
  add(t) {
    this._items.add(null), (this._size += 1)
    let e = this._size
    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2)
      this._items.set(e, this._items.get(Math.trunc(e / 2)))
    this._items.set(e, t)
  }
}
class wg {
  constructor() {
    wg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._childBoundables = new Yc()),
      (this._bounds = null),
      (this._level = null),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._level = t
    }
  }
  getLevel() {
    return this._level
  }
  size() {
    return this._childBoundables.size()
  }
  getChildBoundables() {
    return this._childBoundables
  }
  addChildBoundable(t) {
    Cc.isTrue(null === this._bounds), this._childBoundables.add(t)
  }
  isEmpty() {
    return this._childBoundables.isEmpty()
  }
  getBounds() {
    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds
  }
  get interfaces_() {
    return [xg, Ic]
  }
}
class Eg {
  static maxDistance(t, e, n, i, s, r, o, a) {
    let l = Eg.distance(t, e, s, r)
    return (
      (l = Math.max(l, Eg.distance(t, e, o, a))),
      (l = Math.max(l, Eg.distance(n, i, s, r))),
      (l = Math.max(l, Eg.distance(n, i, o, a))),
      l
    )
  }
  static distance(t, e, n, i) {
    const s = n - t,
      r = i - e
    return Math.sqrt(s * s + r * r)
  }
  static maximumDistance(t, e) {
    const n = Math.min(t.getMinX(), e.getMinX()),
      i = Math.min(t.getMinY(), e.getMinY()),
      s = Math.max(t.getMaxX(), e.getMaxX()),
      r = Math.max(t.getMaxY(), e.getMaxY())
    return Eg.distance(n, i, s, r)
  }
  static minMaxDistance(t, e) {
    const n = t.getMinX(),
      i = t.getMinY(),
      s = t.getMaxX(),
      r = t.getMaxY(),
      o = e.getMinX(),
      a = e.getMinY(),
      l = e.getMaxX(),
      h = e.getMaxY()
    let c = Eg.maxDistance(n, i, n, r, o, a, o, h)
    return (
      (c = Math.min(c, Eg.maxDistance(n, i, n, r, o, a, l, a))),
      (c = Math.min(c, Eg.maxDistance(n, i, n, r, l, h, o, h))),
      (c = Math.min(c, Eg.maxDistance(n, i, n, r, l, h, l, a))),
      (c = Math.min(c, Eg.maxDistance(n, i, s, i, o, a, o, h))),
      (c = Math.min(c, Eg.maxDistance(n, i, s, i, o, a, l, a))),
      (c = Math.min(c, Eg.maxDistance(n, i, s, i, l, h, o, h))),
      (c = Math.min(c, Eg.maxDistance(n, i, s, i, l, h, l, a))),
      (c = Math.min(c, Eg.maxDistance(s, r, n, r, o, a, o, h))),
      (c = Math.min(c, Eg.maxDistance(s, r, n, r, o, a, l, a))),
      (c = Math.min(c, Eg.maxDistance(s, r, n, r, l, h, o, h))),
      (c = Math.min(c, Eg.maxDistance(s, r, n, r, l, h, l, a))),
      (c = Math.min(c, Eg.maxDistance(s, r, s, i, o, a, o, h))),
      (c = Math.min(c, Eg.maxDistance(s, r, s, i, o, a, l, a))),
      (c = Math.min(c, Eg.maxDistance(s, r, s, i, l, h, o, h))),
      (c = Math.min(c, Eg.maxDistance(s, r, s, i, l, h, l, a))),
      c
    )
  }
}
class bg {
  constructor() {
    bg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._boundable1 = null),
      (this._boundable2 = null),
      (this._distance = null),
      (this._itemDistance = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._boundable1 = t),
      (this._boundable2 = e),
      (this._itemDistance = n),
      (this._distance = this.distance())
  }
  static area(t) {
    return t.getBounds().getArea()
  }
  static isComposite(t) {
    return t instanceof wg
  }
  maximumDistance() {
    return Eg.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds())
  }
  expandToQueue(t, e) {
    const n = bg.isComposite(this._boundable1),
      i = bg.isComposite(this._boundable2)
    if (n && i)
      return bg.area(this._boundable1) > bg.area(this._boundable2)
        ? (this.expand(this._boundable1, this._boundable2, !1, t, e), null)
        : (this.expand(this._boundable2, this._boundable1, !0, t, e), null)
    if (n) return this.expand(this._boundable1, this._boundable2, !1, t, e), null
    if (i) return this.expand(this._boundable2, this._boundable1, !0, t, e), null
    throw new Ec('neither boundable is composite')
  }
  isLeaves() {
    return !(bg.isComposite(this._boundable1) || bg.isComposite(this._boundable2))
  }
  compareTo(t) {
    const e = t
    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
  }
  expand(t, e, n, i, s) {
    for (let r = t.getChildBoundables().iterator(); r.hasNext(); ) {
      const t = r.next()
      let o = null
      ;(o = n ? new bg(e, t, this._itemDistance) : new bg(t, e, this._itemDistance)),
        o.getDistance() < s && i.add(o)
    }
  }
  getBoundable(t) {
    return 0 === t ? this._boundable1 : this._boundable2
  }
  getDistance() {
    return this._distance
  }
  distance() {
    return this.isLeaves()
      ? this._itemDistance.distance(this._boundable1, this._boundable2)
      : this._boundable1.getBounds().distance(this._boundable2.getBounds())
  }
  get interfaces_() {
    return [Sc]
  }
}
class Mg {
  constructor() {
    Mg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._root = null),
      (this._built = !1),
      (this._itemBoundables = new Yc()),
      (this._nodeCapacity = null),
      0 === arguments.length)
    )
      Mg.constructor_.call(this, Mg.DEFAULT_NODE_CAPACITY)
    else if (1 === arguments.length) {
      const t = arguments[0]
      Cc.isTrue(t > 1, 'Node capacity must be greater than 1'), (this._nodeCapacity = t)
    }
  }
  static compareDoubles(t, e) {
    return t > e ? 1 : t < e ? -1 : 0
  }
  queryInternal() {
    if (Uc(arguments[2], Xd) && arguments[0] instanceof Object && arguments[1] instanceof wg) {
      const t = arguments[0],
        e = arguments[2],
        n = arguments[1].getChildBoundables()
      for (let i = 0; i < n.size(); i++) {
        const s = n.get(i)
        this.getIntersectsOp().intersects(s.getBounds(), t) &&
          (s instanceof wg
            ? this.queryInternal(t, s, e)
            : s instanceof vg
              ? e.visitItem(s.getItem())
              : Cc.shouldNeverReachHere())
      }
    } else if (
      Uc(arguments[2], kc) &&
      arguments[0] instanceof Object &&
      arguments[1] instanceof wg
    ) {
      const t = arguments[0],
        e = arguments[2],
        n = arguments[1].getChildBoundables()
      for (let i = 0; i < n.size(); i++) {
        const s = n.get(i)
        this.getIntersectsOp().intersects(s.getBounds(), t) &&
          (s instanceof wg
            ? this.queryInternal(t, s, e)
            : s instanceof vg
              ? e.add(s.getItem())
              : Cc.shouldNeverReachHere())
      }
    }
  }
  getNodeCapacity() {
    return this._nodeCapacity
  }
  lastNode(t) {
    return t.get(t.size() - 1)
  }
  size() {
    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root))
    if (1 === arguments.length) {
      let t = 0
      for (let e = arguments[0].getChildBoundables().iterator(); e.hasNext(); ) {
        const n = e.next()
        n instanceof wg ? (t += this.size(n)) : n instanceof vg && (t += 1)
      }
      return t
    }
  }
  removeItem(t, e) {
    let n = null
    for (let i = t.getChildBoundables().iterator(); i.hasNext(); ) {
      const t = i.next()
      t instanceof vg && t.getItem() === e && (n = t)
    }
    return null !== n && (t.getChildBoundables().remove(n), !0)
  }
  itemsTree() {
    if (0 === arguments.length) {
      this.build()
      const t = this.itemsTree(this._root)
      return null === t ? new Yc() : t
    }
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      for (let n = t.getChildBoundables().iterator(); n.hasNext(); ) {
        const t = n.next()
        if (t instanceof wg) {
          const n = this.itemsTree(t)
          null !== n && e.add(n)
        } else t instanceof vg ? e.add(t.getItem()) : Cc.shouldNeverReachHere()
      }
      return e.size() <= 0 ? null : e
    }
  }
  insert(t, e) {
    Cc.isTrue(
      !this._built,
      'Cannot insert items into an STR packed R-tree after it has been built.'
    ),
      this._itemBoundables.add(new vg(t, e))
  }
  boundablesAtLevel() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      return this.boundablesAtLevel(t, this._root, e), e
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if ((Cc.isTrue(t > -2), e.getLevel() === t)) return n.add(e), null
      for (let i = e.getChildBoundables().iterator(); i.hasNext(); ) {
        const e = i.next()
        e instanceof wg
          ? this.boundablesAtLevel(t, e, n)
          : (Cc.isTrue(e instanceof vg), -1 === t && n.add(e))
      }
      return null
    }
  }
  query() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.build()
      const e = new Yc()
      return (
        this.isEmpty() ||
          (this.getIntersectsOp().intersects(this._root.getBounds(), t) &&
            this.queryInternal(t, this._root, e)),
        e
      )
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      if ((this.build(), this.isEmpty())) return null
      this.getIntersectsOp().intersects(this._root.getBounds(), t) &&
        this.queryInternal(t, this._root, e)
    }
  }
  build() {
    if (this._built) return null
    ;(this._root = this._itemBoundables.isEmpty()
      ? this.createNode(0)
      : this.createHigherLevels(this._itemBoundables, -1)),
      (this._itemBoundables = null),
      (this._built = !0)
  }
  getRoot() {
    return this.build(), this._root
  }
  remove() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return (
        this.build(),
        !!this.getIntersectsOp().intersects(this._root.getBounds(), t) &&
          this.remove(t, this._root, e)
      )
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      let i = this.removeItem(e, n)
      if (i) return !0
      let s = null
      for (let r = e.getChildBoundables().iterator(); r.hasNext(); ) {
        const e = r.next()
        if (
          this.getIntersectsOp().intersects(e.getBounds(), t) &&
          e instanceof wg &&
          ((i = this.remove(t, e, n)), i)
        ) {
          s = e
          break
        }
      }
      return null !== s && s.getChildBoundables().isEmpty() && e.getChildBoundables().remove(s), i
    }
  }
  createHigherLevels(t, e) {
    Cc.isTrue(!t.isEmpty())
    const n = this.createParentBoundables(t, e + 1)
    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
  }
  depth() {
    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root))
    if (1 === arguments.length) {
      let t = 0
      for (let e = arguments[0].getChildBoundables().iterator(); e.hasNext(); ) {
        const n = e.next()
        if (n instanceof wg) {
          const e = this.depth(n)
          e > t && (t = e)
        }
      }
      return t + 1
    }
  }
  createParentBoundables(t, e) {
    Cc.isTrue(!t.isEmpty())
    const n = new Yc()
    n.add(this.createNode(e))
    const i = new Yc(t)
    Od.sort(i, this.getComparator())
    for (let t = i.iterator(); t.hasNext(); ) {
      const i = t.next()
      this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() &&
        n.add(this.createNode(e)),
        this.lastNode(n).addChildBoundable(i)
    }
    return n
  }
  isEmpty() {
    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
  }
  get interfaces_() {
    return [Ic]
  }
}
;(Mg.IntersectsOp = function () {}), (Mg.DEFAULT_NODE_CAPACITY = 10)
class Sg {
  distance(t, e) {}
}
class Ag extends Mg {
  constructor() {
    super(), Ag.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (0 === arguments.length) Ag.constructor_.call(this, Ag.DEFAULT_NODE_CAPACITY)
    else if (1 === arguments.length) {
      const t = arguments[0]
      Mg.constructor_.call(this, t)
    }
  }
  static centreX(t) {
    return Ag.avg(t.getMinX(), t.getMaxX())
  }
  static avg(t, e) {
    return (t + e) / 2
  }
  static getItems(t) {
    const e = new Array(t.size()).fill(null)
    let n = 0
    for (; !t.isEmpty(); ) {
      const i = t.poll()
      ;(e[n] = i.getBoundable(0).getItem()), n++
    }
    return e
  }
  static centreY(t) {
    return Ag.avg(t.getMinY(), t.getMaxY())
  }
  createParentBoundablesFromVerticalSlices(t, e) {
    Cc.isTrue(t.length > 0)
    const n = new Yc()
    for (let i = 0; i < t.length; i++)
      n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e))
    return n
  }
  nearestNeighbourK() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this.nearestNeighbourK(t, Mc.POSITIVE_INFINITY, e)
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[2]
      let n = arguments[1]
      const i = new _g()
      i.add(t)
      const s = new _g()
      for (; !i.isEmpty() && n >= 0; ) {
        const t = i.poll(),
          r = t.getDistance()
        if (r >= n) break
        if (t.isLeaves())
          if (s.size() < e) s.add(t)
          else {
            s.peek().getDistance() > r && (s.poll(), s.add(t))
            n = s.peek().getDistance()
          }
        else t.expandToQueue(i, n)
      }
      return Ag.getItems(s)
    }
  }
  createNode(t) {
    return new Tg(t)
  }
  size() {
    return 0 === arguments.length ? super.size.call(this) : super.size.apply(this, arguments)
  }
  insert() {
    if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof Xc))
      return super.insert.apply(this, arguments)
    {
      const t = arguments[0],
        e = arguments[1]
      if (t.isNull()) return null
      super.insert.call(this, t, e)
    }
  }
  getIntersectsOp() {
    return Ag.intersectsOp
  }
  verticalSlices(t, e) {
    const n = Math.trunc(Math.ceil(t.size() / e)),
      i = new Array(e).fill(null),
      s = t.iterator()
    for (let t = 0; t < e; t++) {
      i[t] = new Yc()
      let e = 0
      for (; s.hasNext() && e < n; ) {
        const n = s.next()
        i[t].add(n), e++
      }
    }
    return i
  }
  query() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return super.query.call(this, t)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      super.query.call(this, t, e)
    }
  }
  getComparator() {
    return Ag.yComparator
  }
  createParentBoundablesFromVerticalSlice(t, e) {
    return super.createParentBoundables.call(this, t, e)
  }
  remove() {
    if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof Xc) {
      const t = arguments[0],
        e = arguments[1]
      return super.remove.call(this, t, e)
    }
    return super.remove.apply(this, arguments)
  }
  depth() {
    return 0 === arguments.length ? super.depth.call(this) : super.depth.apply(this, arguments)
  }
  createParentBoundables(t, e) {
    Cc.isTrue(!t.isEmpty())
    const n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
      i = new Yc(t)
    Od.sort(i, Ag.xComparator)
    const s = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n))))
    return this.createParentBoundablesFromVerticalSlices(s, e)
  }
  nearestNeighbour() {
    if (1 === arguments.length) {
      if (Uc(arguments[0], Sg)) {
        const t = arguments[0]
        if (this.isEmpty()) return null
        const e = new bg(this.getRoot(), this.getRoot(), t)
        return this.nearestNeighbour(e)
      }
      if (arguments[0] instanceof bg) {
        const t = arguments[0]
        let e = Mc.POSITIVE_INFINITY,
          n = null
        const i = new _g()
        for (i.add(t); !i.isEmpty() && e > 0; ) {
          const t = i.poll(),
            s = t.getDistance()
          if (s >= e) break
          t.isLeaves() ? ((e = s), (n = t)) : t.expandToQueue(i, e)
        }
        return null === n ? null : [n.getBoundable(0).getItem(), n.getBoundable(1).getItem()]
      }
    } else {
      if (2 === arguments.length) {
        const t = arguments[0],
          e = arguments[1]
        if (this.isEmpty() || t.isEmpty()) return null
        const n = new bg(this.getRoot(), t.getRoot(), e)
        return this.nearestNeighbour(n)
      }
      if (3 === arguments.length) {
        const t = arguments[2],
          e = new vg(arguments[0], arguments[1]),
          n = new bg(this.getRoot(), e, t)
        return this.nearestNeighbour(n)[0]
      }
      if (4 === arguments.length) {
        const t = arguments[2],
          e = arguments[3],
          n = new vg(arguments[0], arguments[1]),
          i = new bg(this.getRoot(), n, t)
        return this.nearestNeighbourK(i, e)
      }
    }
  }
  isWithinDistance() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = Mc.POSITIVE_INFINITY
      const i = new _g()
      for (i.add(t); !i.isEmpty(); ) {
        const t = i.poll(),
          s = t.getDistance()
        if (s > e) return !1
        if (t.maximumDistance() <= e) return !0
        if (t.isLeaves()) {
          if (((n = s), n <= e)) return !0
        } else t.expandToQueue(i, n)
      }
      return !1
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = new bg(this.getRoot(), t.getRoot(), e)
      return this.isWithinDistance(i, n)
    }
  }
  get interfaces_() {
    return [mg, Ic]
  }
}
class Tg extends wg {
  constructor() {
    super(), Tg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0]
    wg.constructor_.call(this, t)
  }
  computeBounds() {
    let t = null
    for (let e = this.getChildBoundables().iterator(); e.hasNext(); ) {
      const n = e.next()
      null === t ? (t = new Xc(n.getBounds())) : t.expandToInclude(n.getBounds())
    }
    return t
  }
}
;(Ag.STRtreeNode = Tg),
  (Ag.xComparator = new (class {
    get interfaces_() {
      return [Tc]
    }
    compare(t, e) {
      return Mg.compareDoubles(Ag.centreX(t.getBounds()), Ag.centreX(e.getBounds()))
    }
  })()),
  (Ag.yComparator = new (class {
    get interfaces_() {
      return [Tc]
    }
    compare(t, e) {
      return Mg.compareDoubles(Ag.centreY(t.getBounds()), Ag.centreY(e.getBounds()))
    }
  })()),
  (Ag.intersectsOp = new (class {
    get interfaces_() {
      return [IntersectsOp]
    }
    intersects(t, e) {
      return t.intersects(e)
    }
  })()),
  (Ag.DEFAULT_NODE_CAPACITY = 10)
class Ig {
  static relativeSign(t, e) {
    return t < e ? -1 : t > e ? 1 : 0
  }
  static compare(t, e, n) {
    if (e.equals2D(n)) return 0
    const i = Ig.relativeSign(e.x, n.x),
      s = Ig.relativeSign(e.y, n.y)
    switch (t) {
      case 0:
        return Ig.compareValue(i, s)
      case 1:
        return Ig.compareValue(s, i)
      case 2:
        return Ig.compareValue(s, -i)
      case 3:
        return Ig.compareValue(-i, s)
      case 4:
        return Ig.compareValue(-i, -s)
      case 5:
        return Ig.compareValue(-s, -i)
      case 6:
        return Ig.compareValue(-s, i)
      case 7:
        return Ig.compareValue(i, -s)
    }
    return Cc.shouldNeverReachHere('invalid octant value'), 0
  }
  static compareValue(t, e) {
    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
  }
}
class Rg {
  constructor() {
    Rg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._segString = null),
      (this.coord = null),
      (this.segmentIndex = null),
      (this._segmentOctant = null),
      (this._isInterior = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2],
      i = arguments[3]
    ;(this._segString = t),
      (this.coord = new Oc(e)),
      (this.segmentIndex = n),
      (this._segmentOctant = i),
      (this._isInterior = !e.equals2D(t.getCoordinate(n)))
  }
  getCoordinate() {
    return this.coord
  }
  print(t) {
    t.print(this.coord), t.print(' seg # = ' + this.segmentIndex)
  }
  compareTo(t) {
    const e = t
    return this.segmentIndex < e.segmentIndex
      ? -1
      : this.segmentIndex > e.segmentIndex
        ? 1
        : this.coord.equals2D(e.coord)
          ? 0
          : this._isInterior
            ? e._isInterior
              ? Ig.compare(this._segmentOctant, this.coord, e.coord)
              : 1
            : -1
  }
  isEndPoint(t) {
    return (0 === this.segmentIndex && !this._isInterior) || this.segmentIndex === t
  }
  toString() {
    return this.segmentIndex + ':' + this.coord.toString()
  }
  isInterior() {
    return this._isInterior
  }
  get interfaces_() {
    return [Sc]
  }
}
class Lg {
  constructor() {
    Lg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._nodeMap = new Wp()), (this._edge = null)
    const t = arguments[0]
    this._edge = t
  }
  getSplitCoordinates() {
    const t = new qc()
    this.addEndpoints()
    const e = this.iterator()
    let n = e.next()
    for (; e.hasNext(); ) {
      const i = e.next()
      this.addEdgeCoordinates(n, i, t), (n = i)
    }
    return t.toCoordinateArray()
  }
  addCollapsedNodes() {
    const t = new Yc()
    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t)
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next().intValue()
      this.add(this._edge.getCoordinate(t), t)
    }
  }
  createSplitEdgePts(t, e) {
    let n = e.segmentIndex - t.segmentIndex + 2
    if (2 === n) return [new Oc(t.coord), new Oc(e.coord)]
    const i = this._edge.getCoordinate(e.segmentIndex),
      s = e.isInterior() || !e.coord.equals2D(i)
    s || n--
    const r = new Array(n).fill(null)
    let o = 0
    r[o++] = new Oc(t.coord)
    for (let n = t.segmentIndex + 1; n <= e.segmentIndex; n++) r[o++] = this._edge.getCoordinate(n)
    return s && (r[o] = new Oc(e.coord)), r
  }
  print(t) {
    t.println('Intersections:')
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().print(t)
    }
  }
  findCollapsesFromExistingVertices(t) {
    for (let e = 0; e < this._edge.size() - 2; e++) {
      const n = this._edge.getCoordinate(e)
      this._edge.getCoordinate(e + 1)
      const i = this._edge.getCoordinate(e + 2)
      n.equals2D(i) && t.add(Jc.valueOf(e + 1))
    }
  }
  addEdgeCoordinates(t, e, n) {
    const i = this.createSplitEdgePts(t, e)
    n.add(i, !1)
  }
  iterator() {
    return this._nodeMap.values().iterator()
  }
  addSplitEdges(t) {
    this.addEndpoints(), this.addCollapsedNodes()
    const e = this.iterator()
    let n = e.next()
    for (; e.hasNext(); ) {
      const i = e.next(),
        s = this.createSplitEdge(n, i)
      t.add(s), (n = i)
    }
  }
  findCollapseIndex(t, e, n) {
    if (!t.coord.equals2D(e.coord)) return !1
    let i = e.segmentIndex - t.segmentIndex
    return e.isInterior() || i--, 1 === i && ((n[0] = t.segmentIndex + 1), !0)
  }
  findCollapsesFromInsertedNodes(t) {
    const e = new Array(1).fill(null),
      n = this.iterator()
    let i = n.next()
    for (; n.hasNext(); ) {
      const s = n.next()
      this.findCollapseIndex(i, s, e) && t.add(Jc.valueOf(e[0])), (i = s)
    }
  }
  getEdge() {
    return this._edge
  }
  addEndpoints() {
    const t = this._edge.size() - 1
    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t)
  }
  createSplitEdge(t, e) {
    const n = this.createSplitEdgePts(t, e)
    return new Dg(n, this._edge.getData())
  }
  add(t, e) {
    const n = new Rg(this._edge, t, e, this._edge.getSegmentOctant(e)),
      i = this._nodeMap.get(n)
    return null !== i
      ? (Cc.isTrue(i.coord.equals2D(t), 'Found equal nodes with different coordinates'), i)
      : (this._nodeMap.put(n, n), n)
  }
  checkSplitEdgesCorrectness(t) {
    const e = this._edge.getCoordinates(),
      n = t.get(0).getCoordinate(0)
    if (!n.equals2D(e[0])) throw new Rc('bad split edge start point at ' + n)
    const i = t.get(t.size() - 1).getCoordinates(),
      s = i[i.length - 1]
    if (!s.equals2D(e[e.length - 1])) throw new Rc('bad split edge end point at ' + s)
  }
}
class Cg {
  static octant() {
    if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
      const t = arguments[0],
        e = arguments[1]
      if (0 === t && 0 === e)
        throw new Ec('Cannot compute the octant for point ( ' + t + ', ' + e + ' )')
      const n = Math.abs(t),
        i = Math.abs(e)
      return t >= 0
        ? e >= 0
          ? n >= i
            ? 0
            : 1
          : n >= i
            ? 7
            : 6
        : e >= 0
          ? n >= i
            ? 3
            : 2
          : n >= i
            ? 4
            : 5
    }
    if (arguments[0] instanceof Oc && arguments[1] instanceof Oc) {
      const t = arguments[0],
        e = arguments[1],
        n = e.x - t.x,
        i = e.y - t.y
      if (0 === n && 0 === i)
        throw new Ec('Cannot compute the octant for two identical points ' + t)
      return Cg.octant(n, i)
    }
  }
}
class Ng {
  getCoordinates() {}
  size() {}
  getCoordinate(t) {}
  isClosed() {}
  setData(t) {}
  getData() {}
}
class Pg {
  addIntersection(t, e) {}
  get interfaces_() {
    return [Ng]
  }
}
class Dg {
  constructor() {
    Dg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._nodeList = new Lg(this)), (this._pts = null), (this._data = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._pts = t), (this._data = e)
  }
  static getNodedSubstrings() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      return Dg.getNodedSubstrings(t, e), e
    }
    if (2 === arguments.length) {
      const t = arguments[1]
      for (let e = arguments[0].iterator(); e.hasNext(); ) {
        e.next().getNodeList().addSplitEdges(t)
      }
    }
  }
  getCoordinates() {
    return this._pts
  }
  size() {
    return this._pts.length
  }
  getCoordinate(t) {
    return this._pts[t]
  }
  isClosed() {
    return this._pts[0].equals(this._pts[this._pts.length - 1])
  }
  getSegmentOctant(t) {
    return t === this._pts.length - 1
      ? -1
      : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
  }
  setData(t) {
    this._data = t
  }
  safeOctant(t, e) {
    return t.equals2D(e) ? 0 : Cg.octant(t, e)
  }
  getData() {
    return this._data
  }
  addIntersection() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.addIntersectionNode(t, e)
    } else if (4 === arguments.length) {
      const t = arguments[1],
        e = arguments[3],
        n = new Oc(arguments[0].getIntersection(e))
      this.addIntersection(n, t)
    }
  }
  toString() {
    return hd.toLineString(new Pu(this._pts))
  }
  getNodeList() {
    return this._nodeList
  }
  addIntersectionNode(t, e) {
    let n = e
    const i = n + 1
    if (i < this._pts.length) {
      const e = this._pts[i]
      t.equals2D(e) && (n = i)
    }
    return this._nodeList.add(t, n)
  }
  addIntersections(t, e, n) {
    for (let i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
  }
  get interfaces_() {
    return [Pg]
  }
}
class Og {
  constructor() {
    Og.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._overlapSeg1 = new dd()), (this._overlapSeg2 = new dd())
  }
  overlap() {
    if (2 === arguments.length);
    else if (4 === arguments.length) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3]
      arguments[0].getLineSegment(t, this._overlapSeg1),
        e.getLineSegment(n, this._overlapSeg2),
        this.overlap(this._overlapSeg1, this._overlapSeg2)
    }
  }
}
class Fg {
  constructor() {
    Fg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pts = null),
      (this._start = null),
      (this._end = null),
      (this._env = null),
      (this._context = null),
      (this._id = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2],
      i = arguments[3]
    ;(this._pts = t), (this._start = e), (this._end = n), (this._context = i)
  }
  getLineSegment(t, e) {
    ;(e.p0 = this._pts[t]), (e.p1 = this._pts[t + 1])
  }
  computeSelect(t, e, n, i) {
    const s = this._pts[e],
      r = this._pts[n]
    if (n - e == 1) return i.select(this, e), null
    if (!t.intersects(s, r)) return null
    const o = Math.trunc((e + n) / 2)
    e < o && this.computeSelect(t, e, o, i), o < n && this.computeSelect(t, o, n, i)
  }
  getCoordinates() {
    const t = new Array(this._end - this._start + 1).fill(null)
    let e = 0
    for (let n = this._start; n <= this._end; n++) t[e++] = this._pts[n]
    return t
  }
  computeOverlaps() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.computeOverlaps(this._start, this._end, t, t._start, t._end, e)
    } else if (6 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5]
      if (e - t == 1 && s - i == 1) return r.overlap(this, t, n, i), null
      if (!this.overlaps(t, e, n, i, s)) return null
      const o = Math.trunc((t + e) / 2),
        a = Math.trunc((i + s) / 2)
      t < o &&
        (i < a && this.computeOverlaps(t, o, n, i, a, r),
        a < s && this.computeOverlaps(t, o, n, a, s, r)),
        o < e &&
          (i < a && this.computeOverlaps(o, e, n, i, a, r),
          a < s && this.computeOverlaps(o, e, n, a, s, r))
    }
  }
  setId(t) {
    this._id = t
  }
  select(t, e) {
    this.computeSelect(t, this._start, this._end, e)
  }
  getEnvelope() {
    if (null === this._env) {
      const t = this._pts[this._start],
        e = this._pts[this._end]
      this._env = new Xc(t, e)
    }
    return this._env
  }
  overlaps(t, e, n, i, s) {
    return Xc.intersects(this._pts[t], this._pts[e], n._pts[i], n._pts[s])
  }
  getEndIndex() {
    return this._end
  }
  getStartIndex() {
    return this._start
  }
  getContext() {
    return this._context
  }
  getId() {
    return this._id
  }
}
class Gg {
  static findChainEnd(t, e) {
    let n = e
    for (; n < t.length - 1 && t[n].equals2D(t[n + 1]); ) n++
    if (n >= t.length - 1) return t.length - 1
    const i = Rp.quadrant(t[n], t[n + 1])
    let s = e + 1
    for (; s < t.length; ) {
      if (!t[s - 1].equals2D(t[s])) {
        if (Rp.quadrant(t[s - 1], t[s]) !== i) break
      }
      s++
    }
    return s - 1
  }
  static getChains() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return Gg.getChains(t, null)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = new Yc()
      let i = 0
      do {
        const s = Gg.findChainEnd(t, i),
          r = new Fg(t, i, s, e)
        n.add(r), (i = s)
      } while (i < t.length - 1)
      return n
    }
  }
}
class zg {
  computeNodes(t) {}
  getNodedSubstrings() {}
}
class Bg {
  constructor() {
    Bg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._segInt = null), 0 === arguments.length));
    else if (1 === arguments.length) {
      const t = arguments[0]
      this.setSegmentIntersector(t)
    }
  }
  setSegmentIntersector(t) {
    this._segInt = t
  }
  get interfaces_() {
    return [zg]
  }
}
class Ug extends Bg {
  constructor() {
    super(), Ug.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._monoChains = new Yc()),
      (this._index = new Ag()),
      (this._idCounter = 0),
      (this._nodedSegStrings = null),
      (this._nOverlaps = 0),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      const t = arguments[0]
      Bg.constructor_.call(this, t)
    }
  }
  getMonotoneChains() {
    return this._monoChains
  }
  getNodedSubstrings() {
    return Dg.getNodedSubstrings(this._nodedSegStrings)
  }
  getIndex() {
    return this._index
  }
  add(t) {
    for (let e = Gg.getChains(t.getCoordinates(), t).iterator(); e.hasNext(); ) {
      const t = e.next()
      t.setId(this._idCounter++), this._index.insert(t.getEnvelope(), t), this._monoChains.add(t)
    }
  }
  computeNodes(t) {
    this._nodedSegStrings = t
    for (let e = t.iterator(); e.hasNext(); ) this.add(e.next())
    this.intersectChains()
  }
  intersectChains() {
    const t = new Vg(this._segInt)
    for (let e = this._monoChains.iterator(); e.hasNext(); ) {
      const n = e.next()
      for (let e = this._index.query(n.getEnvelope()).iterator(); e.hasNext(); ) {
        const i = e.next()
        if (
          (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++),
          this._segInt.isDone())
        )
          return null
      }
    }
  }
}
class Vg extends Og {
  constructor() {
    super(), Vg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._si = null
    const t = arguments[0]
    this._si = t
  }
  overlap() {
    if (4 !== arguments.length) return super.overlap.apply(this, arguments)
    {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3],
        i = arguments[0].getContext(),
        s = e.getContext()
      this._si.processIntersections(i, t, s, n)
    }
  }
}
Ug.SegmentOverlapAction = Vg
class Hg {
  constructor() {
    Hg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._noder = null),
      (this._scaleFactor = null),
      (this._offsetX = null),
      (this._offsetY = null),
      (this._isScaled = !1),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      Hg.constructor_.call(this, t, e, 0, 0)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._noder = t), (this._scaleFactor = e), (this._isScaled = !this.isIntegerPrecision())
    }
  }
  rescale() {
    if (Uc(arguments[0], Vc)) {
      for (let t = arguments[0].iterator(); t.hasNext(); ) {
        const e = t.next()
        this.rescale(e.getCoordinates())
      }
    } else if (arguments[0] instanceof Array) {
      const t = arguments[0]
      for (let e = 0; e < t.length; e++)
        (t[e].x = t[e].x / this._scaleFactor + this._offsetX),
          (t[e].y = t[e].y / this._scaleFactor + this._offsetY)
      2 === t.length && t[0].equals2D(t[1]) && su.out.println(t)
    }
  }
  scale() {
    if (Uc(arguments[0], Vc)) {
      const t = arguments[0],
        e = new Yc(t.size())
      for (let n = t.iterator(); n.hasNext(); ) {
        const t = n.next()
        e.add(new Dg(this.scale(t.getCoordinates()), t.getData()))
      }
      return e
    }
    if (arguments[0] instanceof Array) {
      const t = arguments[0],
        e = new Array(t.length).fill(null)
      for (let n = 0; n < t.length; n++)
        e[n] = new Oc(
          Math.round((t[n].x - this._offsetX) * this._scaleFactor),
          Math.round((t[n].y - this._offsetY) * this._scaleFactor),
          t[n].getZ()
        )
      return Cu.removeRepeatedPoints(e)
    }
  }
  isIntegerPrecision() {
    return 1 === this._scaleFactor
  }
  getNodedSubstrings() {
    const t = this._noder.getNodedSubstrings()
    return this._isScaled && this.rescale(t), t
  }
  computeNodes(t) {
    let e = t
    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e)
  }
  get interfaces_() {
    return [zg]
  }
}
class kg {
  constructor() {
    kg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._geom = null),
      (this._geomFact = null),
      (this._bnRule = null),
      (this._endpointMap = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      kg.constructor_.call(this, t, wp.MOD2_BOUNDARY_RULE)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._geom = t), (this._geomFact = t.getFactory()), (this._bnRule = e)
    }
  }
  static getBoundary() {
    if (1 === arguments.length) {
      return new kg(arguments[0]).getBoundary()
    }
    if (2 === arguments.length) {
      return new kg(arguments[0], arguments[1]).getBoundary()
    }
  }
  boundaryMultiLineString(t) {
    if (this._geom.isEmpty()) return this.getEmptyMultiPoint()
    const e = this.computeBoundaryCoordinates(t)
    return 1 === e.length
      ? this._geomFact.createPoint(e[0])
      : this._geomFact.createMultiPointFromCoords(e)
  }
  getBoundary() {
    return this._geom instanceof mu
      ? this.boundaryLineString(this._geom)
      : this._geom instanceof Hu
        ? this.boundaryMultiLineString(this._geom)
        : this._geom.getBoundary()
  }
  boundaryLineString(t) {
    if (this._geom.isEmpty()) return this.getEmptyMultiPoint()
    if (t.isClosed()) {
      return this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint()
    }
    return this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
  }
  getEmptyMultiPoint() {
    return this._geomFact.createMultiPoint()
  }
  computeBoundaryCoordinates(t) {
    const e = new Yc()
    this._endpointMap = new Wp()
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const n = t.getGeometryN(e)
      0 !== n.getNumPoints() &&
        (this.addEndpoint(n.getCoordinateN(0)),
        this.addEndpoint(n.getCoordinateN(n.getNumPoints() - 1)))
    }
    for (let t = this._endpointMap.entrySet().iterator(); t.hasNext(); ) {
      const n = t.next(),
        i = n.getValue().count
      this._bnRule.isInBoundary(i) && e.add(n.getKey())
    }
    return Cu.toCoordinateArray(e)
  }
  addEndpoint(t) {
    let e = this._endpointMap.get(t)
    null === e && ((e = new Wg()), this._endpointMap.put(t, e)), e.count++
  }
}
class Wg {
  constructor() {
    Wg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.count = null
  }
}
class Yg {
  constructor() {
    Yg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._inputGeom = null),
      (this._isClosedEndpointsInInterior = !0),
      (this._nonSimpleLocation = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      this._inputGeom = t
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._inputGeom = t), (this._isClosedEndpointsInInterior = !e.isInBoundary(2))
    }
  }
  static isSimple() {
    if (1 === arguments.length) {
      return new Yg(arguments[0]).isSimple()
    }
    if (2 === arguments.length) {
      return new Yg(arguments[0], arguments[1]).isSimple()
    }
  }
  isSimpleMultiPoint(t) {
    if (t.isEmpty()) return !0
    const e = new Su()
    for (let n = 0; n < t.getNumGeometries(); n++) {
      const i = t.getGeometryN(n).getCoordinate()
      if (e.contains(i)) return (this._nonSimpleLocation = i), !1
      e.add(i)
    }
    return !0
  }
  isSimplePolygonal(t) {
    for (let e = Dd.getLines(t).iterator(); e.hasNext(); ) {
      const t = e.next()
      if (!this.isSimpleLinearGeometry(t)) return !1
    }
    return !0
  }
  hasClosedEndpointIntersection(t) {
    const e = new Wp()
    for (let n = t.getEdgeIterator(); n.hasNext(); ) {
      const t = n.next(),
        i = t.isClosed(),
        s = t.getCoordinate(0)
      this.addEndpoint(e, s, i)
      const r = t.getCoordinate(t.getNumPoints() - 1)
      this.addEndpoint(e, r, i)
    }
    for (let t = e.values().iterator(); t.hasNext(); ) {
      const e = t.next()
      if (e.isClosed && 2 !== e.degree) return (this._nonSimpleLocation = e.getCoordinate()), !0
    }
    return !1
  }
  getNonSimpleLocation() {
    return this._nonSimpleLocation
  }
  isSimpleLinearGeometry(t) {
    if (t.isEmpty()) return !0
    const e = new rg(0, t),
      n = new ud(),
      i = e.computeSelfNodes(n, !0)
    return (
      !i.hasIntersection() ||
      (i.hasProperIntersection()
        ? ((this._nonSimpleLocation = i.getProperIntersectionPoint()), !1)
        : !this.hasNonEndpointIntersection(e) &&
          (!this._isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)))
    )
  }
  hasNonEndpointIntersection(t) {
    for (let e = t.getEdgeIterator(); e.hasNext(); ) {
      const t = e.next(),
        n = t.getMaximumSegmentIndex()
      for (let e = t.getEdgeIntersectionList().iterator(); e.hasNext(); ) {
        const t = e.next()
        if (!t.isEndPoint(n)) return (this._nonSimpleLocation = t.getCoordinate()), !0
      }
    }
    return !1
  }
  addEndpoint(t, e, n) {
    let i = t.get(e)
    null === i && ((i = new jg(e)), t.put(e, i)), i.addEndpoint(n)
  }
  computeSimple(t) {
    return (
      (this._nonSimpleLocation = null),
      !!t.isEmpty() ||
        (t instanceof mu || t instanceof Hu
          ? this.isSimpleLinearGeometry(t)
          : t instanceof Iu
            ? this.isSimpleMultiPoint(t)
            : Uc(t, wu)
              ? this.isSimplePolygonal(t)
              : !(t instanceof Tu) || this.isSimpleGeometryCollection(t))
    )
  }
  isSimple() {
    return (this._nonSimpleLocation = null), this.computeSimple(this._inputGeom)
  }
  isSimpleGeometryCollection(t) {
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const n = t.getGeometryN(e)
      if (!this.computeSimple(n)) return !1
    }
    return !0
  }
}
class jg {
  constructor() {
    jg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.pt = null), (this.isClosed = null), (this.degree = null)
    const t = arguments[0]
    ;(this.pt = t), (this.isClosed = !1), (this.degree = 0)
  }
  addEndpoint(t) {
    this.degree++, (this.isClosed |= t)
  }
  getCoordinate() {
    return this.pt
  }
}
Yg.EndpointInfo = jg
class qg {
  constructor() {
    qg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._quadrantSegments = qg.DEFAULT_QUADRANT_SEGMENTS),
      (this._endCapStyle = qg.CAP_ROUND),
      (this._joinStyle = qg.JOIN_ROUND),
      (this._mitreLimit = qg.DEFAULT_MITRE_LIMIT),
      (this._isSingleSided = !1),
      (this._simplifyFactor = qg.DEFAULT_SIMPLIFY_FACTOR),
      0 === arguments.length)
    );
    else if (1 === arguments.length) {
      const t = arguments[0]
      this.setQuadrantSegments(t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.setQuadrantSegments(t), this.setEndCapStyle(e)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      this.setQuadrantSegments(t),
        this.setEndCapStyle(e),
        this.setJoinStyle(n),
        this.setMitreLimit(i)
    }
  }
  static bufferDistanceError(t) {
    const e = Math.PI / 2 / t
    return 1 - Math.cos(e / 2)
  }
  getEndCapStyle() {
    return this._endCapStyle
  }
  isSingleSided() {
    return this._isSingleSided
  }
  setQuadrantSegments(t) {
    ;(this._quadrantSegments = t),
      0 === this._quadrantSegments && (this._joinStyle = qg.JOIN_BEVEL),
      this._quadrantSegments < 0 &&
        ((this._joinStyle = qg.JOIN_MITRE), (this._mitreLimit = Math.abs(this._quadrantSegments))),
      t <= 0 && (this._quadrantSegments = 1),
      this._joinStyle !== qg.JOIN_ROUND && (this._quadrantSegments = qg.DEFAULT_QUADRANT_SEGMENTS)
  }
  getJoinStyle() {
    return this._joinStyle
  }
  setJoinStyle(t) {
    this._joinStyle = t
  }
  setSimplifyFactor(t) {
    this._simplifyFactor = t < 0 ? 0 : t
  }
  getSimplifyFactor() {
    return this._simplifyFactor
  }
  getQuadrantSegments() {
    return this._quadrantSegments
  }
  setEndCapStyle(t) {
    this._endCapStyle = t
  }
  getMitreLimit() {
    return this._mitreLimit
  }
  setMitreLimit(t) {
    this._mitreLimit = t
  }
  setSingleSided(t) {
    this._isSingleSided = t
  }
}
;(qg.CAP_ROUND = 1),
  (qg.CAP_FLAT = 2),
  (qg.CAP_SQUARE = 3),
  (qg.JOIN_ROUND = 1),
  (qg.JOIN_MITRE = 2),
  (qg.JOIN_BEVEL = 3),
  (qg.DEFAULT_QUADRANT_SEGMENTS = 8),
  (qg.DEFAULT_MITRE_LIMIT = 5),
  (qg.DEFAULT_SIMPLIFY_FACTOR = 0.01)
class Zg {
  constructor() {
    Zg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._minIndex = -1), (this._minCoord = null), (this._minDe = null), (this._orientedDe = null)
  }
  getCoordinate() {
    return this._minCoord
  }
  getRightmostSide(t, e) {
    let n = this.getRightmostSideOfSegment(t, e)
    return (
      n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)),
      n < 0 && ((this._minCoord = null), this.checkForRightmostCoordinate(t)),
      n
    )
  }
  findRightmostEdgeAtVertex() {
    const t = this._minDe.getEdge().getCoordinates()
    Cc.isTrue(
      this._minIndex > 0 && this._minIndex < t.length,
      'rightmost point expected to be interior vertex of edge'
    )
    const e = t[this._minIndex - 1],
      n = t[this._minIndex + 1],
      i = nu.index(this._minCoord, n, e)
    let s = !1
    ;((e.y < this._minCoord.y && n.y < this._minCoord.y && i === nu.COUNTERCLOCKWISE) ||
      (e.y > this._minCoord.y && n.y > this._minCoord.y && i === nu.CLOCKWISE)) &&
      (s = !0),
      s && (this._minIndex = this._minIndex - 1)
  }
  getRightmostSideOfSegment(t, e) {
    const n = t.getEdge().getCoordinates()
    if (e < 0 || e + 1 >= n.length) return -1
    if (n[e].y === n[e + 1].y) return -1
    let i = Lp.LEFT
    return n[e].y < n[e + 1].y && (i = Lp.RIGHT), i
  }
  getEdge() {
    return this._orientedDe
  }
  checkForRightmostCoordinate(t) {
    const e = t.getEdge().getCoordinates()
    for (let n = 0; n < e.length - 1; n++)
      (null === this._minCoord || e[n].x > this._minCoord.x) &&
        ((this._minDe = t), (this._minIndex = n), (this._minCoord = e[n]))
  }
  findRightmostEdgeAtNode() {
    const t = this._minDe.getNode().getEdges()
    ;(this._minDe = t.getRightmostEdge()),
      this._minDe.isForward() ||
        ((this._minDe = this._minDe.getSym()),
        (this._minIndex = this._minDe.getEdge().getCoordinates().length - 1))
  }
  findEdge(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      t.isForward() && this.checkForRightmostCoordinate(t)
    }
    Cc.isTrue(
      0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()),
      'inconsistency in rightmost processing'
    ),
      0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(),
      (this._orientedDe = this._minDe)
    this.getRightmostSide(this._minDe, this._minIndex) === Lp.LEFT &&
      (this._orientedDe = this._minDe.getSym())
  }
}
class Xg {
  constructor() {
    this.array = []
  }
  addLast(t) {
    this.array.push(t)
  }
  removeFirst() {
    return this.array.shift()
  }
  isEmpty() {
    return 0 === this.array.length
  }
}
class Kg {
  constructor() {
    Kg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._finder = null),
      (this._dirEdgeList = new Yc()),
      (this._nodes = new Yc()),
      (this._rightMostCoord = null),
      (this._env = null),
      (this._finder = new Zg())
  }
  clearVisitedEdges() {
    for (let t = this._dirEdgeList.iterator(); t.hasNext(); ) {
      t.next().setVisited(!1)
    }
  }
  getRightmostCoordinate() {
    return this._rightMostCoord
  }
  computeNodeDepth(t) {
    let e = null
    for (let n = t.getEdges().iterator(); n.hasNext(); ) {
      const t = n.next()
      if (t.isVisited() || t.getSym().isVisited()) {
        e = t
        break
      }
    }
    if (null === e) throw new eg('unable to find edge to compute depths at ' + t.getCoordinate())
    t.getEdges().computeDepths(e)
    for (let e = t.getEdges().iterator(); e.hasNext(); ) {
      const t = e.next()
      t.setVisited(!0), this.copySymDepths(t)
    }
  }
  computeDepth(t) {
    this.clearVisitedEdges()
    const e = this._finder.getEdge()
    e.getNode(),
      e.getLabel(),
      e.setEdgeDepths(Lp.RIGHT, t),
      this.copySymDepths(e),
      this.computeDepths(e)
  }
  create(t) {
    this.addReachable(t),
      this._finder.findEdge(this._dirEdgeList),
      (this._rightMostCoord = this._finder.getCoordinate())
  }
  findResultEdges() {
    for (let t = this._dirEdgeList.iterator(); t.hasNext(); ) {
      const e = t.next()
      e.getDepth(Lp.RIGHT) >= 1 &&
        e.getDepth(Lp.LEFT) <= 0 &&
        !e.isInteriorAreaEdge() &&
        e.setInResult(!0)
    }
  }
  computeDepths(t) {
    const e = new Gu(),
      n = new Xg(),
      i = t.getNode()
    for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty(); ) {
      const t = n.removeFirst()
      e.add(t), this.computeNodeDepth(t)
      for (let i = t.getEdges().iterator(); i.hasNext(); ) {
        const t = i.next().getSym()
        if (t.isVisited()) continue
        const s = t.getNode()
        e.contains(s) || (n.addLast(s), e.add(s))
      }
    }
  }
  compareTo(t) {
    const e = t
    return this._rightMostCoord.x < e._rightMostCoord.x
      ? -1
      : this._rightMostCoord.x > e._rightMostCoord.x
        ? 1
        : 0
  }
  getEnvelope() {
    if (null === this._env) {
      const t = new Xc()
      for (let e = this._dirEdgeList.iterator(); e.hasNext(); ) {
        const n = e.next().getEdge().getCoordinates()
        for (let e = 0; e < n.length - 1; e++) t.expandToInclude(n[e])
      }
      this._env = t
    }
    return this._env
  }
  addReachable(t) {
    const e = new pp()
    for (e.add(t); !e.empty(); ) {
      const t = e.pop()
      this.add(t, e)
    }
  }
  copySymDepths(t) {
    const e = t.getSym()
    e.setDepth(Lp.LEFT, t.getDepth(Lp.RIGHT)), e.setDepth(Lp.RIGHT, t.getDepth(Lp.LEFT))
  }
  add(t, e) {
    t.setVisited(!0), this._nodes.add(t)
    for (let n = t.getEdges().iterator(); n.hasNext(); ) {
      const t = n.next()
      this._dirEdgeList.add(t)
      const i = t.getSym().getNode()
      i.isVisited() || e.push(i)
    }
  }
  getNodes() {
    return this._nodes
  }
  getDirectedEdges() {
    return this._dirEdgeList
  }
  get interfaces_() {
    return [Sc]
  }
}
class Jg {
  constructor() {
    Jg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._startDe = null),
      (this._maxNodeDegree = -1),
      (this._edges = new Yc()),
      (this._pts = new Yc()),
      (this._label = new Fp(pd.NONE)),
      (this._ring = null),
      (this._isHole = null),
      (this._shell = null),
      (this._holes = new Yc()),
      (this._geometryFactory = null),
      0 === arguments.length)
    );
    else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._geometryFactory = e), this.computePoints(t), this.computeRing()
    }
  }
  computeRing() {
    if (null !== this._ring) return null
    const t = new Array(this._pts.size()).fill(null)
    for (let e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e)
    ;(this._ring = this._geometryFactory.createLinearRing(t)),
      (this._isHole = nu.isCCW(this._ring.getCoordinates()))
  }
  isIsolated() {
    return 1 === this._label.getGeometryCount()
  }
  computePoints(t) {
    this._startDe = t
    let e = t,
      n = !0
    do {
      if (null === e) throw new eg('Found null DirectedEdge')
      if (e.getEdgeRing() === this)
        throw new eg('Directed Edge visited twice during ring-building at ' + e.getCoordinate())
      this._edges.add(e)
      const t = e.getLabel()
      Cc.isTrue(t.isArea()),
        this.mergeLabel(t),
        this.addPoints(e.getEdge(), e.isForward(), n),
        (n = !1),
        this.setEdgeRing(e, this),
        (e = this.getNext(e))
    } while (e !== this._startDe)
  }
  getLinearRing() {
    return this._ring
  }
  getCoordinate(t) {
    return this._pts.get(t)
  }
  computeMaxNodeDegree() {
    this._maxNodeDegree = 0
    let t = this._startDe
    do {
      const e = t.getNode().getEdges().getOutgoingDegree(this)
      e > this._maxNodeDegree && (this._maxNodeDegree = e), (t = this.getNext(t))
    } while (t !== this._startDe)
    this._maxNodeDegree *= 2
  }
  addPoints(t, e, n) {
    const i = t.getCoordinates()
    if (e) {
      let t = 1
      n && (t = 0)
      for (let e = t; e < i.length; e++) this._pts.add(i[e])
    } else {
      let t = i.length - 2
      n && (t = i.length - 1)
      for (let e = t; e >= 0; e--) this._pts.add(i[e])
    }
  }
  isHole() {
    return this._isHole
  }
  setInResult() {
    let t = this._startDe
    do {
      t.getEdge().setInResult(!0), (t = t.getNext())
    } while (t !== this._startDe)
  }
  containsPoint(t) {
    const e = this.getLinearRing()
    if (!e.getEnvelopeInternal().contains(t)) return !1
    if (!op.isInRing(t, e.getCoordinates())) return !1
    for (let e = this._holes.iterator(); e.hasNext(); ) {
      if (e.next().containsPoint(t)) return !1
    }
    return !0
  }
  addHole(t) {
    this._holes.add(t)
  }
  isShell() {
    return null === this._shell
  }
  getLabel() {
    return this._label
  }
  getEdges() {
    return this._edges
  }
  getMaxNodeDegree() {
    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
  }
  getShell() {
    return this._shell
  }
  mergeLabel() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.mergeLabel(t, 0), this.mergeLabel(t, 1)
    } else if (2 === arguments.length) {
      const t = arguments[1],
        e = arguments[0].getLocation(t, Lp.RIGHT)
      if (e === pd.NONE) return null
      if (this._label.getLocation(t) === pd.NONE) return this._label.setLocation(t, e), null
    }
  }
  setShell(t) {
    ;(this._shell = t), null !== t && t.addHole(this)
  }
  toPolygon(t) {
    const e = new Array(this._holes.size()).fill(null)
    for (let t = 0; t < this._holes.size(); t++) e[t] = this._holes.get(t).getLinearRing()
    return t.createPolygon(this.getLinearRing(), e)
  }
}
class Qg extends Jg {
  constructor() {
    super(), Qg.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Jg.constructor_.call(this, t, e)
  }
  setEdgeRing(t, e) {
    t.setMinEdgeRing(e)
  }
  getNext(t) {
    return t.getNextMin()
  }
}
class $g extends Jg {
  constructor() {
    super(), $g.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Jg.constructor_.call(this, t, e)
  }
  buildMinimalRings() {
    const t = new Yc()
    let e = this._startDe
    do {
      if (null === e.getMinEdgeRing()) {
        const n = new Qg(e, this._geometryFactory)
        t.add(n)
      }
      e = e.getNext()
    } while (e !== this._startDe)
    return t
  }
  setEdgeRing(t, e) {
    t.setEdgeRing(e)
  }
  linkDirectedEdgesForMinimalEdgeRings() {
    let t = this._startDe
    do {
      t.getNode().getEdges().linkMinimalDirectedEdges(this), (t = t.getNext())
    } while (t !== this._startDe)
  }
  getNext(t) {
    return t.getNext()
  }
}
class tf {
  constructor() {
    tf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geometryFactory = null), (this._shellList = new Yc())
    const t = arguments[0]
    this._geometryFactory = t
  }
  static findEdgeRingContaining(t, e) {
    const n = t.getLinearRing(),
      i = n.getEnvelopeInternal()
    let s = n.getCoordinateN(0),
      r = null,
      o = null
    for (let t = e.iterator(); t.hasNext(); ) {
      const e = t.next(),
        a = e.getLinearRing(),
        l = a.getEnvelopeInternal()
      if (l.equals(i)) continue
      if (!l.contains(i)) continue
      s = Cu.ptNotInList(n.getCoordinates(), a.getCoordinates())
      let h = !1
      op.isInRing(s, a.getCoordinates()) && (h = !0),
        h &&
          (null === r || o.contains(l)) &&
          ((r = e), (o = r.getLinearRing().getEnvelopeInternal()))
    }
    return r
  }
  sortShellsAndHoles(t, e, n) {
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      t.isHole() ? n.add(t) : e.add(t)
    }
  }
  computePolygons(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next().toPolygon(this._geometryFactory)
      e.add(t)
    }
    return e
  }
  placeFreeHoles(t, e) {
    for (let n = e.iterator(); n.hasNext(); ) {
      const e = n.next()
      if (null === e.getShell()) {
        const n = tf.findEdgeRingContaining(e, t)
        if (null === n) throw new eg('unable to assign hole to a shell', e.getCoordinate(0))
        e.setShell(n)
      }
    }
  }
  buildMinimalEdgeRings(t, e, n) {
    const i = new Yc()
    for (let s = t.iterator(); s.hasNext(); ) {
      const t = s.next()
      if (t.getMaxNodeDegree() > 2) {
        t.linkDirectedEdgesForMinimalEdgeRings()
        const i = t.buildMinimalRings(),
          s = this.findShell(i)
        null !== s ? (this.placePolygonHoles(s, i), e.add(s)) : n.addAll(i)
      } else i.add(t)
    }
    return i
  }
  buildMaximalEdgeRings(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      if (t.isInResult() && t.getLabel().isArea() && null === t.getEdgeRing()) {
        const n = new $g(t, this._geometryFactory)
        e.add(n), n.setInResult()
      }
    }
    return e
  }
  placePolygonHoles(t, e) {
    for (let n = e.iterator(); n.hasNext(); ) {
      const e = n.next()
      e.isHole() && e.setShell(t)
    }
  }
  getPolygons() {
    return this.computePolygons(this._shellList)
  }
  findShell(t) {
    let e = 0,
      n = null
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      t.isHole() || ((n = t), e++)
    }
    return Cc.isTrue(e <= 1, 'found two shells in MinimalEdgeRing list'), n
  }
  add() {
    if (1 === arguments.length) {
      const t = arguments[0]
      this.add(t.getEdgeEnds(), t.getNodes())
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      sg.linkResultDirectedEdges(e)
      const n = this.buildMaximalEdgeRings(t),
        i = new Yc(),
        s = this.buildMinimalEdgeRings(n, this._shellList, i)
      this.sortShellsAndHoles(s, this._shellList, i), this.placeFreeHoles(this._shellList, i)
    }
  }
}
class ef {
  constructor() {
    ef.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputLine = null),
      (this._distanceTol = null),
      (this._isDeleted = null),
      (this._angleOrientation = nu.COUNTERCLOCKWISE)
    const t = arguments[0]
    this._inputLine = t
  }
  static simplify(t, e) {
    return new ef(t).simplify(e)
  }
  isDeletable(t, e, n, i) {
    const s = this._inputLine[t],
      r = this._inputLine[e],
      o = this._inputLine[n]
    return (
      !!this.isConcave(s, r, o) &&
      !!this.isShallow(s, r, o, i) &&
      this.isShallowSampled(s, r, t, n, i)
    )
  }
  deleteShallowConcavities() {
    let t = 1,
      e = this.findNextNonDeletedIndex(t),
      n = this.findNextNonDeletedIndex(e),
      i = !1
    for (; n < this._inputLine.length; ) {
      let s = !1
      this.isDeletable(t, e, n, this._distanceTol) &&
        ((this._isDeleted[e] = ef.DELETE), (s = !0), (i = !0)),
        (t = s ? n : e),
        (e = this.findNextNonDeletedIndex(t)),
        (n = this.findNextNonDeletedIndex(e))
    }
    return i
  }
  isShallowConcavity(t, e, n, i) {
    if (!(nu.index(t, e, n) === this._angleOrientation)) return !1
    return ou.pointToSegment(e, t, n) < i
  }
  isShallowSampled(t, e, n, i, s) {
    let r = Math.trunc((i - n) / ef.NUM_PTS_TO_CHECK)
    r <= 0 && (r = 1)
    for (let o = n; o < i; o += r) if (!this.isShallow(t, e, this._inputLine[o], s)) return !1
    return !0
  }
  isConcave(t, e, n) {
    return nu.index(t, e, n) === this._angleOrientation
  }
  simplify(t) {
    ;(this._distanceTol = Math.abs(t)),
      t < 0 && (this._angleOrientation = nu.CLOCKWISE),
      (this._isDeleted = new Array(this._inputLine.length).fill(null))
    let e = !1
    do {
      e = this.deleteShallowConcavities()
    } while (e)
    return this.collapseLine()
  }
  findNextNonDeletedIndex(t) {
    let e = t + 1
    for (; e < this._inputLine.length && this._isDeleted[e] === ef.DELETE; ) e++
    return e
  }
  isShallow(t, e, n, i) {
    return ou.pointToSegment(e, t, n) < i
  }
  collapseLine() {
    const t = new qc()
    for (let e = 0; e < this._inputLine.length; e++)
      this._isDeleted[e] !== ef.DELETE && t.add(this._inputLine[e])
    return t.toCoordinateArray()
  }
}
;(ef.INIT = 0), (ef.DELETE = 1), (ef.KEEP = 1), (ef.NUM_PTS_TO_CHECK = 10)
class nf {
  constructor() {
    nf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._ptList = null),
      (this._precisionModel = null),
      (this._minimimVertexDistance = 0),
      (this._ptList = new Yc())
  }
  getCoordinates() {
    return this._ptList.toArray(nf.COORDINATE_ARRAY_TYPE)
  }
  setPrecisionModel(t) {
    this._precisionModel = t
  }
  addPt(t) {
    const e = new Oc(t)
    if ((this._precisionModel.makePrecise(e), this.isRedundant(e))) return null
    this._ptList.add(e)
  }
  reverse() {}
  addPts(t, e) {
    if (e) for (let e = 0; e < t.length; e++) this.addPt(t[e])
    else for (let e = t.length - 1; e >= 0; e--) this.addPt(t[e])
  }
  isRedundant(t) {
    if (this._ptList.size() < 1) return !1
    const e = this._ptList.get(this._ptList.size() - 1)
    return t.distance(e) < this._minimimVertexDistance
  }
  toString() {
    return new ku().createLineString(this.getCoordinates()).toString()
  }
  closeRing() {
    if (this._ptList.size() < 1) return null
    const t = new Oc(this._ptList.get(0)),
      e = this._ptList.get(this._ptList.size() - 1)
    if (t.equals(e)) return null
    this._ptList.add(t)
  }
  setMinimumVertexDistance(t) {
    this._minimimVertexDistance = t
  }
}
nf.COORDINATE_ARRAY_TYPE = new Array(0).fill(null)
class sf {
  constructor() {
    sf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._maxCurveSegmentError = 0),
      (this._filletAngleQuantum = null),
      (this._closingSegLengthFactor = 1),
      (this._segList = null),
      (this._distance = 0),
      (this._precisionModel = null),
      (this._bufParams = null),
      (this._li = null),
      (this._s0 = null),
      (this._s1 = null),
      (this._s2 = null),
      (this._seg0 = new dd()),
      (this._seg1 = new dd()),
      (this._offset0 = new dd()),
      (this._offset1 = new dd()),
      (this._side = 0),
      (this._hasNarrowConcaveAngle = !1)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._precisionModel = t),
      (this._bufParams = e),
      (this._li = new ud()),
      (this._filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments()),
      e.getQuadrantSegments() >= 8 &&
        e.getJoinStyle() === qg.JOIN_ROUND &&
        (this._closingSegLengthFactor = sf.MAX_CLOSING_SEG_LEN_FACTOR),
      this.init(n)
  }
  addNextSegment(t, e) {
    if (
      ((this._s0 = this._s1),
      (this._s1 = this._s2),
      (this._s2 = t),
      this._seg0.setCoordinates(this._s0, this._s1),
      this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0),
      this._seg1.setCoordinates(this._s1, this._s2),
      this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1),
      this._s1.equals(this._s2))
    )
      return null
    const n = nu.index(this._s0, this._s1, this._s2),
      i =
        (n === nu.CLOCKWISE && this._side === Lp.LEFT) ||
        (n === nu.COUNTERCLOCKWISE && this._side === Lp.RIGHT)
    0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
  }
  addLineEndCap(t, e) {
    const n = new dd(t, e),
      i = new dd()
    this.computeOffsetSegment(n, Lp.LEFT, this._distance, i)
    const s = new dd()
    this.computeOffsetSegment(n, Lp.RIGHT, this._distance, s)
    const r = e.x - t.x,
      o = e.y - t.y,
      a = Math.atan2(o, r)
    switch (this._bufParams.getEndCapStyle()) {
      case qg.CAP_ROUND:
        this._segList.addPt(i.p1),
          this.addDirectedFillet(e, a + Math.PI / 2, a - Math.PI / 2, nu.CLOCKWISE, this._distance),
          this._segList.addPt(s.p1)
        break
      case qg.CAP_FLAT:
        this._segList.addPt(i.p1), this._segList.addPt(s.p1)
        break
      case qg.CAP_SQUARE:
        const t = new Oc()
        ;(t.x = Math.abs(this._distance) * Math.cos(a)),
          (t.y = Math.abs(this._distance) * Math.sin(a))
        const n = new Oc(i.p1.x + t.x, i.p1.y + t.y),
          r = new Oc(s.p1.x + t.x, s.p1.y + t.y)
        this._segList.addPt(n), this._segList.addPt(r)
    }
  }
  getCoordinates() {
    return this._segList.getCoordinates()
  }
  addMitreJoin(t, e, n, i) {
    const s = iu.intersection(e.p0, e.p1, n.p0, n.p1)
    if (null !== s) {
      if ((i <= 0 ? 1 : s.distance(t) / Math.abs(i)) <= this._bufParams.getMitreLimit())
        return this._segList.addPt(s), null
    }
    this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit())
  }
  addOutsideTurn(t, e) {
    if (
      this._offset0.p1.distance(this._offset1.p0) <
      this._distance * sf.OFFSET_SEGMENT_SEPARATION_FACTOR
    )
      return this._segList.addPt(this._offset0.p1), null
    this._bufParams.getJoinStyle() === qg.JOIN_MITRE
      ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance)
      : this._bufParams.getJoinStyle() === qg.JOIN_BEVEL
        ? this.addBevelJoin(this._offset0, this._offset1)
        : (e && this._segList.addPt(this._offset0.p1),
          this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance),
          this._segList.addPt(this._offset1.p0))
  }
  createSquare(t) {
    this._segList.addPt(new Oc(t.x + this._distance, t.y + this._distance)),
      this._segList.addPt(new Oc(t.x + this._distance, t.y - this._distance)),
      this._segList.addPt(new Oc(t.x - this._distance, t.y - this._distance)),
      this._segList.addPt(new Oc(t.x - this._distance, t.y + this._distance)),
      this._segList.closeRing()
  }
  addSegments(t, e) {
    this._segList.addPts(t, e)
  }
  addFirstSegment() {
    this._segList.addPt(this._offset1.p0)
  }
  addCornerFillet(t, e, n, i, s) {
    const r = e.x - t.x,
      o = e.y - t.y
    let a = Math.atan2(o, r)
    const l = n.x - t.x,
      h = n.y - t.y,
      c = Math.atan2(h, l)
    i === nu.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI),
      this._segList.addPt(e),
      this.addDirectedFillet(t, a, c, i, s),
      this._segList.addPt(n)
  }
  addLastSegment() {
    this._segList.addPt(this._offset1.p1)
  }
  initSideSegments(t, e, n) {
    ;(this._s1 = t),
      (this._s2 = e),
      (this._side = n),
      this._seg1.setCoordinates(t, e),
      this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
  }
  addLimitedMitreJoin(t, e, n, i) {
    const s = this._seg0.p1,
      r = fd.angle(s, this._seg0.p0),
      o = fd.angleBetweenOriented(this._seg0.p0, s, this._seg1.p1) / 2,
      a = fd.normalize(r + o),
      l = fd.normalize(a + Math.PI),
      h = i * n,
      c = n - h * Math.abs(Math.sin(o)),
      u = s.x + h * Math.cos(l),
      d = s.y + h * Math.sin(l),
      p = new Oc(u, d),
      g = new dd(s, p),
      f = g.pointAlongOffset(1, c),
      m = g.pointAlongOffset(1, -c)
    this._side === Lp.LEFT
      ? (this._segList.addPt(f), this._segList.addPt(m))
      : (this._segList.addPt(m), this._segList.addPt(f))
  }
  addDirectedFillet(t, e, n, i, s) {
    const r = i === nu.CLOCKWISE ? -1 : 1,
      o = Math.abs(e - n),
      a = Math.trunc(o / this._filletAngleQuantum + 0.5)
    if (a < 1) return null
    const l = o / a,
      h = new Oc()
    for (let n = 0; n < a; n++) {
      const i = e + r * n * l
      ;(h.x = t.x + s * Math.cos(i)), (h.y = t.y + s * Math.sin(i)), this._segList.addPt(h)
    }
  }
  computeOffsetSegment(t, e, n, i) {
    const s = e === Lp.LEFT ? 1 : -1,
      r = t.p1.x - t.p0.x,
      o = t.p1.y - t.p0.y,
      a = Math.sqrt(r * r + o * o),
      l = (s * n * r) / a,
      h = (s * n * o) / a
    ;(i.p0.x = t.p0.x - h), (i.p0.y = t.p0.y + l), (i.p1.x = t.p1.x - h), (i.p1.y = t.p1.y + l)
  }
  addInsideTurn(t, e) {
    if (
      (this._li.computeIntersection(
        this._offset0.p0,
        this._offset0.p1,
        this._offset1.p0,
        this._offset1.p1
      ),
      this._li.hasIntersection())
    )
      this._segList.addPt(this._li.getIntersection(0))
    else if (
      ((this._hasNarrowConcaveAngle = !0),
      this._offset0.p1.distance(this._offset1.p0) <
        this._distance * sf.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
    )
      this._segList.addPt(this._offset0.p1)
    else {
      if ((this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0)) {
        const t = new Oc(
          (this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) /
            (this._closingSegLengthFactor + 1),
          (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) /
            (this._closingSegLengthFactor + 1)
        )
        this._segList.addPt(t)
        const e = new Oc(
          (this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) /
            (this._closingSegLengthFactor + 1),
          (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) /
            (this._closingSegLengthFactor + 1)
        )
        this._segList.addPt(e)
      } else this._segList.addPt(this._s1)
      this._segList.addPt(this._offset1.p0)
    }
  }
  createCircle(t) {
    const e = new Oc(t.x + this._distance, t.y)
    this._segList.addPt(e),
      this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance),
      this._segList.closeRing()
  }
  addBevelJoin(t, e) {
    this._segList.addPt(t.p1), this._segList.addPt(e.p0)
  }
  init(t) {
    ;(this._distance = t),
      (this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2))),
      (this._segList = new nf()),
      this._segList.setPrecisionModel(this._precisionModel),
      this._segList.setMinimumVertexDistance(t * sf.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
  }
  addCollinear(t) {
    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2)
    this._li.getIntersectionNum() >= 2 &&
      (this._bufParams.getJoinStyle() === qg.JOIN_BEVEL ||
      this._bufParams.getJoinStyle() === qg.JOIN_MITRE
        ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0))
        : this.addCornerFillet(
            this._s1,
            this._offset0.p1,
            this._offset1.p0,
            nu.CLOCKWISE,
            this._distance
          ))
  }
  closeRing() {
    this._segList.closeRing()
  }
  hasNarrowConcaveAngle() {
    return this._hasNarrowConcaveAngle
  }
}
;(sf.OFFSET_SEGMENT_SEPARATION_FACTOR = 0.001),
  (sf.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 0.001),
  (sf.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6),
  (sf.MAX_CLOSING_SEG_LEN_FACTOR = 80)
class rf {
  constructor() {
    rf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._distance = 0), (this._precisionModel = null), (this._bufParams = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._precisionModel = t), (this._bufParams = e)
  }
  static copyCoordinates(t) {
    const e = new Array(t.length).fill(null)
    for (let n = 0; n < e.length; n++) e[n] = new Oc(t[n])
    return e
  }
  getOffsetCurve(t, e) {
    if (((this._distance = e), 0 === e)) return null
    const n = e < 0,
      i = Math.abs(e),
      s = this.getSegGen(i)
    t.length <= 1 ? this.computePointCurve(t[0], s) : this.computeOffsetCurve(t, n, s)
    const r = s.getCoordinates()
    return n && Cu.reverse(r), r
  }
  computeSingleSidedBufferCurve(t, e, n) {
    const i = this.simplifyTolerance(this._distance)
    if (e) {
      n.addSegments(t, !0)
      const e = ef.simplify(t, -i),
        s = e.length - 1
      n.initSideSegments(e[s], e[s - 1], Lp.LEFT), n.addFirstSegment()
      for (let t = s - 2; t >= 0; t--) n.addNextSegment(e[t], !0)
    } else {
      n.addSegments(t, !1)
      const e = ef.simplify(t, i),
        s = e.length - 1
      n.initSideSegments(e[0], e[1], Lp.LEFT), n.addFirstSegment()
      for (let t = 2; t <= s; t++) n.addNextSegment(e[t], !0)
    }
    n.addLastSegment(), n.closeRing()
  }
  computeRingBufferCurve(t, e, n) {
    let i = this.simplifyTolerance(this._distance)
    e === Lp.RIGHT && (i = -i)
    const s = ef.simplify(t, i),
      r = s.length - 1
    n.initSideSegments(s[r - 1], s[0], e)
    for (let t = 1; t <= r; t++) {
      const e = 1 !== t
      n.addNextSegment(s[t], e)
    }
    n.closeRing()
  }
  computeLineBufferCurve(t, e) {
    const n = this.simplifyTolerance(this._distance),
      i = ef.simplify(t, n),
      s = i.length - 1
    e.initSideSegments(i[0], i[1], Lp.LEFT)
    for (let t = 2; t <= s; t++) e.addNextSegment(i[t], !0)
    e.addLastSegment(), e.addLineEndCap(i[s - 1], i[s])
    const r = ef.simplify(t, -n),
      o = r.length - 1
    e.initSideSegments(r[o], r[o - 1], Lp.LEFT)
    for (let t = o - 2; t >= 0; t--) e.addNextSegment(r[t], !0)
    e.addLastSegment(), e.addLineEndCap(r[1], r[0]), e.closeRing()
  }
  computePointCurve(t, e) {
    switch (this._bufParams.getEndCapStyle()) {
      case qg.CAP_ROUND:
        e.createCircle(t)
        break
      case qg.CAP_SQUARE:
        e.createSquare(t)
    }
  }
  getLineCurve(t, e) {
    if (((this._distance = e), this.isLineOffsetEmpty(e))) return null
    const n = Math.abs(e),
      i = this.getSegGen(n)
    if (t.length <= 1) this.computePointCurve(t[0], i)
    else if (this._bufParams.isSingleSided()) {
      const n = e < 0
      this.computeSingleSidedBufferCurve(t, n, i)
    } else this.computeLineBufferCurve(t, i)
    return i.getCoordinates()
  }
  getBufferParameters() {
    return this._bufParams
  }
  simplifyTolerance(t) {
    return t * this._bufParams.getSimplifyFactor()
  }
  getRingCurve(t, e, n) {
    if (((this._distance = n), t.length <= 2)) return this.getLineCurve(t, n)
    if (0 === n) return rf.copyCoordinates(t)
    const i = this.getSegGen(n)
    return this.computeRingBufferCurve(t, e, i), i.getCoordinates()
  }
  computeOffsetCurve(t, e, n) {
    const i = this.simplifyTolerance(this._distance)
    if (e) {
      const e = ef.simplify(t, -i),
        s = e.length - 1
      n.initSideSegments(e[s], e[s - 1], Lp.LEFT), n.addFirstSegment()
      for (let t = s - 2; t >= 0; t--) n.addNextSegment(e[t], !0)
    } else {
      const e = ef.simplify(t, i),
        s = e.length - 1
      n.initSideSegments(e[0], e[1], Lp.LEFT), n.addFirstSegment()
      for (let t = 2; t <= s; t++) n.addNextSegment(e[t], !0)
    }
    n.addLastSegment()
  }
  isLineOffsetEmpty(t) {
    return 0 === t || (t < 0 && !this._bufParams.isSingleSided())
  }
  getSegGen(t) {
    return new sf(this._precisionModel, this._bufParams, t)
  }
}
class of {
  constructor() {
    of.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._subgraphs = null), (this._seg = new dd())
    const t = arguments[0]
    this._subgraphs = t
  }
  findStabbedSegments() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      for (let n = this._subgraphs.iterator(); n.hasNext(); ) {
        const i = n.next(),
          s = i.getEnvelope()
        t.y < s.getMinY() ||
          t.y > s.getMaxY() ||
          this.findStabbedSegments(t, i.getDirectedEdges(), e)
      }
      return e
    }
    if (3 === arguments.length)
      if (Uc(arguments[2], kc) && arguments[0] instanceof Oc && arguments[1] instanceof ng) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = e.getEdge().getCoordinates()
        for (let s = 0; s < i.length - 1; s++) {
          ;(this._seg.p0 = i[s]),
            (this._seg.p1 = i[s + 1]),
            this._seg.p0.y > this._seg.p1.y && this._seg.reverse()
          if (Math.max(this._seg.p0.x, this._seg.p1.x) < t.x) continue
          if (this._seg.isHorizontal()) continue
          if (t.y < this._seg.p0.y || t.y > this._seg.p1.y) continue
          if (nu.index(this._seg.p0, this._seg.p1, t) === nu.RIGHT) continue
          let r = e.getDepth(Lp.LEFT)
          this._seg.p0.equals(i[s]) || (r = e.getDepth(Lp.RIGHT))
          const o = new af(this._seg, r)
          n.add(o)
        }
      } else if (Uc(arguments[2], kc) && arguments[0] instanceof Oc && Uc(arguments[1], kc)) {
        const t = arguments[0],
          e = arguments[2]
        for (let n = arguments[1].iterator(); n.hasNext(); ) {
          const i = n.next()
          i.isForward() && this.findStabbedSegments(t, i, e)
        }
      }
  }
  getDepth(t) {
    const e = this.findStabbedSegments(t)
    if (0 === e.size()) return 0
    return Od.min(e)._leftDepth
  }
}
class af {
  constructor() {
    af.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._upwardSeg = null), (this._leftDepth = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._upwardSeg = new dd(t)), (this._leftDepth = e)
  }
  compareTo(t) {
    const e = t
    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1
    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1
    let n = this._upwardSeg.orientationIndex(e._upwardSeg)
    return 0 !== n
      ? n
      : ((n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)),
        0 !== n ? n : this._upwardSeg.compareTo(e._upwardSeg))
  }
  compareX(t, e) {
    const n = t.p0.compareTo(e.p0)
    return 0 !== n ? n : t.p1.compareTo(e.p1)
  }
  toString() {
    return this._upwardSeg.toString()
  }
  get interfaces_() {
    return [Sc]
  }
}
of.DepthSegment = af
class lf {
  constructor() {
    lf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null),
      (this._distance = null),
      (this._curveBuilder = null),
      (this._curveList = new Yc())
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._inputGeom = t), (this._distance = e), (this._curveBuilder = n)
  }
  addRingSide(t, e, n, i, s) {
    if (0 === e && t.length < Ru.MINIMUM_VALID_SIZE) return null
    let r = i,
      o = s
    t.length >= Ru.MINIMUM_VALID_SIZE && nu.isCCW(t) && ((r = s), (o = i), (n = Lp.opposite(n)))
    const a = this._curveBuilder.getRingCurve(t, n, e)
    this.addCurve(a, r, o)
  }
  addRingBothSides(t, e) {
    this.addRingSide(t, e, Lp.LEFT, pd.EXTERIOR, pd.INTERIOR),
      this.addRingSide(t, e, Lp.RIGHT, pd.INTERIOR, pd.EXTERIOR)
  }
  addPoint(t) {
    if (this._distance <= 0) return null
    const e = t.getCoordinates(),
      n = this._curveBuilder.getLineCurve(e, this._distance)
    this.addCurve(n, pd.EXTERIOR, pd.INTERIOR)
  }
  addPolygon(t) {
    let e = this._distance,
      n = Lp.LEFT
    this._distance < 0 && ((e = -this._distance), (n = Lp.RIGHT))
    const i = t.getExteriorRing(),
      s = Cu.removeRepeatedPoints(i.getCoordinates())
    if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null
    if (this._distance <= 0 && s.length < 3) return null
    this.addRingSide(s, e, n, pd.EXTERIOR, pd.INTERIOR)
    for (let i = 0; i < t.getNumInteriorRing(); i++) {
      const s = t.getInteriorRingN(i),
        r = Cu.removeRepeatedPoints(s.getCoordinates())
      ;(this._distance > 0 && this.isErodedCompletely(s, -this._distance)) ||
        this.addRingSide(r, e, Lp.opposite(n), pd.INTERIOR, pd.EXTERIOR)
    }
  }
  isTriangleErodedCompletely(t, e) {
    const n = new xd(t[0], t[1], t[2]),
      i = n.inCentre()
    return ou.pointToSegment(i, n.p0, n.p1) < Math.abs(e)
  }
  addLineString(t) {
    if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null
    const e = Cu.removeRepeatedPoints(t.getCoordinates())
    if (Cu.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided())
      this.addRingBothSides(e, this._distance)
    else {
      const t = this._curveBuilder.getLineCurve(e, this._distance)
      this.addCurve(t, pd.EXTERIOR, pd.INTERIOR)
    }
  }
  addCurve(t, e, n) {
    if (null === t || t.length < 2) return null
    const i = new Dg(t, new Fp(0, pd.BOUNDARY, e, n))
    this._curveList.add(i)
  }
  getCurves() {
    return this.add(this._inputGeom), this._curveList
  }
  add(t) {
    if (t.isEmpty()) return null
    if (t instanceof Eu) this.addPolygon(t)
    else if (t instanceof mu) this.addLineString(t)
    else if (t instanceof xu) this.addPoint(t)
    else if (t instanceof Iu) this.addCollection(t)
    else if (t instanceof Hu) this.addCollection(t)
    else if (t instanceof Ou) this.addCollection(t)
    else {
      if (!(t instanceof Tu)) throw new pu(t.getGeometryType())
      this.addCollection(t)
    }
  }
  isErodedCompletely(t, e) {
    const n = t.getCoordinates()
    if (n.length < 4) return e < 0
    if (4 === n.length) return this.isTriangleErodedCompletely(n, e)
    const i = t.getEnvelopeInternal(),
      s = Math.min(i.getHeight(), i.getWidth())
    return e < 0 && 2 * Math.abs(e) > s
  }
  addCollection(t) {
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const n = t.getGeometryN(e)
      this.add(n)
    }
  }
}
class hf {
  constructor() {
    hf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._edgeMap = new Wp()),
      (this._edgeList = null),
      (this._ptInAreaLocation = [pd.NONE, pd.NONE])
  }
  getNextCW(t) {
    this.getEdges()
    const e = this._edgeList.indexOf(t)
    let n = e - 1
    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n)
  }
  propagateSideLabels(t) {
    let e = pd.NONE
    for (let n = this.iterator(); n.hasNext(); ) {
      const i = n.next().getLabel()
      i.isArea(t) && i.getLocation(t, Lp.LEFT) !== pd.NONE && (e = i.getLocation(t, Lp.LEFT))
    }
    if (e === pd.NONE) return null
    let n = e
    for (let e = this.iterator(); e.hasNext(); ) {
      const i = e.next(),
        s = i.getLabel()
      if ((s.getLocation(t, Lp.ON) === pd.NONE && s.setLocation(t, Lp.ON, n), s.isArea(t))) {
        const e = s.getLocation(t, Lp.LEFT),
          r = s.getLocation(t, Lp.RIGHT)
        if (r !== pd.NONE) {
          if (r !== n) throw new eg('side location conflict', i.getCoordinate())
          e === pd.NONE &&
            Cc.shouldNeverReachHere('found single null side (at ' + i.getCoordinate() + ')'),
            (n = e)
        } else
          Cc.isTrue(s.getLocation(t, Lp.LEFT) === pd.NONE, 'found single null side'),
            s.setLocation(t, Lp.RIGHT, n),
            s.setLocation(t, Lp.LEFT, n)
      }
    }
  }
  getCoordinate() {
    const t = this.iterator()
    if (!t.hasNext()) return null
    return t.next().getCoordinate()
  }
  print(t) {
    su.out.println('EdgeEndStar:   ' + this.getCoordinate())
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().print(t)
    }
  }
  isAreaLabelsConsistent(t) {
    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
  }
  checkAreaLabelsConsistent(t) {
    const e = this.getEdges()
    if (e.size() <= 0) return !0
    const n = e.size() - 1,
      i = e.get(n).getLabel().getLocation(t, Lp.LEFT)
    Cc.isTrue(i !== pd.NONE, 'Found unlabelled area edge')
    let s = i
    for (let e = this.iterator(); e.hasNext(); ) {
      const n = e.next().getLabel()
      Cc.isTrue(n.isArea(t), 'Found non-area edge')
      const i = n.getLocation(t, Lp.LEFT),
        r = n.getLocation(t, Lp.RIGHT)
      if (i === r) return !1
      if (r !== s) return !1
      s = i
    }
    return !0
  }
  findIndex(t) {
    this.iterator()
    for (let e = 0; e < this._edgeList.size(); e++) {
      if (this._edgeList.get(e) === t) return e
    }
    return -1
  }
  iterator() {
    return this.getEdges().iterator()
  }
  getEdges() {
    return (
      null === this._edgeList && (this._edgeList = new Yc(this._edgeMap.values())), this._edgeList
    )
  }
  getLocation(t, e, n) {
    return (
      this._ptInAreaLocation[t] === pd.NONE &&
        (this._ptInAreaLocation[t] = hp.locate(e, n[t].getGeometry())),
      this._ptInAreaLocation[t]
    )
  }
  toString() {
    const t = new Kc()
    t.append('EdgeEndStar:   ' + this.getCoordinate()), t.append('\n')
    for (let e = this.iterator(); e.hasNext(); ) {
      const n = e.next()
      t.append(n), t.append('\n')
    }
    return t.toString()
  }
  computeEdgeEndLabels(t) {
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().computeLabel(t)
    }
  }
  computeLabelling(t) {
    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),
      this.propagateSideLabels(0),
      this.propagateSideLabels(1)
    const e = [!1, !1]
    for (let t = this.iterator(); t.hasNext(); ) {
      const n = t.next().getLabel()
      for (let t = 0; t < 2; t++) n.isLine(t) && n.getLocation(t) === pd.BOUNDARY && (e[t] = !0)
    }
    for (let n = this.iterator(); n.hasNext(); ) {
      const i = n.next(),
        s = i.getLabel()
      for (let n = 0; n < 2; n++)
        if (s.isAnyNull(n)) {
          let r = pd.NONE
          if (e[n]) r = pd.EXTERIOR
          else {
            const e = i.getCoordinate()
            r = this.getLocation(n, e, t)
          }
          s.setAllLocationsIfNull(n, r)
        }
    }
  }
  getDegree() {
    return this._edgeMap.size()
  }
  insertEdgeEnd(t, e) {
    this._edgeMap.put(t, e), (this._edgeList = null)
  }
}
class cf extends hf {
  constructor() {
    super(), cf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._resultAreaEdgeList = null),
      (this._label = null),
      (this._SCANNING_FOR_INCOMING = 1),
      (this._LINKING_TO_OUTGOING = 2)
  }
  linkResultDirectedEdges() {
    this.getResultAreaEdges()
    let t = null,
      e = null,
      n = this._SCANNING_FOR_INCOMING
    for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {
      const s = this._resultAreaEdgeList.get(i),
        r = s.getSym()
      if (s.getLabel().isArea())
        switch ((null === t && s.isInResult() && (t = s), n)) {
          case this._SCANNING_FOR_INCOMING:
            if (!r.isInResult()) continue
            ;(e = r), (n = this._LINKING_TO_OUTGOING)
            break
          case this._LINKING_TO_OUTGOING:
            if (!s.isInResult()) continue
            e.setNext(s), (n = this._SCANNING_FOR_INCOMING)
        }
    }
    if (n === this._LINKING_TO_OUTGOING) {
      if (null === t) throw new eg('no outgoing dirEdge found', this.getCoordinate())
      Cc.isTrue(t.isInResult(), 'unable to link last incoming dirEdge'), e.setNext(t)
    }
  }
  insert(t) {
    const e = t
    this.insertEdgeEnd(e, e)
  }
  getRightmostEdge() {
    const t = this.getEdges(),
      e = t.size()
    if (e < 1) return null
    const n = t.get(0)
    if (1 === e) return n
    const i = t.get(e - 1),
      s = n.getQuadrant(),
      r = i.getQuadrant()
    return Rp.isNorthern(s) && Rp.isNorthern(r)
      ? n
      : Rp.isNorthern(s) || Rp.isNorthern(r)
        ? 0 !== n.getDy()
          ? n
          : 0 !== i.getDy()
            ? i
            : (Cc.shouldNeverReachHere('found two horizontal edges incident on node'), null)
        : i
  }
  print(t) {
    su.out.println('DirectedEdgeStar: ' + this.getCoordinate())
    for (let e = this.iterator(); e.hasNext(); ) {
      const n = e.next()
      t.print('out '), n.print(t), t.println(), t.print('in '), n.getSym().print(t), t.println()
    }
  }
  getResultAreaEdges() {
    if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList
    this._resultAreaEdgeList = new Yc()
    for (let t = this.iterator(); t.hasNext(); ) {
      const e = t.next()
      ;(e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
    }
    return this._resultAreaEdgeList
  }
  updateLabelling(t) {
    for (let e = this.iterator(); e.hasNext(); ) {
      const n = e.next().getLabel()
      n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1))
    }
  }
  linkAllDirectedEdges() {
    this.getEdges()
    let t = null,
      e = null
    for (let n = this._edgeList.size() - 1; n >= 0; n--) {
      const i = this._edgeList.get(n),
        s = i.getSym()
      null === e && (e = s), null !== t && s.setNext(t), (t = i)
    }
    e.setNext(t)
  }
  computeDepths() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = this.findIndex(t),
        n = t.getDepth(Lp.LEFT),
        i = t.getDepth(Lp.RIGHT),
        s = this.computeDepths(e + 1, this._edgeList.size(), n)
      if (this.computeDepths(0, e, s) !== i) throw new eg('depth mismatch at ' + t.getCoordinate())
    } else if (3 === arguments.length) {
      const t = arguments[1]
      let e = arguments[2]
      for (let n = arguments[0]; n < t; n++) {
        const t = this._edgeList.get(n)
        t.setEdgeDepths(Lp.RIGHT, e), (e = t.getDepth(Lp.LEFT))
      }
      return e
    }
  }
  mergeSymLabels() {
    for (let t = this.iterator(); t.hasNext(); ) {
      const e = t.next()
      e.getLabel().merge(e.getSym().getLabel())
    }
  }
  linkMinimalDirectedEdges(t) {
    let e = null,
      n = null,
      i = this._SCANNING_FOR_INCOMING
    for (let s = this._resultAreaEdgeList.size() - 1; s >= 0; s--) {
      const r = this._resultAreaEdgeList.get(s),
        o = r.getSym()
      switch ((null === e && r.getEdgeRing() === t && (e = r), i)) {
        case this._SCANNING_FOR_INCOMING:
          if (o.getEdgeRing() !== t) continue
          ;(n = o), (i = this._LINKING_TO_OUTGOING)
          break
        case this._LINKING_TO_OUTGOING:
          if (r.getEdgeRing() !== t) continue
          n.setNextMin(r), (i = this._SCANNING_FOR_INCOMING)
      }
    }
    i === this._LINKING_TO_OUTGOING &&
      (Cc.isTrue(null !== e, 'found null for first outgoing dirEdge'),
      Cc.isTrue(e.getEdgeRing() === t, 'unable to link last incoming dirEdge'),
      n.setNextMin(e))
  }
  getOutgoingDegree() {
    if (0 === arguments.length) {
      let t = 0
      for (let e = this.iterator(); e.hasNext(); ) {
        e.next().isInResult() && t++
      }
      return t
    }
    if (1 === arguments.length) {
      const t = arguments[0]
      let e = 0
      for (let n = this.iterator(); n.hasNext(); ) {
        n.next().getEdgeRing() === t && e++
      }
      return e
    }
  }
  getLabel() {
    return this._label
  }
  findCoveredLineEdges() {
    let t = pd.NONE
    for (let e = this.iterator(); e.hasNext(); ) {
      const n = e.next(),
        i = n.getSym()
      if (!n.isLineEdge()) {
        if (n.isInResult()) {
          t = pd.INTERIOR
          break
        }
        if (i.isInResult()) {
          t = pd.EXTERIOR
          break
        }
      }
    }
    if (t === pd.NONE) return null
    let e = t
    for (let t = this.iterator(); t.hasNext(); ) {
      const n = t.next(),
        i = n.getSym()
      n.isLineEdge()
        ? n.getEdge().setCovered(e === pd.INTERIOR)
        : (n.isInResult() && (e = pd.EXTERIOR), i.isInResult() && (e = pd.INTERIOR))
    }
  }
  computeLabelling(t) {
    super.computeLabelling.call(this, t), (this._label = new Fp(pd.NONE))
    for (let t = this.iterator(); t.hasNext(); ) {
      const e = t.next().getEdge().getLabel()
      for (let t = 0; t < 2; t++) {
        const n = e.getLocation(t)
        ;(n !== pd.INTERIOR && n !== pd.BOUNDARY) || this._label.setLocation(t, pd.INTERIOR)
      }
    }
  }
}
class uf extends ig {
  constructor() {
    super()
  }
  createNode(t) {
    return new Qp(t, new cf())
  }
}
class df {
  constructor() {
    df.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pts = null), (this._orientation = null)
    const t = arguments[0]
    ;(this._pts = t), (this._orientation = df.orientation(t))
  }
  static orientation(t) {
    return 1 === Cu.increasingDirection(t)
  }
  static compareOriented(t, e, n, i) {
    const s = e ? 1 : -1,
      r = i ? 1 : -1,
      o = e ? t.length : -1,
      a = i ? n.length : -1
    let l = e ? 0 : t.length - 1,
      h = i ? 0 : n.length - 1
    for (;;) {
      const e = t[l].compareTo(n[h])
      if (0 !== e) return e
      ;(l += s), (h += r)
      const i = l === o,
        c = h === a
      if (i && !c) return -1
      if (!i && c) return 1
      if (i && c) return 0
    }
  }
  compareTo(t) {
    const e = t
    return df.compareOriented(this._pts, this._orientation, e._pts, e._orientation)
  }
  get interfaces_() {
    return [Sc]
  }
}
class pf {
  constructor() {
    pf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._edges = new Yc()), (this._ocaMap = new Wp())
  }
  print(t) {
    t.print('MULTILINESTRING ( ')
    for (let e = 0; e < this._edges.size(); e++) {
      const n = this._edges.get(e)
      e > 0 && t.print(','), t.print('(')
      const i = n.getCoordinates()
      for (let e = 0; e < i.length; e++) e > 0 && t.print(','), t.print(i[e].x + ' ' + i[e].y)
      t.println(')')
    }
    t.print(')  ')
  }
  addAll(t) {
    for (let e = t.iterator(); e.hasNext(); ) this.add(e.next())
  }
  findEdgeIndex(t) {
    for (let e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e
    return -1
  }
  iterator() {
    return this._edges.iterator()
  }
  getEdges() {
    return this._edges
  }
  get(t) {
    return this._edges.get(t)
  }
  findEqualEdge(t) {
    const e = new df(t.getCoordinates())
    return this._ocaMap.get(e)
  }
  add(t) {
    this._edges.add(t)
    const e = new df(t.getCoordinates())
    this._ocaMap.put(e, t)
  }
}
class gf {
  processIntersections(t, e, n, i) {}
  isDone() {}
}
class ff {
  constructor() {
    ff.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._hasIntersection = !1),
      (this._hasProper = !1),
      (this._hasProperInterior = !1),
      (this._hasInterior = !1),
      (this._properIntersectionPoint = null),
      (this._li = null),
      (this._isSelfIntersection = null),
      (this.numIntersections = 0),
      (this.numInteriorIntersections = 0),
      (this.numProperIntersections = 0),
      (this.numTests = 0)
    const t = arguments[0]
    this._li = t
  }
  static isAdjacentSegments(t, e) {
    return 1 === Math.abs(t - e)
  }
  isTrivialIntersection(t, e, n, i) {
    if (t === n && 1 === this._li.getIntersectionNum()) {
      if (ff.isAdjacentSegments(e, i)) return !0
      if (t.isClosed()) {
        const n = t.size() - 1
        if ((0 === e && i === n) || (0 === i && e === n)) return !0
      }
    }
    return !1
  }
  getProperIntersectionPoint() {
    return this._properIntersectionPoint
  }
  hasProperInteriorIntersection() {
    return this._hasProperInterior
  }
  getLineIntersector() {
    return this._li
  }
  hasProperIntersection() {
    return this._hasProper
  }
  processIntersections(t, e, n, i) {
    if (t === n && e === i) return null
    this.numTests++
    const s = t.getCoordinates()[e],
      r = t.getCoordinates()[e + 1],
      o = n.getCoordinates()[i],
      a = n.getCoordinates()[i + 1]
    this._li.computeIntersection(s, r, o, a),
      this._li.hasIntersection() &&
        (this.numIntersections++,
        this._li.isInteriorIntersection() &&
          (this.numInteriorIntersections++, (this._hasInterior = !0)),
        this.isTrivialIntersection(t, e, n, i) ||
          ((this._hasIntersection = !0),
          t.addIntersections(this._li, e, 0),
          n.addIntersections(this._li, i, 1),
          this._li.isProper() &&
            (this.numProperIntersections++,
            (this._hasProper = !0),
            (this._hasProperInterior = !0))))
  }
  hasIntersection() {
    return this._hasIntersection
  }
  isDone() {
    return !1
  }
  hasInteriorIntersection() {
    return this._hasInterior
  }
  get interfaces_() {
    return [gf]
  }
}
class mf {
  constructor() {
    mf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._bufParams = null),
      (this._workingPrecisionModel = null),
      (this._workingNoder = null),
      (this._geomFact = null),
      (this._graph = null),
      (this._edgeList = new pf())
    const t = arguments[0]
    this._bufParams = t
  }
  static depthDelta(t) {
    const e = t.getLocation(0, Lp.LEFT),
      n = t.getLocation(0, Lp.RIGHT)
    return e === pd.INTERIOR && n === pd.EXTERIOR
      ? 1
      : e === pd.EXTERIOR && n === pd.INTERIOR
        ? -1
        : 0
  }
  static convertSegStrings(t) {
    const e = new ku(),
      n = new Yc()
    for (; t.hasNext(); ) {
      const i = t.next(),
        s = e.createLineString(i.getCoordinates())
      n.add(s)
    }
    return e.buildGeometry(n)
  }
  setWorkingPrecisionModel(t) {
    this._workingPrecisionModel = t
  }
  insertUniqueEdge(t) {
    const e = this._edgeList.findEqualEdge(t)
    if (null !== e) {
      const n = e.getLabel()
      let i = t.getLabel()
      e.isPointwiseEqual(t) || ((i = new Fp(t.getLabel())), i.flip()), n.merge(i)
      const s = mf.depthDelta(i),
        r = e.getDepthDelta() + s
      e.setDepthDelta(r)
    } else this._edgeList.add(t), t.setDepthDelta(mf.depthDelta(t.getLabel()))
  }
  buildSubgraphs(t, e) {
    const n = new Yc()
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next(),
        s = t.getRightmostCoordinate(),
        r = new of(n).getDepth(s)
      t.computeDepth(r), t.findResultEdges(), n.add(t), e.add(t.getDirectedEdges(), t.getNodes())
    }
  }
  createSubgraphs(t) {
    const e = new Yc()
    for (let n = t.getNodes().iterator(); n.hasNext(); ) {
      const t = n.next()
      if (!t.isVisited()) {
        const n = new Kg()
        n.create(t), e.add(n)
      }
    }
    return Od.sort(e, Od.reverseOrder()), e
  }
  createEmptyResultGeometry() {
    return this._geomFact.createPolygon()
  }
  getNoder(t) {
    if (null !== this._workingNoder) return this._workingNoder
    const e = new Ug(),
      n = new ud()
    return n.setPrecisionModel(t), e.setSegmentIntersector(new ff(n)), e
  }
  buffer(t, e) {
    let n = this._workingPrecisionModel
    null === n && (n = t.getPrecisionModel()), (this._geomFact = t.getFactory())
    const i = new rf(n, this._bufParams),
      s = new lf(t, e, i).getCurves()
    if (s.size() <= 0) return this.createEmptyResultGeometry()
    this.computeNodedEdges(s, n),
      (this._graph = new sg(new uf())),
      this._graph.addEdges(this._edgeList.getEdges())
    const r = this.createSubgraphs(this._graph),
      o = new tf(this._geomFact)
    this.buildSubgraphs(r, o)
    const a = o.getPolygons()
    if (a.size() <= 0) return this.createEmptyResultGeometry()
    return this._geomFact.buildGeometry(a)
  }
  computeNodedEdges(t, e) {
    const n = this.getNoder(e)
    n.computeNodes(t)
    for (let t = n.getNodedSubstrings().iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getCoordinates()
      if (2 === n.length && n[0].equals2D(n[1])) continue
      const i = e.getData(),
        s = new Jp(e.getCoordinates(), new Fp(i))
      this.insertUniqueEdge(s)
    }
  }
  setNoder(t) {
    this._workingNoder = t
  }
}
class yf {
  constructor() {
    yf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()), (this._segStrings = null)
    const t = arguments[0]
    this._segStrings = t
  }
  checkEndPtVertexIntersections() {
    if (0 === arguments.length)
      for (let t = this._segStrings.iterator(); t.hasNext(); ) {
        const e = t.next().getCoordinates()
        this.checkEndPtVertexIntersections(e[0], this._segStrings),
          this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings)
      }
    else if (2 === arguments.length) {
      const t = arguments[0]
      for (let e = arguments[1].iterator(); e.hasNext(); ) {
        const n = e.next().getCoordinates()
        for (let e = 1; e < n.length - 1; e++)
          if (n[e].equals(t))
            throw new Rc('found endpt/interior pt intersection at index ' + e + ' :pt ' + t)
      }
    }
  }
  checkInteriorIntersections() {
    if (0 === arguments.length)
      for (let t = this._segStrings.iterator(); t.hasNext(); ) {
        const e = t.next()
        for (let t = this._segStrings.iterator(); t.hasNext(); ) {
          const n = t.next()
          this.checkInteriorIntersections(e, n)
        }
      }
    else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = t.getCoordinates(),
        i = e.getCoordinates()
      for (let s = 0; s < n.length - 1; s++)
        for (let n = 0; n < i.length - 1; n++) this.checkInteriorIntersections(t, s, e, n)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      if (t === n && e === i) return null
      const s = t.getCoordinates()[e],
        r = t.getCoordinates()[e + 1],
        o = n.getCoordinates()[i],
        a = n.getCoordinates()[i + 1]
      if (
        (this._li.computeIntersection(s, r, o, a),
        this._li.hasIntersection() &&
          (this._li.isProper() ||
            this.hasInteriorIntersection(this._li, s, r) ||
            this.hasInteriorIntersection(this._li, o, a)))
      )
        throw new Rc('found non-noded intersection at ' + s + '-' + r + ' and ' + o + '-' + a)
    }
  }
  checkValid() {
    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
  }
  checkCollapses() {
    if (0 === arguments.length)
      for (let t = this._segStrings.iterator(); t.hasNext(); ) {
        const e = t.next()
        this.checkCollapses(e)
      }
    else if (1 === arguments.length) {
      const t = arguments[0].getCoordinates()
      for (let e = 0; e < t.length - 2; e++) this.checkCollapse(t[e], t[e + 1], t[e + 2])
    }
  }
  hasInteriorIntersection(t, e, n) {
    for (let i = 0; i < t.getIntersectionNum(); i++) {
      const s = t.getIntersection(i)
      if (!s.equals(e) && !s.equals(n)) return !0
    }
    return !1
  }
  checkCollapse(t, e, n) {
    if (t.equals(n))
      throw new Rc('found non-noded collapse at ' + yf.fact.createLineString([t, e, n]))
  }
}
yf.fact = new ku()
class xf {
  constructor() {
    xf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = null),
      (this._pt = null),
      (this._originalPt = null),
      (this._ptScaled = null),
      (this._p0Scaled = null),
      (this._p1Scaled = null),
      (this._scaleFactor = null),
      (this._minx = null),
      (this._maxx = null),
      (this._miny = null),
      (this._maxy = null),
      (this._corner = new Array(4).fill(null)),
      (this._safeEnv = null)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    if (((this._originalPt = t), (this._pt = t), (this._scaleFactor = e), (this._li = n), e <= 0))
      throw new Ec('Scale factor must be non-zero')
    1 !== e &&
      ((this._pt = new Oc(this.scale(t.x), this.scale(t.y))),
      (this._p0Scaled = new Oc()),
      (this._p1Scaled = new Oc())),
      this.initCorners(this._pt)
  }
  intersectsScaled(t, e) {
    const n = Math.min(t.x, e.x),
      i = Math.max(t.x, e.x),
      s = Math.min(t.y, e.y),
      r = Math.max(t.y, e.y),
      o = this._maxx < n || this._minx > i || this._maxy < s || this._miny > r
    if (o) return !1
    const a = this.intersectsToleranceSquare(t, e)
    return Cc.isTrue(!(o && a), 'Found bad envelope test'), a
  }
  initCorners(t) {
    const e = 0.5
    ;(this._minx = t.x - e),
      (this._maxx = t.x + e),
      (this._miny = t.y - e),
      (this._maxy = t.y + e),
      (this._corner[0] = new Oc(this._maxx, this._maxy)),
      (this._corner[1] = new Oc(this._minx, this._maxy)),
      (this._corner[2] = new Oc(this._minx, this._miny)),
      (this._corner[3] = new Oc(this._maxx, this._miny))
  }
  intersects(t, e) {
    return 1 === this._scaleFactor
      ? this.intersectsScaled(t, e)
      : (this.copyScaled(t, this._p0Scaled),
        this.copyScaled(e, this._p1Scaled),
        this.intersectsScaled(this._p0Scaled, this._p1Scaled))
  }
  scale(t) {
    return Math.round(t * this._scaleFactor)
  }
  getCoordinate() {
    return this._originalPt
  }
  copyScaled(t, e) {
    ;(e.x = this.scale(t.x)), (e.y = this.scale(t.y))
  }
  getSafeEnvelope() {
    if (null === this._safeEnv) {
      const t = xf.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor
      this._safeEnv = new Xc(
        this._originalPt.x - t,
        this._originalPt.x + t,
        this._originalPt.y - t,
        this._originalPt.y + t
      )
    }
    return this._safeEnv
  }
  intersectsPixelClosure(t, e) {
    return (
      this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
      !!this._li.hasIntersection() ||
        (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
        !!this._li.hasIntersection() ||
          (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
          !!this._li.hasIntersection() ||
            (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]),
            !!this._li.hasIntersection())))
    )
  }
  intersectsToleranceSquare(t, e) {
    let n = !1,
      i = !1
    return (
      this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
      !!this._li.isProper() ||
        (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
        !!this._li.isProper() ||
          (this._li.hasIntersection() && (n = !0),
          this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
          !!this._li.isProper() ||
            (this._li.hasIntersection() && (i = !0),
            this._li.computeIntersection(t, e, this._corner[3], this._corner[0]),
            !!this._li.isProper() || !(!n || !i) || !!t.equals(this._pt) || !!e.equals(this._pt))))
    )
  }
  addSnappedNode(t, e) {
    const n = t.getCoordinate(e),
      i = t.getCoordinate(e + 1)
    return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0)
  }
}
xf.SAFE_ENV_EXPANSION_FACTOR = 0.75
class vf {
  constructor() {
    vf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.selectedSegment = new dd()
  }
  select() {
    if (1 === arguments.length);
    else if (2 === arguments.length) {
      const t = arguments[1]
      arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment)
    }
  }
}
class _f {
  constructor() {
    _f.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._index = null
    const t = arguments[0]
    this._index = t
  }
  snap() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.snap(t, null, -1)
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = t.getSafeEnvelope(),
        s = new wf(t, e, n)
      return (
        this._index.query(
          i,
          new (class {
            get interfaces_() {
              return [Xd]
            }
            visitItem(t) {
              t.select(i, s)
            }
          })()
        ),
        s.isNodeAdded()
      )
    }
  }
}
class wf extends vf {
  constructor() {
    super(), wf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._hotPixel = null),
      (this._parentEdge = null),
      (this._hotPixelVertexIndex = null),
      (this._isNodeAdded = !1)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._hotPixel = t), (this._parentEdge = e), (this._hotPixelVertexIndex = n)
  }
  isNodeAdded() {
    return this._isNodeAdded
  }
  select() {
    if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Fg))
      return super.select.apply(this, arguments)
    {
      const t = arguments[1],
        e = arguments[0].getContext()
      if (
        this._parentEdge === e &&
        (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)
      )
        return null
      this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t)
    }
  }
}
_f.HotPixelSnapAction = wf
class Ef {
  constructor() {
    Ef.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = null), (this._interiorIntersections = null)
    const t = arguments[0]
    ;(this._li = t), (this._interiorIntersections = new Yc())
  }
  processIntersections(t, e, n, i) {
    if (t === n && e === i) return null
    const s = t.getCoordinates()[e],
      r = t.getCoordinates()[e + 1],
      o = n.getCoordinates()[i],
      a = n.getCoordinates()[i + 1]
    if (
      (this._li.computeIntersection(s, r, o, a),
      this._li.hasIntersection() && this._li.isInteriorIntersection())
    ) {
      for (let t = 0; t < this._li.getIntersectionNum(); t++)
        this._interiorIntersections.add(this._li.getIntersection(t))
      t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)
    }
  }
  isDone() {
    return !1
  }
  getInteriorIntersections() {
    return this._interiorIntersections
  }
  get interfaces_() {
    return [gf]
  }
}
class bf {
  constructor() {
    bf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pm = null),
      (this._li = null),
      (this._scaleFactor = null),
      (this._noder = null),
      (this._pointSnapper = null),
      (this._nodedSegStrings = null)
    const t = arguments[0]
    ;(this._pm = t),
      (this._li = new ud()),
      this._li.setPrecisionModel(t),
      (this._scaleFactor = t.getScale())
  }
  checkCorrectness(t) {
    const e = Dg.getNodedSubstrings(t),
      n = new yf(e)
    try {
      n.checkValid()
    } catch (t) {
      if (!(t instanceof wc)) throw t
      t.printStackTrace()
    }
  }
  getNodedSubstrings() {
    return Dg.getNodedSubstrings(this._nodedSegStrings)
  }
  snapRound(t, e) {
    const n = this.findInteriorIntersections(t, e)
    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
  }
  findInteriorIntersections(t, e) {
    const n = new Ef(e)
    return (
      this._noder.setSegmentIntersector(n),
      this._noder.computeNodes(t),
      n.getInteriorIntersections()
    )
  }
  computeVertexSnaps() {
    if (Uc(arguments[0], Vc)) {
      for (let t = arguments[0].iterator(); t.hasNext(); ) {
        const e = t.next()
        this.computeVertexSnaps(e)
      }
    } else if (arguments[0] instanceof Dg) {
      const t = arguments[0],
        e = t.getCoordinates()
      for (let n = 0; n < e.length; n++) {
        const i = new xf(e[n], this._scaleFactor, this._li)
        this._pointSnapper.snap(i, t, n) && t.addIntersection(e[n], n)
      }
    }
  }
  computeNodes(t) {
    ;(this._nodedSegStrings = t),
      (this._noder = new Ug()),
      (this._pointSnapper = new _f(this._noder.getIndex())),
      this.snapRound(t, this._li)
  }
  computeIntersectionSnaps(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next(),
        n = new xf(t, this._scaleFactor, this._li)
      this._pointSnapper.snap(n)
    }
  }
  get interfaces_() {
    return [zg]
  }
}
class Mf {
  constructor() {
    Mf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._argGeom = null),
      (this._distance = null),
      (this._bufParams = new qg()),
      (this._resultGeometry = null),
      (this._saveException = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      this._argGeom = t
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._argGeom = t), (this._bufParams = e)
    }
  }
  static bufferOp() {
    if (2 === arguments.length) {
      const t = arguments[1]
      return new Mf(arguments[0]).getResultGeometry(t)
    }
    if (3 === arguments.length) {
      if (
        Number.isInteger(arguments[2]) &&
        arguments[0] instanceof hu &&
        'number' == typeof arguments[1]
      ) {
        const t = arguments[1],
          e = arguments[2],
          n = new Mf(arguments[0])
        n.setQuadrantSegments(e)
        return n.getResultGeometry(t)
      }
      if (
        arguments[2] instanceof qg &&
        arguments[0] instanceof hu &&
        'number' == typeof arguments[1]
      ) {
        const t = arguments[1]
        return new Mf(arguments[0], arguments[2]).getResultGeometry(t)
      }
    } else if (4 === arguments.length) {
      const t = arguments[1],
        e = arguments[2],
        n = arguments[3],
        i = new Mf(arguments[0])
      i.setQuadrantSegments(e), i.setEndCapStyle(n)
      return i.getResultGeometry(t)
    }
  }
  static precisionScaleFactor(t, e, n) {
    const i = t.getEnvelopeInternal(),
      s =
        ru.max(
          Math.abs(i.getMaxX()),
          Math.abs(i.getMaxY()),
          Math.abs(i.getMinX()),
          Math.abs(i.getMinY())
        ) +
        2 * (e > 0 ? e : 0),
      r = n - Math.trunc(Math.log(s) / Math.log(10) + 1)
    return Math.pow(10, r)
  }
  bufferFixedPrecision(t) {
    const e = new Hg(new bf(new Uu(1)), t.getScale()),
      n = new mf(this._bufParams)
    n.setWorkingPrecisionModel(t),
      n.setNoder(e),
      (this._resultGeometry = n.buffer(this._argGeom, this._distance))
  }
  bufferReducedPrecision() {
    if (0 === arguments.length) {
      for (let t = Mf.MAX_PRECISION_DIGITS; t >= 0; t--) {
        try {
          this.bufferReducedPrecision(t)
        } catch (t) {
          if (!(t instanceof eg)) throw t
          this._saveException = t
        }
        if (null !== this._resultGeometry) return null
      }
      throw this._saveException
    }
    if (1 === arguments.length) {
      const t = arguments[0],
        e = Mf.precisionScaleFactor(this._argGeom, this._distance, t),
        n = new Uu(e)
      this.bufferFixedPrecision(n)
    }
  }
  computeGeometry() {
    if ((this.bufferOriginalPrecision(), null !== this._resultGeometry)) return null
    const t = this._argGeom.getFactory().getPrecisionModel()
    t.getType() === Uu.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
  }
  setQuadrantSegments(t) {
    this._bufParams.setQuadrantSegments(t)
  }
  bufferOriginalPrecision() {
    try {
      const t = new mf(this._bufParams)
      this._resultGeometry = t.buffer(this._argGeom, this._distance)
    } catch (t) {
      if (!(t instanceof Rc)) throw t
      this._saveException = t
    }
  }
  getResultGeometry(t) {
    return (this._distance = t), this.computeGeometry(), this._resultGeometry
  }
  setEndCapStyle(t) {
    this._bufParams.setEndCapStyle(t)
  }
}
;(Mf.CAP_ROUND = qg.CAP_ROUND),
  (Mf.CAP_BUTT = qg.CAP_FLAT),
  (Mf.CAP_FLAT = qg.CAP_FLAT),
  (Mf.CAP_SQUARE = qg.CAP_SQUARE),
  (Mf.MAX_PRECISION_DIGITS = 12)
var Sf = Object.freeze({ __proto__: null, BufferOp: Mf, BufferParameters: qg })
class Af {
  constructor() {
    Af.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._component = null), (this._segIndex = null), (this._pt = null), 2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      Af.constructor_.call(this, t, Af.INSIDE_AREA, e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._component = t), (this._segIndex = e), (this._pt = n)
    }
  }
  getSegmentIndex() {
    return this._segIndex
  }
  getCoordinate() {
    return this._pt
  }
  isInsideArea() {
    return this._segIndex === Af.INSIDE_AREA
  }
  toString() {
    return this._component.getGeometryType() + '[' + this._segIndex + ']-' + hd.toPoint(this._pt)
  }
  getGeometryComponent() {
    return this._component
  }
}
Af.INSIDE_AREA = -1
class Tf {
  constructor() {
    Tf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._locations = null
    const t = arguments[0]
    this._locations = t
  }
  static getLocations(t) {
    const e = new Yc()
    return t.apply(new Tf(e)), e
  }
  filter(t) {
    if (t.isEmpty()) return null
    ;(t instanceof xu || t instanceof mu || t instanceof Eu) &&
      this._locations.add(new Af(t, 0, t.getCoordinate()))
  }
  get interfaces_() {
    return [fu]
  }
}
class If {
  constructor() {
    If.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._geom = null),
      (this._terminateDistance = 0),
      (this._ptLocator = new Ap()),
      (this._minDistanceLocation = null),
      (this._minDistance = Mc.MAX_VALUE),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      If.constructor_.call(this, t, e, 0)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._geom = new Array(2).fill(null)),
        (this._geom[0] = t),
        (this._geom[1] = e),
        (this._terminateDistance = n)
    }
  }
  static distance(t, e) {
    return new If(t, e).distance()
  }
  static isWithinDistance(t, e, n) {
    if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > n) return !1
    return new If(t, e, n).distance() <= n
  }
  static nearestPoints(t, e) {
    return new If(t, e).nearestPoints()
  }
  computeContainmentDistance() {
    if (0 === arguments.length) {
      const t = new Array(2).fill(null)
      if ((this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance))
        return null
      this.computeContainmentDistance(1, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = this._geom[t]
      if (n.getDimension() < 2) return null
      const i = 1 - t,
        s = Gd.getPolygons(n)
      if (s.size() > 0) {
        const n = Tf.getLocations(this._geom[i])
        if (
          (this.computeContainmentDistance(n, s, e), this._minDistance <= this._terminateDistance)
        )
          return (this._minDistanceLocation[i] = e[0]), (this._minDistanceLocation[t] = e[1]), null
      }
    } else if (3 === arguments.length)
      if (arguments[2] instanceof Array && Uc(arguments[0], kc) && Uc(arguments[1], kc)) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        for (let i = 0; i < t.size(); i++) {
          const s = t.get(i)
          for (let t = 0; t < e.size(); t++)
            if (
              (this.computeContainmentDistance(s, e.get(t), n),
              this._minDistance <= this._terminateDistance)
            )
              return null
        }
      } else if (
        arguments[2] instanceof Array &&
        arguments[0] instanceof Af &&
        arguments[1] instanceof Eu
      ) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2],
          i = t.getCoordinate()
        if (pd.EXTERIOR !== this._ptLocator.locate(i, e))
          return (this._minDistance = 0), (n[0] = t), (n[1] = new Af(e, i)), null
      }
  }
  computeMinDistanceLinesPoints(t, e, n) {
    for (let i = 0; i < t.size(); i++) {
      const s = t.get(i)
      for (let t = 0; t < e.size(); t++) {
        const i = e.get(t)
        if ((this.computeMinDistance(s, i, n), this._minDistance <= this._terminateDistance))
          return null
      }
    }
  }
  computeFacetDistance() {
    const t = new Array(2).fill(null),
      e = Dd.getLines(this._geom[0]),
      n = Dd.getLines(this._geom[1]),
      i = Fd.getPoints(this._geom[0]),
      s = Fd.getPoints(this._geom[1])
    return (
      this.computeMinDistanceLines(e, n, t),
      this.updateMinDistance(t, !1),
      this._minDistance <= this._terminateDistance
        ? null
        : ((t[0] = null),
          (t[1] = null),
          this.computeMinDistanceLinesPoints(e, s, t),
          this.updateMinDistance(t, !1),
          this._minDistance <= this._terminateDistance
            ? null
            : ((t[0] = null),
              (t[1] = null),
              this.computeMinDistanceLinesPoints(n, i, t),
              this.updateMinDistance(t, !0),
              this._minDistance <= this._terminateDistance
                ? null
                : ((t[0] = null),
                  (t[1] = null),
                  this.computeMinDistancePoints(i, s, t),
                  void this.updateMinDistance(t, !1))))
    )
  }
  nearestLocations() {
    return this.computeMinDistance(), this._minDistanceLocation
  }
  updateMinDistance(t, e) {
    if (null === t[0]) return null
    e
      ? ((this._minDistanceLocation[0] = t[1]), (this._minDistanceLocation[1] = t[0]))
      : ((this._minDistanceLocation[0] = t[0]), (this._minDistanceLocation[1] = t[1]))
  }
  nearestPoints() {
    this.computeMinDistance()
    return [
      this._minDistanceLocation[0].getCoordinate(),
      this._minDistanceLocation[1].getCoordinate()
    ]
  }
  computeMinDistance() {
    if (0 === arguments.length) {
      if (null !== this._minDistanceLocation) return null
      if (
        ((this._minDistanceLocation = new Array(2).fill(null)),
        this.computeContainmentDistance(),
        this._minDistance <= this._terminateDistance)
      )
        return null
      this.computeFacetDistance()
    } else if (3 === arguments.length)
      if (
        arguments[2] instanceof Array &&
        arguments[0] instanceof mu &&
        arguments[1] instanceof xu
      ) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance)
          return null
        const i = t.getCoordinates(),
          s = e.getCoordinate()
        for (let r = 0; r < i.length - 1; r++) {
          const o = ou.pointToSegment(s, i[r], i[r + 1])
          if (o < this._minDistance) {
            this._minDistance = o
            const a = new dd(i[r], i[r + 1]).closestPoint(s)
            ;(n[0] = new Af(t, r, a)), (n[1] = new Af(e, 0, s))
          }
          if (this._minDistance <= this._terminateDistance) return null
        }
      } else if (
        arguments[2] instanceof Array &&
        arguments[0] instanceof mu &&
        arguments[1] instanceof mu
      ) {
        const t = arguments[0],
          e = arguments[1],
          n = arguments[2]
        if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance)
          return null
        const i = t.getCoordinates(),
          s = e.getCoordinates()
        for (let r = 0; r < i.length - 1; r++) {
          const o = new Xc(i[r], i[r + 1])
          if (!(o.distance(e.getEnvelopeInternal()) > this._minDistance))
            for (let a = 0; a < s.length - 1; a++) {
              const l = new Xc(s[a], s[a + 1])
              if (o.distance(l) > this._minDistance) continue
              const h = ou.segmentToSegment(i[r], i[r + 1], s[a], s[a + 1])
              if (h < this._minDistance) {
                this._minDistance = h
                const o = new dd(i[r], i[r + 1]),
                  l = new dd(s[a], s[a + 1]),
                  c = o.closestPoints(l)
                ;(n[0] = new Af(t, r, c[0])), (n[1] = new Af(e, a, c[1]))
              }
              if (this._minDistance <= this._terminateDistance) return null
            }
        }
      }
  }
  computeMinDistancePoints(t, e, n) {
    for (let i = 0; i < t.size(); i++) {
      const s = t.get(i)
      for (let t = 0; t < e.size(); t++) {
        const i = e.get(t),
          r = s.getCoordinate().distance(i.getCoordinate())
        if (
          (r < this._minDistance &&
            ((this._minDistance = r),
            (n[0] = new Af(s, 0, s.getCoordinate())),
            (n[1] = new Af(i, 0, i.getCoordinate()))),
          this._minDistance <= this._terminateDistance)
        )
          return null
      }
    }
  }
  distance() {
    if (null === this._geom[0] || null === this._geom[1])
      throw new Ec('null geometries are not supported')
    return this._geom[0].isEmpty() || this._geom[1].isEmpty()
      ? 0
      : (this.computeMinDistance(), this._minDistance)
  }
  computeMinDistanceLines(t, e, n) {
    for (let i = 0; i < t.size(); i++) {
      const s = t.get(i)
      for (let t = 0; t < e.size(); t++) {
        const i = e.get(t)
        if ((this.computeMinDistance(s, i, n), this._minDistance <= this._terminateDistance))
          return null
      }
    }
  }
}
var Rf = Object.freeze({ __proto__: null, DistanceOp: If })
class Lf {
  constructor() {
    Lf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._factory = null), (this._directedEdges = new Yc()), (this._coordinates = null)
    const t = arguments[0]
    this._factory = t
  }
  getCoordinates() {
    if (null === this._coordinates) {
      let t = 0,
        e = 0
      const n = new qc()
      for (let i = this._directedEdges.iterator(); i.hasNext(); ) {
        const s = i.next()
        s.getEdgeDirection() ? t++ : e++,
          n.add(s.getEdge().getLine().getCoordinates(), !1, s.getEdgeDirection())
      }
      ;(this._coordinates = n.toCoordinateArray()), e > t && Cu.reverse(this._coordinates)
    }
    return this._coordinates
  }
  toLineString() {
    return this._factory.createLineString(this.getCoordinates())
  }
  add(t) {
    this._directedEdges.add(t)
  }
}
class Cf {
  constructor() {
    Cf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isMarked = !1), (this._isVisited = !1), (this._data = null)
  }
  static getComponentWithVisitedState(t, e) {
    for (; t.hasNext(); ) {
      const n = t.next()
      if (n.isVisited() === e) return n
    }
    return null
  }
  static setVisited(t, e) {
    for (; t.hasNext(); ) {
      t.next().setVisited(e)
    }
  }
  static setMarked(t, e) {
    for (; t.hasNext(); ) {
      t.next().setMarked(e)
    }
  }
  setVisited(t) {
    this._isVisited = t
  }
  isMarked() {
    return this._isMarked
  }
  setData(t) {
    this._data = t
  }
  getData() {
    return this._data
  }
  setMarked(t) {
    this._isMarked = t
  }
  getContext() {
    return this._data
  }
  isVisited() {
    return this._isVisited
  }
  setContext(t) {
    this._data = t
  }
}
class Nf extends Cf {
  constructor() {
    super(), Nf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._parentEdge = null),
      (this._from = null),
      (this._to = null),
      (this._p0 = null),
      (this._p1 = null),
      (this._sym = null),
      (this._edgeDirection = null),
      (this._quadrant = null),
      (this._angle = null),
      0 === arguments.length)
    );
    else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      ;(this._from = t),
        (this._to = e),
        (this._edgeDirection = i),
        (this._p0 = t.getCoordinate()),
        (this._p1 = n)
      const s = this._p1.x - this._p0.x,
        r = this._p1.y - this._p0.y
      ;(this._quadrant = Rp.quadrant(s, r)), (this._angle = Math.atan2(r, s))
    }
  }
  static toEdges(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) e.add(n.next()._parentEdge)
    return e
  }
  isRemoved() {
    return null === this._parentEdge
  }
  compareDirection(t) {
    return this._quadrant > t._quadrant
      ? 1
      : this._quadrant < t._quadrant
        ? -1
        : nu.index(t._p0, t._p1, this._p1)
  }
  getCoordinate() {
    return this._from.getCoordinate()
  }
  print(t) {
    const e = this.getClass().getName(),
      n = e.lastIndexOf('.'),
      i = e.substring(n + 1)
    t.print(
      '  ' + i + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + this._angle
    )
  }
  getDirectionPt() {
    return this._p1
  }
  getAngle() {
    return this._angle
  }
  compareTo(t) {
    const e = t
    return this.compareDirection(e)
  }
  getFromNode() {
    return this._from
  }
  getSym() {
    return this._sym
  }
  setEdge(t) {
    this._parentEdge = t
  }
  remove() {
    ;(this._sym = null), (this._parentEdge = null)
  }
  getEdge() {
    return this._parentEdge
  }
  getQuadrant() {
    return this._quadrant
  }
  setSym(t) {
    this._sym = t
  }
  getToNode() {
    return this._to
  }
  getEdgeDirection() {
    return this._edgeDirection
  }
  get interfaces_() {
    return [Sc]
  }
}
class Pf extends Nf {
  constructor() {
    super(), Pf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2],
      i = arguments[3]
    Nf.constructor_.call(this, t, e, n, i)
  }
  getNext() {
    return 2 !== this.getToNode().getDegree()
      ? null
      : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()
        ? this.getToNode().getOutEdges().getEdges().get(1)
        : (Cc.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()),
          this.getToNode().getOutEdges().getEdges().get(0))
  }
}
class Df extends Cf {
  constructor() {
    super(), Df.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._dirEdge = null), 0 === arguments.length));
    else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this.setDirectedEdges(t, e)
    }
  }
  isRemoved() {
    return null === this._dirEdge
  }
  setDirectedEdges(t, e) {
    ;(this._dirEdge = [t, e]),
      t.setEdge(this),
      e.setEdge(this),
      t.setSym(e),
      e.setSym(t),
      t.getFromNode().addOutEdge(t),
      e.getFromNode().addOutEdge(e)
  }
  getDirEdge() {
    if (Number.isInteger(arguments[0])) {
      const t = arguments[0]
      return this._dirEdge[t]
    }
    if (arguments[0] instanceof Ff) {
      const t = arguments[0]
      return this._dirEdge[0].getFromNode() === t
        ? this._dirEdge[0]
        : this._dirEdge[1].getFromNode() === t
          ? this._dirEdge[1]
          : null
    }
  }
  remove() {
    this._dirEdge = null
  }
  getOppositeNode(t) {
    return this._dirEdge[0].getFromNode() === t
      ? this._dirEdge[0].getToNode()
      : this._dirEdge[1].getFromNode() === t
        ? this._dirEdge[1].getToNode()
        : null
  }
}
class Of {
  constructor() {
    Of.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._outEdges = new Yc()), (this._sorted = !1)
  }
  getNextEdge(t) {
    const e = this.getIndex(t)
    return this._outEdges.get(this.getIndex(e + 1))
  }
  getCoordinate() {
    const t = this.iterator()
    if (!t.hasNext()) return null
    return t.next().getCoordinate()
  }
  iterator() {
    return this.sortEdges(), this._outEdges.iterator()
  }
  sortEdges() {
    this._sorted || (Od.sort(this._outEdges), (this._sorted = !0))
  }
  remove(t) {
    this._outEdges.remove(t)
  }
  getEdges() {
    return this.sortEdges(), this._outEdges
  }
  getNextCWEdge(t) {
    const e = this.getIndex(t)
    return this._outEdges.get(this.getIndex(e - 1))
  }
  getIndex() {
    if (arguments[0] instanceof Df) {
      const t = arguments[0]
      this.sortEdges()
      for (let e = 0; e < this._outEdges.size(); e++) {
        if (this._outEdges.get(e).getEdge() === t) return e
      }
      return -1
    }
    if (arguments[0] instanceof Nf) {
      const t = arguments[0]
      this.sortEdges()
      for (let e = 0; e < this._outEdges.size(); e++) {
        if (this._outEdges.get(e) === t) return e
      }
      return -1
    }
    if (Number.isInteger(arguments[0])) {
      let t = arguments[0] % this._outEdges.size()
      return t < 0 && (t += this._outEdges.size()), t
    }
  }
  add(t) {
    this._outEdges.add(t), (this._sorted = !1)
  }
  getDegree() {
    return this._outEdges.size()
  }
}
class Ff extends Cf {
  constructor() {
    super(), Ff.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._pt = null), (this._deStar = null), 1 === arguments.length)) {
      const t = arguments[0]
      Ff.constructor_.call(this, t, new Of())
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._pt = t), (this._deStar = e)
    }
  }
  static getEdgesBetween(t, e) {
    const n = Nf.toEdges(t.getOutEdges().getEdges()),
      i = new Gu(n),
      s = Nf.toEdges(e.getOutEdges().getEdges())
    return i.retainAll(s), i
  }
  isRemoved() {
    return null === this._pt
  }
  addOutEdge(t) {
    this._deStar.add(t)
  }
  getCoordinate() {
    return this._pt
  }
  getOutEdges() {
    return this._deStar
  }
  remove() {
    if (0 === arguments.length) this._pt = null
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._deStar.remove(t)
    }
  }
  getIndex(t) {
    return this._deStar.getIndex(t)
  }
  getDegree() {
    return this._deStar.getDegree()
  }
}
class Gf extends Df {
  constructor() {
    super(), Gf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._line = null
    const t = arguments[0]
    this._line = t
  }
  getLine() {
    return this._line
  }
}
class zf {
  constructor() {
    zf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._nodeMap = new Wp()
  }
  find(t) {
    return this._nodeMap.get(t)
  }
  iterator() {
    return this._nodeMap.values().iterator()
  }
  remove(t) {
    return this._nodeMap.remove(t)
  }
  values() {
    return this._nodeMap.values()
  }
  add(t) {
    return this._nodeMap.put(t.getCoordinate(), t), t
  }
}
class Bf {
  constructor() {
    Bf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._edges = new Gu()), (this._dirEdges = new Gu()), (this._nodeMap = new zf())
  }
  findNodesOfDegree(t) {
    const e = new Yc()
    for (let n = this.nodeIterator(); n.hasNext(); ) {
      const i = n.next()
      i.getDegree() === t && e.add(i)
    }
    return e
  }
  dirEdgeIterator() {
    return this._dirEdges.iterator()
  }
  edgeIterator() {
    return this._edges.iterator()
  }
  remove() {
    if (arguments[0] instanceof Df) {
      const t = arguments[0]
      this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this._edges.remove(t), t.remove()
    } else if (arguments[0] instanceof Nf) {
      const t = arguments[0],
        e = t.getSym()
      null !== e && e.setSym(null), t.getFromNode().remove(t), t.remove(), this._dirEdges.remove(t)
    } else if (arguments[0] instanceof Ff) {
      const t = arguments[0]
      for (let e = t.getOutEdges().getEdges().iterator(); e.hasNext(); ) {
        const t = e.next(),
          n = t.getSym()
        null !== n && this.remove(n), this._dirEdges.remove(t)
        const i = t.getEdge()
        null !== i && this._edges.remove(i)
      }
      this._nodeMap.remove(t.getCoordinate()), t.remove()
    }
  }
  findNode(t) {
    return this._nodeMap.find(t)
  }
  getEdges() {
    return this._edges
  }
  nodeIterator() {
    return this._nodeMap.iterator()
  }
  contains() {
    if (arguments[0] instanceof Df) {
      const t = arguments[0]
      return this._edges.contains(t)
    }
    if (arguments[0] instanceof Nf) {
      const t = arguments[0]
      return this._dirEdges.contains(t)
    }
  }
  add() {
    if (arguments[0] instanceof Ff) {
      const t = arguments[0]
      this._nodeMap.add(t)
    } else if (arguments[0] instanceof Df) {
      const t = arguments[0]
      this._edges.add(t), this.add(t.getDirEdge(0)), this.add(t.getDirEdge(1))
    } else if (arguments[0] instanceof Nf) {
      const t = arguments[0]
      this._dirEdges.add(t)
    }
  }
  getNodes() {
    return this._nodeMap.values()
  }
}
class Uf extends Bf {
  constructor() {
    super()
  }
  addEdge(t) {
    if (t.isEmpty()) return null
    const e = Cu.removeRepeatedPoints(t.getCoordinates())
    if (e.length <= 1) return null
    const n = e[0],
      i = e[e.length - 1],
      s = this.getNode(n),
      r = this.getNode(i),
      o = new Pf(s, r, e[1], !0),
      a = new Pf(r, s, e[e.length - 2], !1),
      l = new Gf(t)
    l.setDirectedEdges(o, a), this.add(l)
  }
  getNode(t) {
    let e = this.findNode(t)
    return null === e && ((e = new Ff(t)), this.add(e)), e
  }
}
class Vf {
  constructor() {
    Vf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._graph = new Uf()),
      (this._mergedLineStrings = null),
      (this._factory = null),
      (this._edgeStrings = null)
  }
  buildEdgeStringsForUnprocessedNodes() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      const e = t.next()
      e.isMarked() ||
        (Cc.isTrue(2 === e.getDegree()), this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
    }
  }
  buildEdgeStringsForNonDegree2Nodes() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      const e = t.next()
      2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e), e.setMarked(!0))
    }
  }
  buildEdgeStringsForObviousStartNodes() {
    this.buildEdgeStringsForNonDegree2Nodes()
  }
  getMergedLineStrings() {
    return this.merge(), this._mergedLineStrings
  }
  buildEdgeStringsStartingAt(t) {
    for (let e = t.getOutEdges().iterator(); e.hasNext(); ) {
      const t = e.next()
      t.getEdge().isMarked() || this._edgeStrings.add(this.buildEdgeStringStartingWith(t))
    }
  }
  merge() {
    if (null !== this._mergedLineStrings) return null
    Cf.setMarked(this._graph.nodeIterator(), !1),
      Cf.setMarked(this._graph.edgeIterator(), !1),
      (this._edgeStrings = new Yc()),
      this.buildEdgeStringsForObviousStartNodes(),
      this.buildEdgeStringsForIsolatedLoops(),
      (this._mergedLineStrings = new Yc())
    for (let t = this._edgeStrings.iterator(); t.hasNext(); ) {
      const e = t.next()
      this._mergedLineStrings.add(e.toLineString())
    }
  }
  addLineString(t) {
    null === this._factory && (this._factory = t.getFactory()), this._graph.addEdge(t)
  }
  buildEdgeStringStartingWith(t) {
    const e = new Lf(this._factory)
    let n = t
    do {
      e.add(n), n.getEdge().setMarked(!0), (n = n.getNext())
    } while (null !== n && n !== t)
    return e
  }
  add() {
    if (arguments[0] instanceof hu) {
      const t = arguments[0]
      for (let e = 0; e < t.getNumGeometries(); e++) {
        const n = t.getGeometryN(e)
        n instanceof mu && this.addLineString(n)
      }
    } else if (Uc(arguments[0], Vc)) {
      const t = arguments[0]
      this._mergedLineStrings = null
      for (let e = t.iterator(); e.hasNext(); ) {
        const t = e.next()
        this.add(t)
      }
    }
  }
  buildEdgeStringsForIsolatedLoops() {
    this.buildEdgeStringsForUnprocessedNodes()
  }
}
class Hf {
  constructor() {
    Hf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._parentGraph = null),
      (this._edges = new Gu()),
      (this._dirEdges = new Yc()),
      (this._nodeMap = new zf())
    const t = arguments[0]
    this._parentGraph = t
  }
  dirEdgeIterator() {
    return this._dirEdges.iterator()
  }
  edgeIterator() {
    return this._edges.iterator()
  }
  getParent() {
    return this._parentGraph
  }
  nodeIterator() {
    return this._nodeMap.iterator()
  }
  contains(t) {
    return this._edges.contains(t)
  }
  add(t) {
    if (this._edges.contains(t)) return null
    this._edges.add(t),
      this._dirEdges.add(t.getDirEdge(0)),
      this._dirEdges.add(t.getDirEdge(1)),
      this._nodeMap.add(t.getDirEdge(0).getFromNode()),
      this._nodeMap.add(t.getDirEdge(1).getFromNode())
  }
}
class kf {
  constructor() {
    kf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._graph = null
    const t = arguments[0]
    this._graph = t
  }
  addReachable(t, e) {
    const n = new pp()
    for (n.add(t); !n.empty(); ) {
      const t = n.pop()
      this.addEdges(t, n, e)
    }
  }
  findSubgraph(t) {
    const e = new Hf(this._graph)
    return this.addReachable(t, e), e
  }
  getConnectedSubgraphs() {
    const t = new Yc()
    Cf.setVisited(this._graph.nodeIterator(), !1)
    for (let e = this._graph.edgeIterator(); e.hasNext(); ) {
      const n = e.next().getDirEdge(0).getFromNode()
      n.isVisited() || t.add(this.findSubgraph(n))
    }
    return t
  }
  addEdges(t, e, n) {
    t.setVisited(!0)
    for (let i = t.getOutEdges().iterator(); i.hasNext(); ) {
      const t = i.next()
      n.add(t.getEdge())
      const s = t.getToNode()
      s.isVisited() || e.push(s)
    }
  }
}
class Wf {
  constructor() {
    Wf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._graph = new Uf()),
      (this._factory = new ku()),
      (this._lineCount = 0),
      (this._isRun = !1),
      (this._sequencedGeometry = null),
      (this._isSequenceable = !1)
  }
  static findUnvisitedBestOrientedDE(t) {
    let e = null,
      n = null
    for (let i = t.getOutEdges().iterator(); i.hasNext(); ) {
      const t = i.next()
      t.getEdge().isVisited() || ((n = t), t.getEdgeDirection() && (e = t))
    }
    return null !== e ? e : n
  }
  static findLowestDegreeNode(t) {
    let e = Jc.MAX_VALUE,
      n = null
    for (let i = t.nodeIterator(); i.hasNext(); ) {
      const t = i.next()
      ;(null === n || t.getDegree() < e) && ((e = t.getDegree()), (n = t))
    }
    return n
  }
  static isSequenced(t) {
    if (!(t instanceof Hu)) return !0
    const e = t,
      n = new Su()
    let i = null
    const s = new Yc()
    for (let t = 0; t < e.getNumGeometries(); t++) {
      const r = e.getGeometryN(t),
        o = r.getCoordinateN(0),
        a = r.getCoordinateN(r.getNumPoints() - 1)
      if (n.contains(o)) return !1
      if (n.contains(a)) return !1
      null !== i && (o.equals(i) || (n.addAll(s), s.clear())), s.add(o), s.add(a), (i = a)
    }
    return !0
  }
  static reverse(t) {
    const e = t.getCoordinates(),
      n = new Array(e.length).fill(null),
      i = e.length
    for (let t = 0; t < i; t++) n[i - 1 - t] = new Oc(e[t])
    return t.getFactory().createLineString(n)
  }
  static sequence(t) {
    const e = new Wf()
    return e.add(t), e.getSequencedLineStrings()
  }
  addLine(t) {
    null === this._factory && (this._factory = t.getFactory()),
      this._graph.addEdge(t),
      this._lineCount++
  }
  hasSequence(t) {
    let e = 0
    for (let n = t.nodeIterator(); n.hasNext(); ) {
      n.next().getDegree() % 2 == 1 && e++
    }
    return e <= 2
  }
  computeSequence() {
    if (this._isRun) return null
    this._isRun = !0
    const t = this.findSequences()
    if (null === t) return null
    ;(this._sequencedGeometry = this.buildSequencedGeometry(t)), (this._isSequenceable = !0)
    const e = this._sequencedGeometry.getNumGeometries()
    Cc.isTrue(this._lineCount === e, 'Lines were missing from result'),
      Cc.isTrue(
        this._sequencedGeometry instanceof mu || this._sequencedGeometry instanceof Hu,
        'Result is not lineal'
      )
  }
  findSequences() {
    const t = new Yc()
    for (let e = new kf(this._graph).getConnectedSubgraphs().iterator(); e.hasNext(); ) {
      const n = e.next()
      if (!this.hasSequence(n)) return null
      {
        const e = this.findSequence(n)
        t.add(e)
      }
    }
    return t
  }
  addReverseSubpath(t, e, n) {
    const i = t.getToNode()
    let s = null
    for (;;) {
      e.add(t.getSym()), t.getEdge().setVisited(!0), (s = t.getFromNode())
      const n = Wf.findUnvisitedBestOrientedDE(s)
      if (null === n) break
      t = n.getSym()
    }
    n && Cc.isTrue(s === i, 'path not contiguous')
  }
  findSequence(t) {
    Cf.setVisited(t.edgeIterator(), !1)
    const e = Wf.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),
      n = new Xg(),
      i = n.listIterator()
    for (this.addReverseSubpath(e, i, !1); i.hasPrevious(); ) {
      const t = i.previous(),
        e = Wf.findUnvisitedBestOrientedDE(t.getFromNode())
      null !== e && this.addReverseSubpath(e.getSym(), i, !0)
    }
    return this.orient(n)
  }
  reverse(t) {
    const e = new Xg()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e.addFirst(t.getSym())
    }
    return e
  }
  orient(t) {
    const e = t.get(0),
      n = t.get(t.size() - 1),
      i = e.getFromNode(),
      s = n.getToNode()
    let r = !1
    if (1 === i.getDegree() || 1 === s.getDegree()) {
      let t = !1
      1 === n.getToNode().getDegree() && !1 === n.getEdgeDirection() && ((t = !0), (r = !0)),
        1 === e.getFromNode().getDegree() && !0 === e.getEdgeDirection() && ((t = !0), (r = !1)),
        t || (1 === e.getFromNode().getDegree() && (r = !0))
    }
    return r ? this.reverse(t) : t
  }
  buildSequencedGeometry(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      for (let t = n.next().iterator(); t.hasNext(); ) {
        const n = t.next(),
          i = n.getEdge().getLine()
        let s = i
        n.getEdgeDirection() || i.isClosed() || (s = Wf.reverse(i)), e.add(s)
      }
    }
    return 0 === e.size()
      ? this._factory.createMultiLineString(new Array(0).fill(null))
      : this._factory.buildGeometry(e)
  }
  getSequencedLineStrings() {
    return this.computeSequence(), this._sequencedGeometry
  }
  isSequenceable() {
    return this.computeSequence(), this._isSequenceable
  }
  add() {
    if (Uc(arguments[0], Vc)) {
      for (let t = arguments[0].iterator(); t.hasNext(); ) {
        const e = t.next()
        this.add(e)
      }
    } else if (arguments[0] instanceof hu) {
      arguments[0].apply(
        new (class {
          get interfaces_() {
            return [lu]
          }
          filter(t) {
            t instanceof mu && this.addLine(t)
          }
        })()
      )
    }
  }
}
var Yf = Object.freeze({ __proto__: null, LineMerger: Vf, LineSequencer: Wf })
class jf {
  constructor() {
    jf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._snapTolerance = 0),
      (this._srcPts = null),
      (this._seg = new dd()),
      (this._allowSnappingToSourceVertices = !1),
      (this._isClosed = !1),
      arguments[0] instanceof mu && 'number' == typeof arguments[1])
    ) {
      const t = arguments[0],
        e = arguments[1]
      jf.constructor_.call(this, t.getCoordinates(), e)
    } else if (arguments[0] instanceof Array && 'number' == typeof arguments[1]) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._srcPts = t), (this._isClosed = jf.isClosed(t)), (this._snapTolerance = e)
    }
  }
  static isClosed(t) {
    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
  }
  snapVertices(t, e) {
    const n = this._isClosed ? t.size() - 1 : t.size()
    for (let i = 0; i < n; i++) {
      const n = t.get(i),
        s = this.findSnapForVertex(n, e)
      null !== s &&
        (t.set(i, new Oc(s)), 0 === i && this._isClosed && t.set(t.size() - 1, new Oc(s)))
    }
  }
  findSnapForVertex(t, e) {
    for (let n = 0; n < e.length; n++) {
      if (t.equals2D(e[n])) return null
      if (t.distance(e[n]) < this._snapTolerance) return e[n]
    }
    return null
  }
  snapTo(t) {
    const e = new qc(this._srcPts)
    this.snapVertices(e, t), this.snapSegments(e, t)
    return e.toCoordinateArray()
  }
  snapSegments(t, e) {
    if (0 === e.length) return null
    let n = e.length
    e[0].equals2D(e[e.length - 1]) && (n = e.length - 1)
    for (let i = 0; i < n; i++) {
      const n = e[i],
        s = this.findSegmentIndexToSnap(n, t)
      s >= 0 && t.add(s + 1, new Oc(n), !1)
    }
  }
  findSegmentIndexToSnap(t, e) {
    let n = Mc.MAX_VALUE,
      i = -1
    for (let s = 0; s < e.size() - 1; s++) {
      if (
        ((this._seg.p0 = e.get(s)),
        (this._seg.p1 = e.get(s + 1)),
        this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t))
      ) {
        if (this._allowSnappingToSourceVertices) continue
        return -1
      }
      const r = this._seg.distance(t)
      r < this._snapTolerance && r < n && ((n = r), (i = s))
    }
    return i
  }
  setAllowSnappingToSourceVertices(t) {
    this._allowSnappingToSourceVertices = t
  }
}
class qf {
  constructor() {
    qf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._srcGeom = null
    const t = arguments[0]
    this._srcGeom = t
  }
  static snap(t, e, n) {
    const i = new Array(2).fill(null),
      s = new qf(t)
    i[0] = s.snapTo(e, n)
    const r = new qf(e)
    return (i[1] = r.snapTo(i[0], n)), i
  }
  static computeOverlaySnapTolerance() {
    if (1 === arguments.length) {
      const t = arguments[0]
      let e = qf.computeSizeBasedSnapTolerance(t)
      const n = t.getPrecisionModel()
      if (n.getType() === Uu.FIXED) {
        const t = ((1 / n.getScale()) * 2) / 1.415
        t > e && (e = t)
      }
      return e
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return Math.min(qf.computeOverlaySnapTolerance(t), qf.computeOverlaySnapTolerance(e))
    }
  }
  static computeSizeBasedSnapTolerance(t) {
    const e = t.getEnvelopeInternal()
    return Math.min(e.getHeight(), e.getWidth()) * qf.SNAP_PRECISION_FACTOR
  }
  static snapToSelf(t, e, n) {
    return new qf(t).snapToSelf(e, n)
  }
  snapTo(t, e) {
    const n = this.extractTargetCoordinates(t)
    return new Zf(e, n).transform(this._srcGeom)
  }
  snapToSelf(t, e) {
    const n = this.extractTargetCoordinates(this._srcGeom),
      i = new Zf(t, n, !0).transform(this._srcGeom)
    let s = i
    return e && Uc(s, wu) && (s = i.buffer(0)), s
  }
  computeSnapTolerance(t) {
    return this.computeMinimumSegmentLength(t) / 10
  }
  extractTargetCoordinates(t) {
    const e = new Su(),
      n = t.getCoordinates()
    for (let t = 0; t < n.length; t++) e.add(n[t])
    return e.toArray(new Array(0).fill(null))
  }
  computeMinimumSegmentLength(t) {
    let e = Mc.MAX_VALUE
    for (let n = 0; n < t.length - 1; n++) {
      const i = t[n].distance(t[n + 1])
      i < e && (e = i)
    }
    return e
  }
}
qf.SNAP_PRECISION_FACTOR = 1e-9
class Zf extends Nd {
  constructor() {
    super(), Zf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._snapTolerance = null),
      (this._snapPts = null),
      (this._isSelfSnap = !1),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._snapTolerance = t), (this._snapPts = e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._snapTolerance = t), (this._snapPts = e), (this._isSelfSnap = n)
    }
  }
  snapLine(t, e) {
    const n = new jf(t, this._snapTolerance)
    return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e)
  }
  transformCoordinates(t, e) {
    const n = t.toCoordinateArray(),
      i = this.snapLine(n, this._snapPts)
    return this._factory.getCoordinateSequenceFactory().create(i)
  }
}
var Xf = Object.freeze({ __proto__: null, GeometrySnapper: qf, LineStringSnapper: jf })
class Kf {
  constructor() {
    Kf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pts = null), (this._data = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._pts = t), (this._data = e)
  }
  getCoordinates() {
    return this._pts
  }
  size() {
    return this._pts.length
  }
  getCoordinate(t) {
    return this._pts[t]
  }
  isClosed() {
    return this._pts[0].equals(this._pts[this._pts.length - 1])
  }
  getSegmentOctant(t) {
    return t === this._pts.length - 1
      ? -1
      : Cg.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
  }
  setData(t) {
    this._data = t
  }
  getData() {
    return this._data
  }
  toString() {
    return hd.toLineString(new Pu(this._pts))
  }
  get interfaces_() {
    return [Ng]
  }
}
class Jf {
  constructor() {
    Jf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._findAllIntersections = !1),
      (this._isCheckEndSegmentsOnly = !1),
      (this._keepIntersections = !0),
      (this._isInteriorIntersectionsOnly = !1),
      (this._li = null),
      (this._interiorIntersection = null),
      (this._intSegments = null),
      (this._intersections = new Yc()),
      (this._intersectionCount = 0)
    const t = arguments[0]
    ;(this._li = t), (this._interiorIntersection = null)
  }
  static createAllIntersectionsFinder(t) {
    const e = new Jf(t)
    return e.setFindAllIntersections(!0), e
  }
  static isInteriorVertexIntersection() {
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[3]
      return (!arguments[2] || !n) && !!t.equals2D(e)
    }
    if (8 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5],
        o = arguments[6],
        a = arguments[7]
      return (
        !!Jf.isInteriorVertexIntersection(t, n, s, o) ||
        !!Jf.isInteriorVertexIntersection(t, i, s, a) ||
        !!Jf.isInteriorVertexIntersection(e, n, r, o) ||
        !!Jf.isInteriorVertexIntersection(e, i, r, a)
      )
    }
  }
  static createInteriorIntersectionCounter(t) {
    const e = new Jf(t)
    return (
      e.setInteriorIntersectionsOnly(!0),
      e.setFindAllIntersections(!0),
      e.setKeepIntersections(!1),
      e
    )
  }
  static createIntersectionCounter(t) {
    const e = new Jf(t)
    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
  }
  static isEndSegment(t, e) {
    return 0 === e || e >= t.size() - 2
  }
  static createAnyIntersectionFinder(t) {
    return new Jf(t)
  }
  static createInteriorIntersectionsFinder(t) {
    const e = new Jf(t)
    return e.setFindAllIntersections(!0), e.setInteriorIntersectionsOnly(!0), e
  }
  setCheckEndSegmentsOnly(t) {
    this._isCheckEndSegmentsOnly = t
  }
  getIntersectionSegments() {
    return this._intSegments
  }
  count() {
    return this._intersectionCount
  }
  getIntersections() {
    return this._intersections
  }
  setFindAllIntersections(t) {
    this._findAllIntersections = t
  }
  setKeepIntersections(t) {
    this._keepIntersections = t
  }
  getIntersection() {
    return this._interiorIntersection
  }
  processIntersections(t, e, n, i) {
    if (!this._findAllIntersections && this.hasIntersection()) return null
    const s = t === n
    if (s && e === i) return null
    if (this._isCheckEndSegmentsOnly) {
      if (!(Jf.isEndSegment(t, e) || Jf.isEndSegment(n, i))) return null
    }
    const r = t.getCoordinate(e),
      o = t.getCoordinate(e + 1),
      a = n.getCoordinate(i),
      l = n.getCoordinate(i + 1),
      h = 0 === e,
      c = e + 2 === t.size(),
      u = 0 === i,
      d = i + 2 === n.size()
    this._li.computeIntersection(r, o, a, l)
    const p = this._li.hasIntersection() && this._li.isInteriorIntersection()
    let g = !1
    if (!this._isInteriorIntersectionsOnly) {
      g = !(s && Math.abs(i - e) <= 1) && Jf.isInteriorVertexIntersection(r, o, a, l, h, c, u, d)
    }
    ;(p || g) &&
      ((this._intSegments = new Array(4).fill(null)),
      (this._intSegments[0] = r),
      (this._intSegments[1] = o),
      (this._intSegments[2] = a),
      (this._intSegments[3] = l),
      (this._interiorIntersection = this._li.getIntersection(0)),
      this._keepIntersections && this._intersections.add(this._interiorIntersection),
      this._intersectionCount++)
  }
  hasIntersection() {
    return null !== this._interiorIntersection
  }
  isDone() {
    return !this._findAllIntersections && null !== this._interiorIntersection
  }
  setInteriorIntersectionsOnly(t) {
    this._isInteriorIntersectionsOnly = t
  }
  get interfaces_() {
    return [gf]
  }
}
class Qf {
  constructor() {
    Qf.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()),
      (this._segStrings = null),
      (this._findAllIntersections = !1),
      (this._segInt = null),
      (this._isValid = !0)
    const t = arguments[0]
    this._segStrings = t
  }
  static computeIntersections(t) {
    const e = new Qf(t)
    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
  }
  execute() {
    if (null !== this._segInt) return null
    this.checkInteriorIntersections()
  }
  getIntersections() {
    return this._segInt.getIntersections()
  }
  isValid() {
    return this.execute(), this._isValid
  }
  setFindAllIntersections(t) {
    this._findAllIntersections = t
  }
  checkInteriorIntersections() {
    ;(this._isValid = !0),
      (this._segInt = new Jf(this._li)),
      this._segInt.setFindAllIntersections(this._findAllIntersections)
    const t = new Ug()
    if (
      (t.setSegmentIntersector(this._segInt),
      t.computeNodes(this._segStrings),
      this._segInt.hasIntersection())
    )
      return (this._isValid = !1), null
  }
  checkValid() {
    if ((this.execute(), !this._isValid))
      throw new eg(this.getErrorMessage(), this._segInt.getIntersection())
  }
  getErrorMessage() {
    if (this._isValid) return 'no intersections found'
    const t = this._segInt.getIntersectionSegments()
    return (
      'found non-noded intersection between ' +
      hd.toLineString(t[0], t[1]) +
      ' and ' +
      hd.toLineString(t[2], t[3])
    )
  }
}
class $f {
  constructor() {
    $f.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._nv = null
    const t = arguments[0]
    this._nv = new Qf($f.toSegmentStrings(t))
  }
  static toSegmentStrings(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e.add(new Kf(t.getCoordinates(), t))
    }
    return e
  }
  static checkValid(t) {
    new $f(t).checkValid()
  }
  checkValid() {
    this._nv.checkValid()
  }
}
class tm {
  constructor() {
    tm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._op = null),
      (this._geometryFactory = null),
      (this._ptLocator = null),
      (this._lineEdgesList = new Yc()),
      (this._resultLineList = new Yc())
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2]
    ;(this._op = t), (this._geometryFactory = e), (this._ptLocator = n)
  }
  collectLines(t) {
    for (let e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext(); ) {
      const n = e.next()
      this.collectLineEdge(n, t, this._lineEdgesList),
        this.collectBoundaryTouchEdge(n, t, this._lineEdgesList)
    }
  }
  labelIsolatedLine(t, e) {
    const n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e))
    t.getLabel().setLocation(e, n)
  }
  build(t) {
    return (
      this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList
    )
  }
  collectLineEdge(t, e, n) {
    const i = t.getLabel(),
      s = t.getEdge()
    t.isLineEdge() &&
      (t.isVisited() || !hm.isResultOfOp(i, e) || s.isCovered() || (n.add(s), t.setVisitedEdge(!0)))
  }
  findCoveredLineEdges() {
    for (let t = this._op.getGraph().getNodes().iterator(); t.hasNext(); ) {
      t.next().getEdges().findCoveredLineEdges()
    }
    for (let t = this._op.getGraph().getEdgeEnds().iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getEdge()
      if (e.isLineEdge() && !n.isCoveredSet()) {
        const t = this._op.isCoveredByA(e.getCoordinate())
        n.setCovered(t)
      }
    }
  }
  labelIsolatedLines(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next(),
        n = t.getLabel()
      t.isIsolated() && (n.isNull(0) ? this.labelIsolatedLine(t, 0) : this.labelIsolatedLine(t, 1))
    }
  }
  buildLines(t) {
    for (let t = this._lineEdgesList.iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = this._geometryFactory.createLineString(e.getCoordinates())
      this._resultLineList.add(n), e.setInResult(!0)
    }
  }
  collectBoundaryTouchEdge(t, e, n) {
    const i = t.getLabel()
    return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult()
      ? null
      : (Cc.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()),
        void (
          hm.isResultOfOp(i, e) &&
          e === hm.INTERSECTION &&
          (n.add(t.getEdge()), t.setVisitedEdge(!0))
        ))
  }
}
class em {
  constructor() {
    em.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._op = null), (this._geometryFactory = null), (this._resultPointList = new Yc())
    const t = arguments[0],
      e = arguments[1]
    ;(this._op = t), (this._geometryFactory = e)
  }
  filterCoveredNodeToPoint(t) {
    const e = t.getCoordinate()
    if (!this._op.isCoveredByLA(e)) {
      const t = this._geometryFactory.createPoint(e)
      this._resultPointList.add(t)
    }
  }
  extractNonCoveredResultNodes(t) {
    for (let e = this._op.getGraph().getNodes().iterator(); e.hasNext(); ) {
      const n = e.next()
      if (
        !n.isInResult() &&
        !n.isIncidentEdgeInResult() &&
        (0 === n.getEdges().getDegree() || t === hm.INTERSECTION)
      ) {
        const e = n.getLabel()
        hm.isResultOfOp(e, t) && this.filterCoveredNodeToPoint(n)
      }
    }
  }
  build(t) {
    return this.extractNonCoveredResultNodes(t), this._resultPointList
  }
}
class nm {
  constructor() {
    ;(this._isFirst = !0),
      (this._commonMantissaBitsCount = 53),
      (this._commonBits = new bc()),
      (this._commonSignExp = null)
  }
  getCommon() {
    return Mc.longBitsToDouble(this._commonBits)
  }
  add(t) {
    const e = Mc.doubleToLongBits(t)
    if (this._isFirst)
      return (
        (this._commonBits = e),
        (this._commonSignExp = nm.signExpBits(this._commonBits)),
        (this._isFirst = !1),
        null
      )
    if (nm.signExpBits(e) !== this._commonSignExp)
      return (this._commonBits.high = 0), (this._commonBits.low = 0), null
    ;(this._commonMantissaBitsCount = nm.numCommonMostSigMantissaBits(this._commonBits, e)),
      (this._commonBits = nm.zeroLowerBits(
        this._commonBits,
        64 - (12 + this._commonMantissaBitsCount)
      ))
  }
  toString() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = Mc.longBitsToDouble(t),
        n =
          '0000000000000000000000000000000000000000000000000000000000000000' + bc.toBinaryString(t),
        i = n.substring(n.length - 64)
      return (
        i.substring(0, 1) +
        '  ' +
        i.substring(1, 12) +
        '(exp) ' +
        i.substring(12) +
        ' [ ' +
        e +
        ' ]'
      )
    }
  }
  getClass() {
    return nm
  }
  get interfaces_() {
    return []
  }
  static getBit(t, e) {
    const n = 1 << e % 32
    return e < 32 ? (0 != (t.low & n) ? 1 : 0) : 0 != (t.high & n) ? 1 : 0
  }
  static signExpBits(t) {
    return t.high >>> 20
  }
  static zeroLowerBits(t, e) {
    let n = 'low'
    if ((e > 32 && ((t.low = 0), (e %= 32), (n = 'high')), e > 0)) {
      const i = e < 32 ? ~((1 << e) - 1) : 0
      t[n] &= i
    }
    return t
  }
  static numCommonMostSigMantissaBits(t, e) {
    let n = 0
    for (let i = 52; i >= 0; i--) {
      if (nm.getBit(t, i) !== nm.getBit(e, i)) return n
      n++
    }
    return 52
  }
}
class im {
  constructor() {
    im.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._commonCoord = null), (this._ccFilter = new sm())
  }
  addCommonBits(t) {
    const e = new rm(this._commonCoord)
    t.apply(e), t.geometryChanged()
  }
  removeCommonBits(t) {
    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t
    const e = new Oc(this._commonCoord)
    ;(e.x = -e.x), (e.y = -e.y)
    const n = new rm(e)
    return t.apply(n), t.geometryChanged(), t
  }
  getCommonCoordinate() {
    return this._commonCoord
  }
  add(t) {
    t.apply(this._ccFilter), (this._commonCoord = this._ccFilter.getCommonCoordinate())
  }
}
class sm {
  constructor() {
    sm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._commonBitsX = new nm()), (this._commonBitsY = new nm())
  }
  filter(t) {
    this._commonBitsX.add(t.x), this._commonBitsY.add(t.y)
  }
  getCommonCoordinate() {
    return new Oc(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
  }
  get interfaces_() {
    return [cu]
  }
}
class rm {
  constructor() {
    rm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.trans = null
    const t = arguments[0]
    this.trans = t
  }
  filter(t, e) {
    const n = t.getOrdinate(e, 0) + this.trans.x,
      i = t.getOrdinate(e, 1) + this.trans.y
    t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i)
  }
  isDone() {
    return !1
  }
  isGeometryChanged() {
    return !0
  }
  get interfaces_() {
    return [Zc]
  }
}
;(im.CommonCoordinateFilter = sm), (im.Translater = rm)
class om {
  constructor() {
    om.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geom = new Array(2).fill(null)), (this._snapTolerance = null), (this._cbr = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._geom[0] = t), (this._geom[1] = e), this.computeSnapTolerance()
  }
  static overlayOp(t, e, n) {
    return new om(t, e).getResultGeometry(n)
  }
  static union(t, e) {
    return om.overlayOp(t, e, hm.UNION)
  }
  static intersection(t, e) {
    return om.overlayOp(t, e, hm.INTERSECTION)
  }
  static symDifference(t, e) {
    return om.overlayOp(t, e, hm.SYMDIFFERENCE)
  }
  static difference(t, e) {
    return om.overlayOp(t, e, hm.DIFFERENCE)
  }
  selfSnap(t) {
    return new qf(t).snapTo(t, this._snapTolerance)
  }
  removeCommonBits(t) {
    ;(this._cbr = new im()), this._cbr.add(t[0]), this._cbr.add(t[1])
    const e = new Array(2).fill(null)
    return (
      (e[0] = this._cbr.removeCommonBits(t[0].copy())),
      (e[1] = this._cbr.removeCommonBits(t[1].copy())),
      e
    )
  }
  prepareResult(t) {
    return this._cbr.addCommonBits(t), t
  }
  getResultGeometry(t) {
    const e = this.snap(this._geom),
      n = hm.overlayOp(e[0], e[1], t)
    return this.prepareResult(n)
  }
  checkValid(t) {
    t.isValid() || su.out.println('Snapped geometry is invalid')
  }
  computeSnapTolerance() {
    this._snapTolerance = qf.computeOverlaySnapTolerance(this._geom[0], this._geom[1])
  }
  snap(t) {
    const e = this.removeCommonBits(t)
    return qf.snap(e[0], e[1], this._snapTolerance)
  }
}
class am {
  constructor() {
    am.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._geom = new Array(2).fill(null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._geom[0] = t), (this._geom[1] = e)
  }
  static overlayOp(t, e, n) {
    return new am(t, e).getResultGeometry(n)
  }
  static union(t, e) {
    return am.overlayOp(t, e, hm.UNION)
  }
  static intersection(t, e) {
    return am.overlayOp(t, e, hm.INTERSECTION)
  }
  static symDifference(t, e) {
    return am.overlayOp(t, e, hm.SYMDIFFERENCE)
  }
  static difference(t, e) {
    return am.overlayOp(t, e, hm.DIFFERENCE)
  }
  getResultGeometry(t) {
    let e = null,
      n = !1,
      i = null
    try {
      e = hm.overlayOp(this._geom[0], this._geom[1], t)
      !0 && (n = !0)
    } catch (t) {
      if (!(t instanceof Rc)) throw t
      i = t
    }
    if (!n)
      try {
        e = om.overlayOp(this._geom[0], this._geom[1], t)
      } catch (t) {
        throw t instanceof Rc ? i : t
      }
    return e
  }
}
class lm {
  constructor() {
    lm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._li = new ud()),
      (this._resultPrecisionModel = null),
      (this._arg = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      this.setComputationPrecision(t.getPrecisionModel()),
        (this._arg = new Array(1).fill(null)),
        (this._arg[0] = new rg(0, t))
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      lm.constructor_.call(this, t, e, wp.OGC_SFS_BOUNDARY_RULE)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      t.getPrecisionModel().compareTo(e.getPrecisionModel()) >= 0
        ? this.setComputationPrecision(t.getPrecisionModel())
        : this.setComputationPrecision(e.getPrecisionModel()),
        (this._arg = new Array(2).fill(null)),
        (this._arg[0] = new rg(0, t, n)),
        (this._arg[1] = new rg(1, e, n))
    }
  }
  getArgGeometry(t) {
    return this._arg[t].getGeometry()
  }
  setComputationPrecision(t) {
    ;(this._resultPrecisionModel = t), this._li.setPrecisionModel(this._resultPrecisionModel)
  }
}
class hm extends lm {
  constructor() {
    super(), hm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._ptLocator = new Ap()),
      (this._geomFact = null),
      (this._resultGeom = null),
      (this._graph = null),
      (this._edgeList = new pf()),
      (this._resultPolyList = new Yc()),
      (this._resultLineList = new Yc()),
      (this._resultPointList = new Yc())
    const t = arguments[0],
      e = arguments[1]
    lm.constructor_.call(this, t, e),
      (this._graph = new sg(new uf())),
      (this._geomFact = t.getFactory())
  }
  static overlayOp(t, e, n) {
    return new hm(t, e).getResultGeometry(n)
  }
  static union(t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty()) return hm.createEmptyResult(hm.UNION, t, e, t.getFactory())
      if (t.isEmpty()) return e.copy()
      if (e.isEmpty()) return t.copy()
    }
    if (t.isGeometryCollection() || e.isGeometryCollection())
      throw new Ec('This method does not support GeometryCollection arguments')
    return am.overlayOp(t, e, hm.UNION)
  }
  static intersection(t, e) {
    if (t.isEmpty() || e.isEmpty())
      return hm.createEmptyResult(hm.INTERSECTION, t, e, t.getFactory())
    if (t.isGeometryCollection()) {
      const n = e
      return Sd.map(
        t,
        new (class {
          get interfaces_() {
            return [MapOp]
          }
          map(t) {
            return hm.intersection(t, n)
          }
        })()
      )
    }
    return am.overlayOp(t, e, hm.INTERSECTION)
  }
  static symDifference(t, e) {
    if (t.isEmpty() || e.isEmpty()) {
      if (t.isEmpty() && e.isEmpty())
        return hm.createEmptyResult(hm.SYMDIFFERENCE, t, e, t.getFactory())
      if (t.isEmpty()) return e.copy()
      if (e.isEmpty()) return t.copy()
    }
    if (t.isGeometryCollection() || e.isGeometryCollection())
      throw new Ec('This method does not support GeometryCollection arguments')
    return am.overlayOp(t, e, hm.SYMDIFFERENCE)
  }
  static resultDimension(t, e, n) {
    const i = e.getDimension(),
      s = n.getDimension()
    let r = -1
    switch (t) {
      case hm.INTERSECTION:
        r = Math.min(i, s)
        break
      case hm.UNION:
        r = Math.max(i, s)
        break
      case hm.DIFFERENCE:
        r = i
        break
      case hm.SYMDIFFERENCE:
        r = Math.max(i, s)
    }
    return r
  }
  static createEmptyResult(t, e, n, i) {
    const s = hm.resultDimension(t, e, n)
    return i.createEmpty(s)
  }
  static difference(t, e) {
    if (t.isEmpty()) return hm.createEmptyResult(hm.DIFFERENCE, t, e, t.getFactory())
    if (e.isEmpty()) return t.copy()
    if (t.isGeometryCollection() || e.isGeometryCollection())
      throw new Ec('This method does not support GeometryCollection arguments')
    return am.overlayOp(t, e, hm.DIFFERENCE)
  }
  static isResultOfOp() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = t.getLocation(0),
        i = t.getLocation(1)
      return hm.isResultOfOp(n, i, e)
    }
    if (3 === arguments.length) {
      let t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      switch ((t === pd.BOUNDARY && (t = pd.INTERIOR), e === pd.BOUNDARY && (e = pd.INTERIOR), n)) {
        case hm.INTERSECTION:
          return t === pd.INTERIOR && e === pd.INTERIOR
        case hm.UNION:
          return t === pd.INTERIOR || e === pd.INTERIOR
        case hm.DIFFERENCE:
          return t === pd.INTERIOR && e !== pd.INTERIOR
        case hm.SYMDIFFERENCE:
          return (
            (t === pd.INTERIOR && e !== pd.INTERIOR) || (t !== pd.INTERIOR && e === pd.INTERIOR)
          )
      }
      return !1
    }
  }
  insertUniqueEdge(t) {
    const e = this._edgeList.findEqualEdge(t)
    if (null !== e) {
      const n = e.getLabel()
      let i = t.getLabel()
      e.isPointwiseEqual(t) || ((i = new Fp(t.getLabel())), i.flip())
      const s = e.getDepth()
      s.isNull() && s.add(n), s.add(i), n.merge(i)
    } else this._edgeList.add(t)
  }
  getGraph() {
    return this._graph
  }
  cancelDuplicateResultEdges() {
    for (let t = this._graph.getEdgeEnds().iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getSym()
      e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
    }
  }
  isCoveredByLA(t) {
    return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList)
  }
  computeGeometry(t, e, n, i) {
    const s = new Yc()
    return (
      s.addAll(t),
      s.addAll(e),
      s.addAll(n),
      s.isEmpty()
        ? hm.createEmptyResult(
            i,
            this._arg[0].getGeometry(),
            this._arg[1].getGeometry(),
            this._geomFact
          )
        : this._geomFact.buildGeometry(s)
    )
  }
  mergeSymLabels() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      t.next().getEdges().mergeSymLabels()
    }
  }
  isCovered(t, e) {
    for (let n = e.iterator(); n.hasNext(); ) {
      const e = n.next()
      if (this._ptLocator.locate(t, e) !== pd.EXTERIOR) return !0
    }
    return !1
  }
  replaceCollapsedEdges() {
    const t = new Yc()
    for (let e = this._edgeList.iterator(); e.hasNext(); ) {
      const n = e.next()
      n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
    }
    this._edgeList.addAll(t)
  }
  updateNodeLabelling() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getEdges().getLabel()
      e.getLabel().merge(n)
    }
  }
  getResultGeometry(t) {
    return this.computeOverlay(t), this._resultGeom
  }
  insertUniqueEdges(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this.insertUniqueEdge(t)
    }
  }
  computeOverlay(t) {
    this.copyPoints(0),
      this.copyPoints(1),
      this._arg[0].computeSelfNodes(this._li, !1),
      this._arg[1].computeSelfNodes(this._li, !1),
      this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0)
    const e = new Yc()
    this._arg[0].computeSplitEdges(e),
      this._arg[1].computeSplitEdges(e),
      this.insertUniqueEdges(e),
      this.computeLabelsFromDepths(),
      this.replaceCollapsedEdges(),
      $f.checkValid(this._edgeList.getEdges()),
      this._graph.addEdges(this._edgeList.getEdges()),
      this.computeLabelling(),
      this.labelIncompleteNodes(),
      this.findResultAreaEdges(t),
      this.cancelDuplicateResultEdges()
    const n = new tf(this._geomFact)
    n.add(this._graph), (this._resultPolyList = n.getPolygons())
    const i = new tm(this, this._geomFact, this._ptLocator)
    this._resultLineList = i.build(t)
    const s = new em(this, this._geomFact, this._ptLocator)
    ;(this._resultPointList = s.build(t)),
      (this._resultGeom = this.computeGeometry(
        this._resultPointList,
        this._resultLineList,
        this._resultPolyList,
        t
      ))
  }
  labelIncompleteNode(t, e) {
    const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry())
    t.getLabel().setLocation(e, n)
  }
  copyPoints(t) {
    for (let e = this._arg[t].getNodeIterator(); e.hasNext(); ) {
      const n = e.next()
      this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
    }
  }
  findResultAreaEdges(t) {
    for (let e = this._graph.getEdgeEnds().iterator(); e.hasNext(); ) {
      const n = e.next(),
        i = n.getLabel()
      i.isArea() &&
        !n.isInteriorAreaEdge() &&
        hm.isResultOfOp(i.getLocation(0, Lp.RIGHT), i.getLocation(1, Lp.RIGHT), t) &&
        n.setInResult(!0)
    }
  }
  computeLabelsFromDepths() {
    for (let t = this._edgeList.iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getLabel(),
        i = e.getDepth()
      if (!i.isNull()) {
        i.normalize()
        for (let t = 0; t < 2; t++)
          n.isNull(t) ||
            !n.isArea() ||
            i.isNull(t) ||
            (0 === i.getDelta(t)
              ? n.toLine(t)
              : (Cc.isTrue(!i.isNull(t, Lp.LEFT), 'depth of LEFT side has not been initialized'),
                n.setLocation(t, Lp.LEFT, i.getLocation(t, Lp.LEFT)),
                Cc.isTrue(!i.isNull(t, Lp.RIGHT), 'depth of RIGHT side has not been initialized'),
                n.setLocation(t, Lp.RIGHT, i.getLocation(t, Lp.RIGHT))))
      }
    }
  }
  computeLabelling() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      t.next().getEdges().computeLabelling(this._arg)
    }
    this.mergeSymLabels(), this.updateNodeLabelling()
  }
  labelIncompleteNodes() {
    for (let t = this._graph.getNodes().iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getLabel()
      e.isIsolated() &&
        (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)),
        e.getEdges().updateLabelling(n)
    }
  }
  isCoveredByA(t) {
    return !!this.isCovered(t, this._resultPolyList)
  }
}
;(hm.INTERSECTION = 1), (hm.UNION = 2), (hm.DIFFERENCE = 3), (hm.SYMDIFFERENCE = 4)
var cm = Object.freeze({ __proto__: null, snap: Xf, OverlayOp: hm })
class um extends Nf {
  constructor() {
    super(), um.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._edgeRing = null), (this._next = null), (this._label = -1)
    const t = arguments[0],
      e = arguments[1],
      n = arguments[2],
      i = arguments[3]
    Nf.constructor_.call(this, t, e, n, i)
  }
  getNext() {
    return this._next
  }
  isInRing() {
    return null !== this._edgeRing
  }
  setRing(t) {
    this._edgeRing = t
  }
  setLabel(t) {
    this._label = t
  }
  getLabel() {
    return this._label
  }
  setNext(t) {
    this._next = t
  }
  getRing() {
    return this._edgeRing
  }
}
class dm extends Df {
  constructor() {
    super(), dm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._line = null
    const t = arguments[0]
    this._line = t
  }
  getLine() {
    return this._line
  }
}
class pm {
  constructor() {
    pm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geometryFactory = new ku()),
      (this._geomGraph = null),
      (this._disconnectedRingcoord = null)
    const t = arguments[0]
    this._geomGraph = t
  }
  static findDifferentPoint(t, e) {
    for (let n = 0; n < t.length; n++) if (!t[n].equals(e)) return t[n]
    return null
  }
  visitInteriorRing(t, e) {
    if (t.isEmpty()) return null
    const n = t.getCoordinates(),
      i = n[0],
      s = pm.findDifferentPoint(n, i),
      r = e.findEdgeInSameDirection(i, s),
      o = e.findEdgeEnd(r)
    let a = null
    o.getLabel().getLocation(0, Lp.RIGHT) === pd.INTERIOR
      ? (a = o)
      : o.getSym().getLabel().getLocation(0, Lp.RIGHT) === pd.INTERIOR && (a = o.getSym()),
      Cc.isTrue(null !== a, 'unable to find dirEdge with Interior on RHS'),
      this.visitLinkedDirectedEdges(a)
  }
  visitShellInteriors(t, e) {
    if (t instanceof Eu) {
      const n = t
      this.visitInteriorRing(n.getExteriorRing(), e)
    }
    if (t instanceof Ou) {
      const n = t
      for (let t = 0; t < n.getNumGeometries(); t++) {
        const i = n.getGeometryN(t)
        this.visitInteriorRing(i.getExteriorRing(), e)
      }
    }
  }
  getCoordinate() {
    return this._disconnectedRingcoord
  }
  setInteriorEdgesInResult(t) {
    for (let e = t.getEdgeEnds().iterator(); e.hasNext(); ) {
      const t = e.next()
      t.getLabel().getLocation(0, Lp.RIGHT) === pd.INTERIOR && t.setInResult(!0)
    }
  }
  visitLinkedDirectedEdges(t) {
    const e = t
    let n = t
    do {
      Cc.isTrue(null !== n, 'found null Directed Edge'), n.setVisited(!0), (n = n.getNext())
    } while (n !== e)
  }
  buildEdgeRings(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      if (t.isInResult() && null === t.getEdgeRing()) {
        const n = new $g(t, this._geometryFactory)
        n.linkDirectedEdgesForMinimalEdgeRings()
        const i = n.buildMinimalRings()
        e.addAll(i)
      }
    }
    return e
  }
  hasUnvisitedShellEdge(t) {
    for (let e = 0; e < t.size(); e++) {
      const n = t.get(e)
      if (n.isHole()) continue
      const i = n.getEdges()
      let s = i.get(0)
      if (s.getLabel().getLocation(0, Lp.RIGHT) === pd.INTERIOR)
        for (let t = 0; t < i.size(); t++)
          if (((s = i.get(t)), !s.isVisited()))
            return (this._disconnectedRingcoord = s.getCoordinate()), !0
    }
    return !1
  }
  isInteriorsConnected() {
    const t = new Yc()
    this._geomGraph.computeSplitEdges(t)
    const e = new sg(new uf())
    e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges()
    const n = this.buildEdgeRings(e.getEdgeEnds())
    return (
      this.visitShellInteriors(this._geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n)
    )
  }
}
class gm {
  createEdgeEndForNext(t, e, n, i) {
    const s = n.segmentIndex + 1
    if (s >= t.getNumPoints() && null === i) return null
    let r = t.getCoordinate(s)
    null !== i && i.segmentIndex === n.segmentIndex && (r = i.coord)
    const o = new tg(t, n.coord, r, new Fp(t.getLabel()))
    e.add(o)
  }
  createEdgeEndForPrev(t, e, n, i) {
    let s = n.segmentIndex
    if (0 === n.dist) {
      if (0 === s) return null
      s--
    }
    let r = t.getCoordinate(s)
    null !== i && i.segmentIndex >= s && (r = i.coord)
    const o = new Fp(t.getLabel())
    o.flip()
    const a = new tg(t, n.coord, r, o)
    e.add(a)
  }
  computeEdgeEnds() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new Yc()
      for (let n = t; n.hasNext(); ) {
        const t = n.next()
        this.computeEdgeEnds(t, e)
      }
      return e
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = t.getEdgeIntersectionList()
      n.addEndpoints()
      const i = n.iterator()
      let s = null,
        r = null
      if (!i.hasNext()) return null
      let o = i.next()
      do {
        ;(s = r),
          (r = o),
          (o = null),
          i.hasNext() && (o = i.next()),
          null !== r &&
            (this.createEdgeEndForPrev(t, e, r, s), this.createEdgeEndForNext(t, e, r, o))
      } while (null !== r)
    }
  }
}
class fm extends tg {
  constructor() {
    super(), fm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._edgeEnds = new Yc()), 1 === arguments.length)) {
      const t = arguments[0]
      fm.constructor_.call(this, null, t)
    } else if (2 === arguments.length) {
      const t = arguments[1]
      tg.constructor_.call(
        this,
        t.getEdge(),
        t.getCoordinate(),
        t.getDirectedCoordinate(),
        new Fp(t.getLabel())
      ),
        this.insert(t)
    }
  }
  insert(t) {
    this._edgeEnds.add(t)
  }
  print(t) {
    t.println('EdgeEndBundle--\x3e Label: ' + this._label)
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().print(t), t.println()
    }
  }
  iterator() {
    return this._edgeEnds.iterator()
  }
  getEdgeEnds() {
    return this._edgeEnds
  }
  computeLabelOn(t, e) {
    let n = 0,
      i = !1
    for (let e = this.iterator(); e.hasNext(); ) {
      const s = e.next().getLabel().getLocation(t)
      s === pd.BOUNDARY && n++, s === pd.INTERIOR && (i = !0)
    }
    let s = pd.NONE
    i && (s = pd.INTERIOR), n > 0 && (s = rg.determineBoundary(e, n)), this._label.setLocation(t, s)
  }
  computeLabelSide(t, e) {
    for (let n = this.iterator(); n.hasNext(); ) {
      const i = n.next()
      if (i.getLabel().isArea()) {
        const n = i.getLabel().getLocation(t, e)
        if (n === pd.INTERIOR) return this._label.setLocation(t, e, pd.INTERIOR), null
        n === pd.EXTERIOR && this._label.setLocation(t, e, pd.EXTERIOR)
      }
    }
  }
  getLabel() {
    return this._label
  }
  computeLabelSides(t) {
    this.computeLabelSide(t, Lp.LEFT), this.computeLabelSide(t, Lp.RIGHT)
  }
  updateIM(t) {
    Jp.updateIM(this._label, t)
  }
  computeLabel(t) {
    let e = !1
    for (let t = this.iterator(); t.hasNext(); ) {
      t.next().getLabel().isArea() && (e = !0)
    }
    this._label = e ? new Fp(pd.NONE, pd.NONE, pd.NONE) : new Fp(pd.NONE)
    for (let n = 0; n < 2; n++) this.computeLabelOn(n, t), e && this.computeLabelSides(n)
  }
}
class mm extends hf {
  constructor() {
    super()
  }
  updateIM(t) {
    for (let e = this.iterator(); e.hasNext(); ) {
      e.next().updateIM(t)
    }
  }
  insert(t) {
    let e = this._edgeMap.get(t)
    null === e ? ((e = new fm(t)), this.insertEdgeEnd(t, e)) : e.insert(t)
  }
}
class ym extends Qp {
  constructor() {
    super(), ym.constructor_.apply(this, arguments)
  }
  static constructor_() {
    const t = arguments[0],
      e = arguments[1]
    Qp.constructor_.call(this, t, e)
  }
  updateIMFromEdges(t) {
    this._edges.updateIM(t)
  }
  computeIM(t) {
    t.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0)
  }
}
class xm extends ig {
  constructor() {
    super()
  }
  createNode(t) {
    return new ym(t, new mm())
  }
}
class vm {
  constructor() {
    vm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._nodes = new $p(new xm())
  }
  insertEdgeEnds(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this._nodes.add(t)
    }
  }
  getNodeIterator() {
    return this._nodes.iterator()
  }
  copyNodesAndLabels(t, e) {
    for (let n = t.getNodeIterator(); n.hasNext(); ) {
      const t = n.next()
      this._nodes.addNode(t.getCoordinate()).setLabel(e, t.getLabel().getLocation(e))
    }
  }
  build(t) {
    this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0)
    const e = new gm().computeEdgeEnds(t.getEdgeIterator())
    this.insertEdgeEnds(e)
  }
  computeIntersectionNodes(t, e) {
    for (let n = t.getEdgeIterator(); n.hasNext(); ) {
      const t = n.next(),
        i = t.getLabel().getLocation(e)
      for (let n = t.getEdgeIntersectionList().iterator(); n.hasNext(); ) {
        const t = n.next(),
          s = this._nodes.addNode(t.coord)
        i === pd.BOUNDARY
          ? s.setLabelBoundary(e)
          : s.getLabel().isNull(e) && s.setLabel(e, pd.INTERIOR)
      }
    }
  }
}
class _m {
  constructor() {
    _m.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()),
      (this._geomGraph = null),
      (this._nodeGraph = new vm()),
      (this._invalidPoint = null)
    const t = arguments[0]
    this._geomGraph = t
  }
  isNodeEdgeAreaLabelsConsistent() {
    for (let t = this._nodeGraph.getNodeIterator(); t.hasNext(); ) {
      const e = t.next()
      if (!e.getEdges().isAreaLabelsConsistent(this._geomGraph))
        return (this._invalidPoint = e.getCoordinate().copy()), !1
    }
    return !0
  }
  getInvalidPoint() {
    return this._invalidPoint
  }
  hasDuplicateRings() {
    for (let t = this._nodeGraph.getNodeIterator(); t.hasNext(); ) {
      for (let e = t.next().getEdges().iterator(); e.hasNext(); ) {
        const t = e.next()
        if (t.getEdgeEnds().size() > 1)
          return (this._invalidPoint = t.getEdge().getCoordinate(0)), !0
      }
    }
    return !1
  }
  isNodeConsistentArea() {
    const t = this._geomGraph.computeSelfNodes(this._li, !0, !0)
    return t.hasProperIntersection()
      ? ((this._invalidPoint = t.getProperIntersectionPoint()), !1)
      : (this._nodeGraph.build(this._geomGraph), this.isNodeEdgeAreaLabelsConsistent())
  }
}
class wm {
  constructor() {
    wm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._graph = null),
      (this._rings = new Yc()),
      (this._totalEnv = new Xc()),
      (this._index = null),
      (this._nestedPt = null)
    const t = arguments[0]
    this._graph = t
  }
  buildIndex() {
    this._index = new Ag()
    for (let t = 0; t < this._rings.size(); t++) {
      const e = this._rings.get(t),
        n = e.getEnvelopeInternal()
      this._index.insert(n, e)
    }
  }
  getNestedPoint() {
    return this._nestedPt
  }
  isNonNested() {
    this.buildIndex()
    for (let t = 0; t < this._rings.size(); t++) {
      const e = this._rings.get(t),
        n = e.getCoordinates(),
        i = this._index.query(e.getEnvelopeInternal())
      for (let t = 0; t < i.size(); t++) {
        const s = i.get(t),
          r = s.getCoordinates()
        if (e === s) continue
        if (!e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())) continue
        const o = bm.findPtNotNode(n, s, this._graph)
        if (null === o) continue
        if (op.isInRing(o, r)) return (this._nestedPt = o), !1
      }
    }
    return !0
  }
  add(t) {
    this._rings.add(t), this._totalEnv.expandToInclude(t.getEnvelopeInternal())
  }
}
class Em {
  constructor() {
    Em.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._errorType = null), (this._pt = null), 1 === arguments.length)) {
      const t = arguments[0]
      Em.constructor_.call(this, t, null)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._errorType = t), null !== e && (this._pt = e.copy())
    }
  }
  getErrorType() {
    return this._errorType
  }
  getMessage() {
    return Em.errMsg[this._errorType]
  }
  getCoordinate() {
    return this._pt
  }
  toString() {
    let t = ''
    return null !== this._pt && (t = ' at or near point ' + this._pt), this.getMessage() + t
  }
}
;(Em.ERROR = 0),
  (Em.REPEATED_POINT = 1),
  (Em.HOLE_OUTSIDE_SHELL = 2),
  (Em.NESTED_HOLES = 3),
  (Em.DISCONNECTED_INTERIOR = 4),
  (Em.SELF_INTERSECTION = 5),
  (Em.RING_SELF_INTERSECTION = 6),
  (Em.NESTED_SHELLS = 7),
  (Em.DUPLICATE_RINGS = 8),
  (Em.TOO_FEW_POINTS = 9),
  (Em.INVALID_COORDINATE = 10),
  (Em.RING_NOT_CLOSED = 11),
  (Em.errMsg = [
    'Topology Validation Error',
    'Repeated Point',
    'Hole lies outside shell',
    'Holes are nested',
    'Interior is disconnected',
    'Self-intersection',
    'Ring Self-intersection',
    'Nested shells',
    'Duplicate Rings',
    'Too few distinct points in geometry component',
    'Invalid Coordinate',
    'Ring is not closed'
  ])
class bm {
  constructor() {
    bm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._parentGeometry = null),
      (this._isSelfTouchingRingFormingHoleValid = !1),
      (this._validErr = null)
    const t = arguments[0]
    this._parentGeometry = t
  }
  static findPtNotNode(t, e, n) {
    const i = n.findEdge(e).getEdgeIntersectionList()
    for (let e = 0; e < t.length; e++) {
      const n = t[e]
      if (!i.isIntersection(n)) return n
    }
    return null
  }
  static isValid() {
    if (arguments[0] instanceof hu) {
      return new bm(arguments[0]).isValid()
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      return !Mc.isNaN(t.x) && !Mc.isInfinite(t.x) && !Mc.isNaN(t.y) && !Mc.isInfinite(t.y)
    }
  }
  checkInvalidCoordinates() {
    if (arguments[0] instanceof Array) {
      const t = arguments[0]
      for (let e = 0; e < t.length; e++)
        if (!bm.isValid(t[e])) return (this._validErr = new Em(Em.INVALID_COORDINATE, t[e])), null
    } else if (arguments[0] instanceof Eu) {
      const t = arguments[0]
      if (
        (this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),
        null !== this._validErr)
      )
        return null
      for (let e = 0; e < t.getNumInteriorRing(); e++)
        if (
          (this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),
          null !== this._validErr)
        )
          return null
    }
  }
  checkHolesNotNested(t, e) {
    if (t.getNumInteriorRing() <= 0) return null
    const n = new wm(e)
    for (let e = 0; e < t.getNumInteriorRing(); e++) {
      const i = t.getInteriorRingN(e)
      i.isEmpty() || n.add(i)
    }
    n.isNonNested() || (this._validErr = new Em(Em.NESTED_HOLES, n.getNestedPoint()))
  }
  checkConsistentArea(t) {
    const e = new _m(t)
    if (!e.isNodeConsistentArea())
      return (this._validErr = new Em(Em.SELF_INTERSECTION, e.getInvalidPoint())), null
    e.hasDuplicateRings() && (this._validErr = new Em(Em.DUPLICATE_RINGS, e.getInvalidPoint()))
  }
  isValid() {
    return this.checkValid(this._parentGeometry), null === this._validErr
  }
  checkShellInsideHole(t, e, n) {
    const i = t.getCoordinates(),
      s = e.getCoordinates(),
      r = bm.findPtNotNode(i, e, n)
    if (null !== r) {
      if (!op.isInRing(r, s)) return r
    }
    const o = bm.findPtNotNode(s, t, n)
    if (null !== o) {
      return op.isInRing(o, i) ? o : null
    }
    return Cc.shouldNeverReachHere('points in shell and hole appear to be equal'), null
  }
  checkNoSelfIntersectingRings(t) {
    for (let e = t.getEdgeIterator(); e.hasNext(); ) {
      const t = e.next()
      if ((this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()), null !== this._validErr))
        return null
    }
  }
  checkConnectedInteriors(t) {
    const e = new pm(t)
    e.isInteriorsConnected() ||
      (this._validErr = new Em(Em.DISCONNECTED_INTERIOR, e.getCoordinate()))
  }
  checkNoSelfIntersectingRing(t) {
    const e = new Su()
    let n = !0
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      if (n) n = !1
      else {
        if (e.contains(t.coord))
          return (this._validErr = new Em(Em.RING_SELF_INTERSECTION, t.coord)), null
        e.add(t.coord)
      }
    }
  }
  checkHolesInShell(t, e) {
    if (t.getNumInteriorRing() <= 0) return null
    const n = t.getExteriorRing(),
      i = n.isEmpty(),
      s = new ip(n)
    for (let r = 0; r < t.getNumInteriorRing(); r++) {
      const o = t.getInteriorRingN(r)
      let a = null
      if (o.isEmpty()) continue
      if (((a = bm.findPtNotNode(o.getCoordinates(), n, e)), null === a)) return null
      if (i || pd.EXTERIOR === s.locate(a))
        return (this._validErr = new Em(Em.HOLE_OUTSIDE_SHELL, a)), null
    }
  }
  checkTooFewPoints(t) {
    if (t.hasTooFewPoints())
      return (this._validErr = new Em(Em.TOO_FEW_POINTS, t.getInvalidPoint())), null
  }
  getValidationError() {
    return this.checkValid(this._parentGeometry), this._validErr
  }
  checkValid() {
    if (arguments[0] instanceof xu) {
      const t = arguments[0]
      this.checkInvalidCoordinates(t.getCoordinates())
    } else if (arguments[0] instanceof Iu) {
      const t = arguments[0]
      this.checkInvalidCoordinates(t.getCoordinates())
    } else if (arguments[0] instanceof Ru) {
      const t = arguments[0]
      if ((this.checkInvalidCoordinates(t.getCoordinates()), null !== this._validErr)) return null
      if ((this.checkClosedRing(t), null !== this._validErr)) return null
      const e = new rg(0, t)
      if ((this.checkTooFewPoints(e), null !== this._validErr)) return null
      const n = new ud()
      e.computeSelfNodes(n, !0, !0), this.checkNoSelfIntersectingRings(e)
    } else if (arguments[0] instanceof mu) {
      const t = arguments[0]
      if ((this.checkInvalidCoordinates(t.getCoordinates()), null !== this._validErr)) return null
      const e = new rg(0, t)
      this.checkTooFewPoints(e)
    } else if (arguments[0] instanceof Eu) {
      const t = arguments[0]
      if ((this.checkInvalidCoordinates(t), null !== this._validErr)) return null
      if ((this.checkClosedRings(t), null !== this._validErr)) return null
      const e = new rg(0, t)
      if ((this.checkTooFewPoints(e), null !== this._validErr)) return null
      if ((this.checkConsistentArea(e), null !== this._validErr)) return null
      if (
        !this._isSelfTouchingRingFormingHoleValid &&
        (this.checkNoSelfIntersectingRings(e), null !== this._validErr)
      )
        return null
      if ((this.checkHolesInShell(t, e), null !== this._validErr)) return null
      if ((this.checkHolesNotNested(t, e), null !== this._validErr)) return null
      this.checkConnectedInteriors(e)
    } else if (arguments[0] instanceof Ou) {
      const t = arguments[0]
      for (let e = 0; e < t.getNumGeometries(); e++) {
        const n = t.getGeometryN(e)
        if ((this.checkInvalidCoordinates(n), null !== this._validErr)) return null
        if ((this.checkClosedRings(n), null !== this._validErr)) return null
      }
      const e = new rg(0, t)
      if ((this.checkTooFewPoints(e), null !== this._validErr)) return null
      if ((this.checkConsistentArea(e), null !== this._validErr)) return null
      if (
        !this._isSelfTouchingRingFormingHoleValid &&
        (this.checkNoSelfIntersectingRings(e), null !== this._validErr)
      )
        return null
      for (let n = 0; n < t.getNumGeometries(); n++) {
        const i = t.getGeometryN(n)
        if ((this.checkHolesInShell(i, e), null !== this._validErr)) return null
      }
      for (let n = 0; n < t.getNumGeometries(); n++) {
        const i = t.getGeometryN(n)
        if ((this.checkHolesNotNested(i, e), null !== this._validErr)) return null
      }
      if ((this.checkShellsNotNested(t, e), null !== this._validErr)) return null
      this.checkConnectedInteriors(e)
    } else if (arguments[0] instanceof Tu) {
      const t = arguments[0]
      for (let e = 0; e < t.getNumGeometries(); e++) {
        const n = t.getGeometryN(e)
        if ((this.checkValid(n), null !== this._validErr)) return null
      }
    } else if (arguments[0] instanceof hu) {
      const t = arguments[0]
      if (((this._validErr = null), t.isEmpty())) return null
      if (t instanceof xu) this.checkValid(t)
      else if (t instanceof Iu) this.checkValid(t)
      else if (t instanceof Ru) this.checkValid(t)
      else if (t instanceof mu) this.checkValid(t)
      else if (t instanceof Eu) this.checkValid(t)
      else if (t instanceof Ou) this.checkValid(t)
      else {
        if (!(t instanceof Tu)) throw new pu(t.getGeometryType())
        this.checkValid(t)
      }
    }
  }
  setSelfTouchingRingFormingHoleValid(t) {
    this._isSelfTouchingRingFormingHoleValid = t
  }
  checkShellNotNested(t, e, n) {
    const i = t.getCoordinates(),
      s = e.getExteriorRing()
    if (s.isEmpty()) return null
    const r = s.getCoordinates(),
      o = bm.findPtNotNode(i, s, n)
    if (null === o) return null
    if (!op.isInRing(o, r)) return null
    if (e.getNumInteriorRing() <= 0) return (this._validErr = new Em(Em.NESTED_SHELLS, o)), null
    let a = null
    for (let i = 0; i < e.getNumInteriorRing(); i++) {
      const s = e.getInteriorRingN(i)
      if (((a = this.checkShellInsideHole(t, s, n)), null === a)) return null
    }
    this._validErr = new Em(Em.NESTED_SHELLS, a)
  }
  checkClosedRings(t) {
    if ((this.checkClosedRing(t.getExteriorRing()), null !== this._validErr)) return null
    for (let e = 0; e < t.getNumInteriorRing(); e++)
      if ((this.checkClosedRing(t.getInteriorRingN(e)), null !== this._validErr)) return null
  }
  checkClosedRing(t) {
    if (t.isEmpty()) return null
    if (!t.isClosed()) {
      let e = null
      t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)),
        (this._validErr = new Em(Em.RING_NOT_CLOSED, e))
    }
  }
  checkShellsNotNested(t, e) {
    for (let n = 0; n < t.getNumGeometries(); n++) {
      const i = t.getGeometryN(n).getExteriorRing()
      for (let s = 0; s < t.getNumGeometries(); s++) {
        if (n === s) continue
        const r = t.getGeometryN(s)
        if ((this.checkShellNotNested(i, r, e), null !== this._validErr)) return null
      }
    }
  }
}
class Mm {
  constructor() {
    Mm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._factory = null),
      (this._deList = new Yc()),
      (this._lowestEdge = null),
      (this._ring = null),
      (this._locator = null),
      (this._ringPts = null),
      (this._holes = null),
      (this._shell = null),
      (this._isHole = null),
      (this._isProcessed = !1),
      (this._isIncludedSet = !1),
      (this._isIncluded = !1)
    const t = arguments[0]
    this._factory = t
  }
  static findDirEdgesInRing(t) {
    let e = t
    const n = new Yc()
    do {
      n.add(e),
        (e = e.getNext()),
        Cc.isTrue(null !== e, 'found null DE in ring'),
        Cc.isTrue(e === t || !e.isInRing(), 'found DE already in ring')
    } while (e !== t)
    return n
  }
  static addEdge(t, e, n) {
    if (e) for (let e = 0; e < t.length; e++) n.add(t[e], !1)
    else for (let e = t.length - 1; e >= 0; e--) n.add(t[e], !1)
  }
  static findEdgeRingContaining(t, e) {
    const n = t.getRing(),
      i = n.getEnvelopeInternal()
    let s = n.getCoordinateN(0),
      r = null,
      o = null
    for (let t = e.iterator(); t.hasNext(); ) {
      const e = t.next(),
        a = e.getRing().getEnvelopeInternal()
      if (a.equals(i)) continue
      if (!a.contains(i)) continue
      s = Cu.ptNotInList(n.getCoordinates(), e.getCoordinates())
      e.isInRing(s) &&
        (null === r || o.contains(a)) &&
        ((r = e), (o = r.getRing().getEnvelopeInternal()))
    }
    return r
  }
  isIncluded() {
    return this._isIncluded
  }
  getCoordinates() {
    if (null === this._ringPts) {
      const t = new qc()
      for (let e = this._deList.iterator(); e.hasNext(); ) {
        const n = e.next(),
          i = n.getEdge()
        Mm.addEdge(i.getLine().getCoordinates(), n.getEdgeDirection(), t)
      }
      this._ringPts = t.toCoordinateArray()
    }
    return this._ringPts
  }
  isIncludedSet() {
    return this._isIncludedSet
  }
  isValid() {
    return (
      this.getCoordinates(),
      !(this._ringPts.length <= 3) && (this.getRing(), bm.isValid(this._ring))
    )
  }
  build(t) {
    let e = t
    do {
      this.add(e),
        e.setRing(this),
        (e = e.getNext()),
        Cc.isTrue(null !== e, 'found null DE in ring'),
        Cc.isTrue(e === t || !e.isInRing(), 'found DE already in ring')
    } while (e !== t)
  }
  isInRing(t) {
    return pd.EXTERIOR !== this.getLocator().locate(t)
  }
  isOuterHole() {
    return !!this._isHole && !this.hasShell()
  }
  getPolygon() {
    let t = null
    if (null !== this._holes) {
      t = new Array(this._holes.size()).fill(null)
      for (let e = 0; e < this._holes.size(); e++) t[e] = this._holes.get(e)
    }
    return this._factory.createPolygon(this._ring, t)
  }
  isHole() {
    return this._isHole
  }
  isProcessed() {
    return this._isProcessed
  }
  addHole() {
    if (arguments[0] instanceof Ru) {
      const t = arguments[0]
      null === this._holes && (this._holes = new Yc()), this._holes.add(t)
    } else if (arguments[0] instanceof Mm) {
      const t = arguments[0]
      t.setShell(this)
      const e = t.getRing()
      null === this._holes && (this._holes = new Yc()), this._holes.add(e)
    }
  }
  setIncluded(t) {
    ;(this._isIncluded = t), (this._isIncludedSet = !0)
  }
  getOuterHole() {
    if (this.isHole()) return null
    for (let t = 0; t < this._deList.size(); t++) {
      const e = this._deList.get(t).getSym().getRing()
      if (e.isOuterHole()) return e
    }
    return null
  }
  computeHole() {
    const t = this.getRing()
    this._isHole = nu.isCCW(t.getCoordinates())
  }
  hasShell() {
    return null !== this._shell
  }
  isOuterShell() {
    return null !== this.getOuterHole()
  }
  getLineString() {
    return this.getCoordinates(), this._factory.createLineString(this._ringPts)
  }
  toString() {
    return hd.toLineString(new Pu(this.getCoordinates()))
  }
  getLocator() {
    return null === this._locator && (this._locator = new ip(this.getRing())), this._locator
  }
  getShell() {
    return this.isHole() ? this._shell : this
  }
  add(t) {
    this._deList.add(t)
  }
  getRing() {
    if (null !== this._ring) return this._ring
    this.getCoordinates(), this._ringPts.length < 3 && su.out.println(this._ringPts)
    try {
      this._ring = this._factory.createLinearRing(this._ringPts)
    } catch (t) {
      if (!(t instanceof wc)) throw t
      su.out.println(this._ringPts)
    }
    return this._ring
  }
  updateIncluded() {
    if (this.isHole()) return null
    for (let t = 0; t < this._deList.size(); t++) {
      const e = this._deList.get(t).getSym().getRing().getShell()
      if (null !== e && e.isIncludedSet()) return this.setIncluded(!e.isIncluded()), null
    }
  }
  setShell(t) {
    this._shell = t
  }
  setProcessed(t) {
    this._isProcessed = t
  }
}
Mm.EnvelopeComparator = class {
  compare(t, e) {
    const n = e
    return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())
  }
  get interfaces_() {
    return [Tc]
  }
}
class Sm extends Bf {
  constructor() {
    super(), Sm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._factory = null
    const t = arguments[0]
    this._factory = t
  }
  static findLabeledEdgeRings(t) {
    const e = new Yc()
    let n = 1
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      if (t.isMarked()) continue
      if (t.getLabel() >= 0) continue
      e.add(t)
      const s = Mm.findDirEdgesInRing(t)
      Sm.label(s, n), n++
    }
    return e
  }
  static getDegreeNonDeleted(t) {
    let e = 0
    for (let n = t.getOutEdges().getEdges().iterator(); n.hasNext(); ) {
      n.next().isMarked() || e++
    }
    return e
  }
  static deleteAllEdges(t) {
    for (let e = t.getOutEdges().getEdges().iterator(); e.hasNext(); ) {
      const t = e.next()
      t.setMarked(!0)
      const n = t.getSym()
      null !== n && n.setMarked(!0)
    }
  }
  static label(t, e) {
    for (let n = t.iterator(); n.hasNext(); ) {
      n.next().setLabel(e)
    }
  }
  static computeNextCWEdges(t) {
    let e = null,
      n = null
    for (let i = t.getOutEdges().getEdges().iterator(); i.hasNext(); ) {
      const t = i.next()
      if (!t.isMarked()) {
        if ((null === e && (e = t), null !== n)) {
          n.getSym().setNext(t)
        }
        n = t
      }
    }
    if (null !== n) {
      n.getSym().setNext(e)
    }
  }
  static computeNextCCWEdges(t, e) {
    let n = null,
      i = null
    const s = t.getOutEdges().getEdges()
    for (let t = s.size() - 1; t >= 0; t--) {
      const r = s.get(t),
        o = r.getSym()
      let a = null
      r.getLabel() === e && (a = r)
      let l = null
      o.getLabel() === e && (l = o),
        (null === a && null === l) ||
          (null !== l && (i = l),
          null !== a && (null !== i && (i.setNext(a), (i = null)), null === n && (n = a)))
    }
    null !== i && (Cc.isTrue(null !== n), i.setNext(n))
  }
  static getDegree(t, e) {
    let n = 0
    for (let i = t.getOutEdges().getEdges().iterator(); i.hasNext(); ) {
      i.next().getLabel() === e && n++
    }
    return n
  }
  static findIntersectionNodes(t, e) {
    let n = t,
      i = null
    do {
      const s = n.getFromNode()
      Sm.getDegree(s, e) > 1 && (null === i && (i = new Yc()), i.add(s)),
        (n = n.getNext()),
        Cc.isTrue(null !== n, 'found null DE in ring'),
        Cc.isTrue(n === t || !n.isInRing(), 'found DE already in ring')
    } while (n !== t)
    return i
  }
  findEdgeRing(t) {
    const e = new Mm(this._factory)
    return e.build(t), e
  }
  computeDepthParity() {
    if (0 === arguments.length) for (;;) return null
  }
  computeNextCWEdges() {
    for (let t = this.nodeIterator(); t.hasNext(); ) {
      const e = t.next()
      Sm.computeNextCWEdges(e)
    }
  }
  addEdge(t) {
    if (t.isEmpty()) return null
    const e = Cu.removeRepeatedPoints(t.getCoordinates())
    if (e.length < 2) return null
    const n = e[0],
      i = e[e.length - 1],
      s = this.getNode(n),
      r = this.getNode(i),
      o = new um(s, r, e[1], !0),
      a = new um(r, s, e[e.length - 2], !1),
      l = new dm(t)
    l.setDirectedEdges(o, a), this.add(l)
  }
  deleteCutEdges() {
    this.computeNextCWEdges(), Sm.findLabeledEdgeRings(this._dirEdges)
    const t = new Yc()
    for (let e = this._dirEdges.iterator(); e.hasNext(); ) {
      const n = e.next()
      if (n.isMarked()) continue
      const i = n.getSym()
      if (n.getLabel() === i.getLabel()) {
        n.setMarked(!0), i.setMarked(!0)
        const e = n.getEdge()
        t.add(e.getLine())
      }
    }
    return t
  }
  getEdgeRings() {
    this.computeNextCWEdges(), Sm.label(this._dirEdges, -1)
    const t = Sm.findLabeledEdgeRings(this._dirEdges)
    this.convertMaximalToMinimalEdgeRings(t)
    const e = new Yc()
    for (let t = this._dirEdges.iterator(); t.hasNext(); ) {
      const n = t.next()
      if (n.isMarked()) continue
      if (n.isInRing()) continue
      const i = this.findEdgeRing(n)
      e.add(i)
    }
    return e
  }
  getNode(t) {
    let e = this.findNode(t)
    return null === e && ((e = new Ff(t)), this.add(e)), e
  }
  convertMaximalToMinimalEdgeRings(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next(),
        n = t.getLabel(),
        i = Sm.findIntersectionNodes(t, n)
      if (null !== i)
        for (let t = i.iterator(); t.hasNext(); ) {
          const e = t.next()
          Sm.computeNextCCWEdges(e, n)
        }
    }
  }
  deleteDangles() {
    const t = this.findNodesOfDegree(1),
      e = new Gu(),
      n = new pp()
    for (let e = t.iterator(); e.hasNext(); ) n.push(e.next())
    for (; !n.isEmpty(); ) {
      const t = n.pop()
      Sm.deleteAllEdges(t)
      for (let i = t.getOutEdges().getEdges().iterator(); i.hasNext(); ) {
        const t = i.next()
        t.setMarked(!0)
        const s = t.getSym()
        null !== s && s.setMarked(!0)
        const r = t.getEdge()
        e.add(r.getLine())
        const o = t.getToNode()
        1 === Sm.getDegreeNonDeleted(o) && n.push(o)
      }
    }
    return e
  }
}
class Am {
  constructor() {
    Am.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._shells = null), (this._shellIndex = null)
    const t = arguments[0]
    ;(this._shells = t), this.buildIndex()
  }
  static assignHolesToShells(t, e) {
    new Am(e).assignHolesToShells(t)
  }
  assignHolesToShells(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this.assignHoleToShell(t)
    }
  }
  buildIndex() {
    this._shellIndex = new Ag()
    for (const t of this._shells) this._shellIndex.insert(t.getRing().getEnvelopeInternal(), t)
  }
  queryOverlappingShells(t) {
    return this._shellIndex.query(t)
  }
  findShellContaining(t) {
    const e = t.getRing().getEnvelopeInternal(),
      n = this.queryOverlappingShells(e)
    return Mm.findEdgeRingContaining(t, n)
  }
  assignHoleToShell(t) {
    const e = this.findShellContaining(t)
    null !== e && e.addHole(t)
  }
}
class Tm {
  constructor() {
    Tm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._lineStringAdder = new Im(this)),
      (this._graph = null),
      (this._dangles = new Yc()),
      (this._cutEdges = new Yc()),
      (this._invalidRingLines = new Yc()),
      (this._holeList = null),
      (this._shellList = null),
      (this._polyList = null),
      (this._isCheckingRingsValid = !0),
      (this._extractOnlyPolygonal = null),
      (this._geomFactory = null),
      0 === arguments.length)
    )
      Tm.constructor_.call(this, !1)
    else if (1 === arguments.length) {
      const t = arguments[0]
      this._extractOnlyPolygonal = t
    }
  }
  static extractPolygons(t, e) {
    const n = new Yc()
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      ;(e || t.isIncluded()) && n.add(t.getPolygon())
    }
    return n
  }
  static findOuterShells(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next(),
        n = t.getOuterHole()
      null === n || n.isProcessed() || (t.setIncluded(!0), n.setProcessed(!0))
    }
  }
  static findDisjointShells(t) {
    Tm.findOuterShells(t)
    let e = null
    do {
      e = !1
      for (let n = t.iterator(); n.hasNext(); ) {
        const t = n.next()
        t.isIncludedSet() || (t.updateIncluded(), t.isIncludedSet() || (e = !0))
      }
    } while (e)
  }
  getGeometry() {
    return (
      null === this._geomFactory && (this._geomFactory = new ku()),
      this.polygonize(),
      this._extractOnlyPolygonal
        ? this._geomFactory.buildGeometry(this._polyList)
        : this._geomFactory.createGeometryCollection(ku.toGeometryArray(this._polyList))
    )
  }
  getInvalidRingLines() {
    return this.polygonize(), this._invalidRingLines
  }
  findValidRings(t, e, n) {
    for (let i = t.iterator(); i.hasNext(); ) {
      const t = i.next()
      t.isValid() ? e.add(t) : n.add(t.getLineString())
    }
  }
  polygonize() {
    if (null !== this._polyList) return null
    if (((this._polyList = new Yc()), null === this._graph)) return null
    ;(this._dangles = this._graph.deleteDangles()), (this._cutEdges = this._graph.deleteCutEdges())
    const t = this._graph.getEdgeRings()
    let e = new Yc()
    ;(this._invalidRingLines = new Yc()),
      this._isCheckingRingsValid ? this.findValidRings(t, e, this._invalidRingLines) : (e = t),
      this.findShellsAndHoles(e),
      Am.assignHolesToShells(this._holeList, this._shellList),
      Od.sort(this._shellList, new Mm.EnvelopeComparator())
    let n = !0
    this._extractOnlyPolygonal && (Tm.findDisjointShells(this._shellList), (n = !1)),
      (this._polyList = Tm.extractPolygons(this._shellList, n))
  }
  getDangles() {
    return this.polygonize(), this._dangles
  }
  getCutEdges() {
    return this.polygonize(), this._cutEdges
  }
  getPolygons() {
    return this.polygonize(), this._polyList
  }
  add() {
    if (Uc(arguments[0], Vc)) {
      for (let t = arguments[0].iterator(); t.hasNext(); ) {
        const e = t.next()
        this.add(e)
      }
    } else if (arguments[0] instanceof mu) {
      const t = arguments[0]
      ;(this._geomFactory = t.getFactory()),
        null === this._graph && (this._graph = new Sm(this._geomFactory)),
        this._graph.addEdge(t)
    } else if (arguments[0] instanceof hu) {
      arguments[0].apply(this._lineStringAdder)
    }
  }
  setCheckRingsValid(t) {
    this._isCheckingRingsValid = t
  }
  findShellsAndHoles(t) {
    ;(this._holeList = new Yc()), (this._shellList = new Yc())
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      t.computeHole(), t.isHole() ? this._holeList.add(t) : this._shellList.add(t)
    }
  }
}
class Im {
  constructor() {
    Im.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.p = null
    const t = arguments[0]
    this.p = t
  }
  filter(t) {
    t instanceof mu && this.p.add(t)
  }
  get interfaces_() {
    return [lu]
  }
}
Tm.LineStringAdder = Im
var Rm = Object.freeze({ __proto__: null, Polygonizer: Tm })
class Lm {
  constructor() {
    Lm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()),
      (this._ptLocator = new Ap()),
      (this._arg = null),
      (this._nodes = new $p(new xm())),
      (this._im = null),
      (this._isolatedEdges = new Yc()),
      (this._invalidPoint = null)
    const t = arguments[0]
    this._arg = t
  }
  insertEdgeEnds(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this._nodes.add(t)
    }
  }
  computeProperIntersectionIM(t, e) {
    const n = this._arg[0].getGeometry().getDimension(),
      i = this._arg[1].getGeometry().getDimension(),
      s = t.hasProperIntersection(),
      r = t.hasProperInteriorIntersection()
    2 === n && 2 === i
      ? s && e.setAtLeast('212101212')
      : 2 === n && 1 === i
        ? (s && e.setAtLeast('FFF0FFFF2'), r && e.setAtLeast('1FFFFF1FF'))
        : 1 === n && 2 === i
          ? (s && e.setAtLeast('F0FFFFFF2'), r && e.setAtLeast('1F1FFFFFF'))
          : 1 === n && 1 === i && r && e.setAtLeast('0FFFFFFFF')
  }
  labelIsolatedEdges(t, e) {
    for (let n = this._arg[t].getEdgeIterator(); n.hasNext(); ) {
      const t = n.next()
      t.isIsolated() &&
        (this.labelIsolatedEdge(t, e, this._arg[e].getGeometry()), this._isolatedEdges.add(t))
    }
  }
  labelIsolatedEdge(t, e, n) {
    if (n.getDimension() > 0) {
      const i = this._ptLocator.locate(t.getCoordinate(), n)
      t.getLabel().setAllLocations(e, i)
    } else t.getLabel().setAllLocations(e, pd.EXTERIOR)
  }
  computeIM() {
    const t = new gd()
    if (
      (t.set(pd.EXTERIOR, pd.EXTERIOR, 2),
      !this._arg[0]
        .getGeometry()
        .getEnvelopeInternal()
        .intersects(this._arg[1].getGeometry().getEnvelopeInternal()))
    )
      return this.computeDisjointIM(t), t
    this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1)
    const e = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !1)
    this.computeIntersectionNodes(0),
      this.computeIntersectionNodes(1),
      this.copyNodesAndLabels(0),
      this.copyNodesAndLabels(1),
      this.labelIsolatedNodes(),
      this.computeProperIntersectionIM(e, t)
    const n = new gm(),
      i = n.computeEdgeEnds(this._arg[0].getEdgeIterator())
    this.insertEdgeEnds(i)
    const s = n.computeEdgeEnds(this._arg[1].getEdgeIterator())
    return (
      this.insertEdgeEnds(s),
      this.labelNodeEdges(),
      this.labelIsolatedEdges(0, 1),
      this.labelIsolatedEdges(1, 0),
      this.updateIM(t),
      t
    )
  }
  labelNodeEdges() {
    for (let t = this._nodes.iterator(); t.hasNext(); ) {
      t.next().getEdges().computeLabelling(this._arg)
    }
  }
  copyNodesAndLabels(t) {
    for (let e = this._arg[t].getNodeIterator(); e.hasNext(); ) {
      const n = e.next()
      this._nodes.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
    }
  }
  labelIntersectionNodes(t) {
    for (let e = this._arg[t].getEdgeIterator(); e.hasNext(); ) {
      const n = e.next(),
        i = n.getLabel().getLocation(t)
      for (let e = n.getEdgeIntersectionList().iterator(); e.hasNext(); ) {
        const n = e.next(),
          s = this._nodes.find(n.coord)
        s.getLabel().isNull(t) &&
          (i === pd.BOUNDARY ? s.setLabelBoundary(t) : s.setLabel(t, pd.INTERIOR))
      }
    }
  }
  labelIsolatedNode(t, e) {
    const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry())
    t.getLabel().setAllLocations(e, n)
  }
  computeIntersectionNodes(t) {
    for (let e = this._arg[t].getEdgeIterator(); e.hasNext(); ) {
      const n = e.next(),
        i = n.getLabel().getLocation(t)
      for (let e = n.getEdgeIntersectionList().iterator(); e.hasNext(); ) {
        const n = e.next(),
          s = this._nodes.addNode(n.coord)
        i === pd.BOUNDARY
          ? s.setLabelBoundary(t)
          : s.getLabel().isNull(t) && s.setLabel(t, pd.INTERIOR)
      }
    }
  }
  labelIsolatedNodes() {
    for (let t = this._nodes.iterator(); t.hasNext(); ) {
      const e = t.next(),
        n = e.getLabel()
      Cc.isTrue(n.getGeometryCount() > 0, 'node with empty label found'),
        e.isIsolated() &&
          (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1))
    }
  }
  updateIM(t) {
    for (let e = this._isolatedEdges.iterator(); e.hasNext(); ) {
      e.next().updateIM(t)
    }
    for (let e = this._nodes.iterator(); e.hasNext(); ) {
      const n = e.next()
      n.updateIM(t), n.updateIMFromEdges(t)
    }
  }
  computeDisjointIM(t) {
    const e = this._arg[0].getGeometry()
    e.isEmpty() ||
      (t.set(pd.INTERIOR, pd.EXTERIOR, e.getDimension()),
      t.set(pd.BOUNDARY, pd.EXTERIOR, e.getBoundaryDimension()))
    const n = this._arg[1].getGeometry()
    n.isEmpty() ||
      (t.set(pd.EXTERIOR, pd.INTERIOR, n.getDimension()),
      t.set(pd.EXTERIOR, pd.BOUNDARY, n.getBoundaryDimension()))
  }
}
class Cm {
  constructor() {
    Cm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._rectEnv = null
    const t = arguments[0]
    this._rectEnv = t.getEnvelopeInternal()
  }
  static contains(t, e) {
    return new Cm(t).contains(e)
  }
  isContainedInBoundary(t) {
    if (t instanceof Eu) return !1
    if (t instanceof xu) return this.isPointContainedInBoundary(t)
    if (t instanceof mu) return this.isLineStringContainedInBoundary(t)
    for (let e = 0; e < t.getNumGeometries(); e++) {
      const n = t.getGeometryN(e)
      if (!this.isContainedInBoundary(n)) return !1
    }
    return !0
  }
  isLineSegmentContainedInBoundary(t, e) {
    if (t.equals(e)) return this.isPointContainedInBoundary(t)
    if (t.x === e.x) {
      if (t.x === this._rectEnv.getMinX() || t.x === this._rectEnv.getMaxX()) return !0
    } else if (t.y === e.y && (t.y === this._rectEnv.getMinY() || t.y === this._rectEnv.getMaxY()))
      return !0
    return !1
  }
  isLineStringContainedInBoundary(t) {
    const e = t.getCoordinateSequence(),
      n = new Oc(),
      i = new Oc()
    for (let t = 0; t < e.size() - 1; t++)
      if (
        (e.getCoordinate(t, n),
        e.getCoordinate(t + 1, i),
        !this.isLineSegmentContainedInBoundary(n, i))
      )
        return !1
    return !0
  }
  isPointContainedInBoundary() {
    if (arguments[0] instanceof xu) {
      const t = arguments[0]
      return this.isPointContainedInBoundary(t.getCoordinate())
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      return (
        t.x === this._rectEnv.getMinX() ||
        t.x === this._rectEnv.getMaxX() ||
        t.y === this._rectEnv.getMinY() ||
        t.y === this._rectEnv.getMaxY()
      )
    }
  }
  contains(t) {
    return !!this._rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t)
  }
}
class Nm {
  constructor() {
    Nm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()),
      (this._rectEnv = null),
      (this._diagUp0 = null),
      (this._diagUp1 = null),
      (this._diagDown0 = null),
      (this._diagDown1 = null)
    const t = arguments[0]
    ;(this._rectEnv = t),
      (this._diagUp0 = new Oc(t.getMinX(), t.getMinY())),
      (this._diagUp1 = new Oc(t.getMaxX(), t.getMaxY())),
      (this._diagDown0 = new Oc(t.getMinX(), t.getMaxY())),
      (this._diagDown1 = new Oc(t.getMaxX(), t.getMinY()))
  }
  intersects(t, e) {
    const n = new Xc(t, e)
    if (!this._rectEnv.intersects(n)) return !1
    if (this._rectEnv.intersects(t)) return !0
    if (this._rectEnv.intersects(e)) return !0
    if (t.compareTo(e) > 0) {
      const n = t
      ;(t = e), (e = n)
    }
    let i = !1
    return (
      e.y > t.y && (i = !0),
      i
        ? this._li.computeIntersection(t, e, this._diagDown0, this._diagDown1)
        : this._li.computeIntersection(t, e, this._diagUp0, this._diagUp1),
      !!this._li.hasIntersection()
    )
  }
}
class Pm {
  constructor() {
    Pm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._rectangle = null), (this._rectEnv = null)
    const t = arguments[0]
    ;(this._rectangle = t), (this._rectEnv = t.getEnvelopeInternal())
  }
  static intersects(t, e) {
    return new Pm(t).intersects(e)
  }
  intersects(t) {
    if (!this._rectEnv.intersects(t.getEnvelopeInternal())) return !1
    const e = new Dm(this._rectEnv)
    if ((e.applyTo(t), e.intersects())) return !0
    const n = new Om(this._rectangle)
    if ((n.applyTo(t), n.containsPoint())) return !0
    const i = new Fm(this._rectangle)
    return i.applyTo(t), !!i.intersects()
  }
}
class Dm extends zd {
  constructor() {
    super(), Dm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._rectEnv = null), (this._intersects = !1)
    const t = arguments[0]
    this._rectEnv = t
  }
  isDone() {
    return !0 === this._intersects
  }
  visit(t) {
    const e = t.getEnvelopeInternal()
    return this._rectEnv.intersects(e)
      ? this._rectEnv.contains(e) ||
        (e.getMinX() >= this._rectEnv.getMinX() && e.getMaxX() <= this._rectEnv.getMaxX()) ||
        (e.getMinY() >= this._rectEnv.getMinY() && e.getMaxY() <= this._rectEnv.getMaxY())
        ? ((this._intersects = !0), null)
        : void 0
      : null
  }
  intersects() {
    return this._intersects
  }
}
class Om extends zd {
  constructor() {
    super(), Om.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._rectSeq = null), (this._rectEnv = null), (this._containsPoint = !1)
    const t = arguments[0]
    ;(this._rectSeq = t.getExteriorRing().getCoordinateSequence()),
      (this._rectEnv = t.getEnvelopeInternal())
  }
  isDone() {
    return !0 === this._containsPoint
  }
  visit(t) {
    if (!(t instanceof Eu)) return null
    const e = t.getEnvelopeInternal()
    if (!this._rectEnv.intersects(e)) return null
    const n = new Oc()
    for (let i = 0; i < 4; i++)
      if ((this._rectSeq.getCoordinate(i, n), e.contains(n) && hp.containsPointInPolygon(n, t)))
        return (this._containsPoint = !0), null
  }
  containsPoint() {
    return this._containsPoint
  }
}
class Fm extends zd {
  constructor() {
    super(), Fm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._rectEnv = null),
      (this._rectIntersector = null),
      (this._hasIntersection = !1),
      (this._p0 = new Oc()),
      (this._p1 = new Oc())
    const t = arguments[0]
    ;(this._rectEnv = t.getEnvelopeInternal()), (this._rectIntersector = new Nm(this._rectEnv))
  }
  intersects() {
    return this._hasIntersection
  }
  isDone() {
    return !0 === this._hasIntersection
  }
  visit(t) {
    const e = t.getEnvelopeInternal()
    if (!this._rectEnv.intersects(e)) return null
    const n = Dd.getLines(t)
    this.checkIntersectionWithLineStrings(n)
  }
  checkIntersectionWithLineStrings(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      if ((this.checkIntersectionWithSegments(t), this._hasIntersection)) return null
    }
  }
  checkIntersectionWithSegments(t) {
    const e = t.getCoordinateSequence()
    for (let t = 1; t < e.size(); t++)
      if (
        (e.getCoordinate(t - 1, this._p0),
        e.getCoordinate(t, this._p1),
        this._rectIntersector.intersects(this._p0, this._p1))
      )
        return (this._hasIntersection = !0), null
  }
}
class Gm extends lm {
  constructor() {
    super(), Gm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._relate = null), 2 === arguments.length)) {
      const t = arguments[0],
        e = arguments[1]
      lm.constructor_.call(this, t, e), (this._relate = new Lm(this._arg))
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      lm.constructor_.call(this, t, e, n), (this._relate = new Lm(this._arg))
    }
  }
  static covers(t, e) {
    return (
      !(2 === e.getDimension() && t.getDimension() < 2) &&
      !(1 === e.getDimension() && t.getDimension() < 1 && e.getLength() > 0) &&
      !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) &&
      (!!t.isRectangle() || new Gm(t, e).getIntersectionMatrix().isCovers())
    )
  }
  static intersects(t, e) {
    if (!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())) return !1
    if (t.isRectangle()) return Pm.intersects(t, e)
    if (e.isRectangle()) return Pm.intersects(e, t)
    if (t.isGeometryCollection() || e.isGeometryCollection()) {
      for (let n = 0; n < t.getNumGeometries(); n++)
        for (let i = 0; i < e.getNumGeometries(); i++)
          if (t.getGeometryN(n).intersects(e.getGeometryN(i))) return !0
      return !1
    }
    return new Gm(t, e).getIntersectionMatrix().isIntersects()
  }
  static touches(t, e) {
    return (
      !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) &&
      new Gm(t, e).getIntersectionMatrix().isTouches(t.getDimension(), e.getDimension())
    )
  }
  static equalsTopo(t, e) {
    return (
      !!t.getEnvelopeInternal().equals(e.getEnvelopeInternal()) &&
      Gm.relate(t, e).isEquals(t.getDimension(), e.getDimension())
    )
  }
  static relate() {
    if (2 === arguments.length) {
      return new Gm(arguments[0], arguments[1]).getIntersectionMatrix()
    }
    if (3 === arguments.length) {
      return new Gm(arguments[0], arguments[1], arguments[2]).getIntersectionMatrix()
    }
  }
  static overlaps(t, e) {
    return (
      !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) &&
      new Gm(t, e).getIntersectionMatrix().isOverlaps(t.getDimension(), e.getDimension())
    )
  }
  static crosses(t, e) {
    return (
      !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) &&
      new Gm(t, e).getIntersectionMatrix().isCrosses(t.getDimension(), e.getDimension())
    )
  }
  static contains(t, e) {
    return (
      !(2 === e.getDimension() && t.getDimension() < 2) &&
      !(1 === e.getDimension() && t.getDimension() < 1 && e.getLength() > 0) &&
      !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) &&
      (t.isRectangle() ? Cm.contains(t, e) : new Gm(t, e).getIntersectionMatrix().isContains())
    )
  }
  getIntersectionMatrix() {
    return this._relate.computeIM()
  }
}
var zm = Object.freeze({ __proto__: null, RelateOp: Gm })
class Bm {
  constructor() {
    Bm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pointGeom = null), (this._otherGeom = null), (this._geomFact = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._pointGeom = t), (this._otherGeom = e), (this._geomFact = e.getFactory())
  }
  static union(t, e) {
    return new Bm(t, e).union()
  }
  union() {
    const t = new Ap(),
      e = new Su()
    for (let n = 0; n < this._pointGeom.getNumGeometries(); n++) {
      const i = this._pointGeom.getGeometryN(n).getCoordinate()
      t.locate(i, this._otherGeom) === pd.EXTERIOR && e.add(i)
    }
    if (0 === e.size()) return this._otherGeom
    let n = null
    const i = Cu.toCoordinateArray(e)
    return (
      (n =
        1 === i.length
          ? this._geomFact.createPoint(i[0])
          : this._geomFact.createMultiPointFromCoords(i)),
      Ad.combine(n, this._otherGeom)
    )
  }
}
class Um {
  constructor() {
    Um.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geomFactory = null),
      (this._polygons = new Yc()),
      (this._lines = new Yc()),
      (this._points = new Yc()),
      (this._dimension = gu.FALSE)
  }
  static extract() {
    if (Uc(arguments[0], Vc)) {
      const t = arguments[0],
        e = new Um()
      return e.add(t), e
    }
    if (arguments[0] instanceof hu) {
      const t = arguments[0],
        e = new Um()
      return e.add(t), e
    }
  }
  getFactory() {
    return this._geomFactory
  }
  recordDimension(t) {
    t > this._dimension && (this._dimension = t)
  }
  getDimension() {
    return this._dimension
  }
  filter(t) {
    return (
      this.recordDimension(t.getDimension()),
      t instanceof Tu || t.isEmpty()
        ? null
        : t instanceof Eu
          ? (this._polygons.add(t), null)
          : t instanceof mu
            ? (this._lines.add(t), null)
            : t instanceof xu
              ? (this._points.add(t), null)
              : void Cc.shouldNeverReachHere('Unhandled geometry type: ' + t.getGeometryType())
    )
  }
  getExtract(t) {
    switch (t) {
      case 0:
        return this._points
      case 1:
        return this._lines
      case 2:
        return this._polygons
    }
    return Cc.shouldNeverReachHere('Invalid dimension: ' + t), null
  }
  isEmpty() {
    return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty()
  }
  add() {
    if (Uc(arguments[0], Vc)) {
      const t = arguments[0]
      for (const e of t) this.add(e)
    } else if (arguments[0] instanceof hu) {
      const t = arguments[0]
      null === this._geomFactory && (this._geomFactory = t.getFactory()), t.apply(this)
    }
  }
  get interfaces_() {
    return [fu]
  }
}
class Vm {
  constructor() {
    Vm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._geomFactory = null), (this._g0 = null), (this._g1 = null), (this._isUnionSafe = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._g0 = t), (this._g1 = e), (this._geomFactory = t.getFactory())
  }
  static containsProperly() {
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return (
        !t.isNull() &&
        e.getX() > t.getMinX() &&
        e.getX() < t.getMaxX() &&
        e.getY() > t.getMinY() &&
        e.getY() < t.getMaxY()
      )
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      return Vm.containsProperly(t, e) && Vm.containsProperly(t, n)
    }
  }
  static union(t, e) {
    return new Vm(t, e).union()
  }
  static intersects(t, e, n) {
    return t.intersects(e) || t.intersects(n)
  }
  static overlapEnvelope(t, e) {
    const n = t.getEnvelopeInternal(),
      i = e.getEnvelopeInternal()
    return n.intersection(i)
  }
  static extractBorderSegments(t, e, n) {
    t.apply(
      new (class {
        get interfaces_() {
          return [Zc]
        }
        filter(t, i) {
          if (i <= 0) return null
          const s = t.getCoordinate(i - 1),
            r = t.getCoordinate(i)
          if (Vm.intersects(e, s, r) && !Vm.containsProperly(e, s, r)) {
            const t = new dd(s, r)
            n.add(t)
          }
        }
        isDone() {
          return !1
        }
        isGeometryChanged() {
          return !1
        }
      })()
    )
  }
  static unionBuffer(t, e) {
    return t.getFactory().createGeometryCollection([t, e]).buffer(0)
  }
  isBorderSegmentsSame(t, e) {
    const n = this.extractBorderSegments(this._g0, this._g1, e),
      i = new Yc()
    return Vm.extractBorderSegments(t, e, i), this.isEqual(n, i)
  }
  extractByEnvelope(t, e, n) {
    const i = new Yc()
    for (let s = 0; s < e.getNumGeometries(); s++) {
      const r = e.getGeometryN(s)
      if (r.getEnvelopeInternal().intersects(t)) i.add(r)
      else {
        const t = r.copy()
        n.add(t)
      }
    }
    return this._geomFactory.buildGeometry(i)
  }
  isEqual(t, e) {
    if (t.size() !== e.size()) return !1
    const n = new Gu(t)
    for (const t of e) if (!n.contains(t)) return !1
    return !0
  }
  union() {
    const t = Vm.overlapEnvelope(this._g0, this._g1)
    if (t.isNull()) {
      const t = this._g0.copy(),
        e = this._g1.copy()
      return Ad.combine(t, e)
    }
    const e = new Yc(),
      n = this.extractByEnvelope(t, this._g0, e),
      i = this.extractByEnvelope(t, this._g1, e),
      s = this.unionFull(n, i)
    let r = null
    return (
      (this._isUnionSafe = this.isBorderSegmentsSame(s, t)),
      (r = this._isUnionSafe ? this.combine(s, e) : this.unionFull(this._g0, this._g1)),
      r
    )
  }
  combine(t, e) {
    if (e.size() <= 0) return t
    e.add(t)
    return Ad.combine(e)
  }
  unionFull(t, e) {
    try {
      return t.union(e)
    } catch (n) {
      if (n instanceof eg) return Vm.unionBuffer(t, e)
      throw n
    }
  }
  extractBorderSegments(t, e, n) {
    const i = new Yc()
    return Vm.extractBorderSegments(t, n, i), null !== e && Vm.extractBorderSegments(e, n, i), i
  }
  isUnionOptimized() {
    return this._isUnionSafe
  }
}
class Hm {
  constructor() {
    Hm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputPolys = null), (this._geomFactory = null)
    const t = arguments[0]
    ;(this._inputPolys = t), null === this._inputPolys && (this._inputPolys = new Yc())
  }
  static restrictToPolygons(t) {
    if (Uc(t, wu)) return t
    const e = Gd.getPolygons(t)
    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(ku.toPolygonArray(e))
  }
  static getGeometry(t, e) {
    return e >= t.size() ? null : t.get(e)
  }
  static union(t) {
    return new Hm(t).union()
  }
  reduceToGeometries(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      let i = null
      Uc(t, kc) ? (i = this.unionTree(t)) : t instanceof hu && (i = t), e.add(i)
    }
    return e
  }
  union() {
    if (null === this._inputPolys)
      throw new IllegalStateException('union() method cannot be called twice')
    if (this._inputPolys.isEmpty()) return null
    this._geomFactory = this._inputPolys.iterator().next().getFactory()
    const t = new Ag(Hm.STRTREE_NODE_CAPACITY)
    for (let e = this._inputPolys.iterator(); e.hasNext(); ) {
      const n = e.next()
      t.insert(n.getEnvelopeInternal(), n)
    }
    this._inputPolys = null
    const e = t.itemsTree()
    return this.unionTree(e)
  }
  binaryUnion() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this.binaryUnion(t, 0, t.size())
    }
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      if (n - e <= 1) {
        const n = Hm.getGeometry(t, e)
        return this.unionSafe(n, null)
      }
      if (n - e == 2) return this.unionSafe(Hm.getGeometry(t, e), Hm.getGeometry(t, e + 1))
      {
        const i = Math.trunc((n + e) / 2),
          s = this.binaryUnion(t, e, i),
          r = this.binaryUnion(t, i, n)
        return this.unionSafe(s, r)
      }
    }
  }
  repeatedUnion(t) {
    let e = null
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e = null === e ? t.copy() : e.union(t)
    }
    return e
  }
  unionSafe(t, e) {
    return null === t && null === e
      ? null
      : null === t
        ? e.copy()
        : null === e
          ? t.copy()
          : this.unionActual(t, e)
  }
  unionActual(t, e) {
    const n = Vm.union(t, e)
    return Hm.restrictToPolygons(n)
  }
  unionTree(t) {
    const e = this.reduceToGeometries(t)
    return this.binaryUnion(e)
  }
  bufferUnion() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return t.get(0).getFactory().buildGeometry(t).buffer(0)
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return t.getFactory().createGeometryCollection([t, e]).buffer(0)
    }
  }
}
Hm.STRTREE_NODE_CAPACITY = 4
class km {
  constructor() {
    km.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._geomFact = null), (this._extracter = null), 1 === arguments.length)) {
      if (Uc(arguments[0], Vc)) {
        const t = arguments[0]
        this.extract(t)
      } else if (arguments[0] instanceof hu) {
        const t = arguments[0]
        this.extract(t)
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._geomFact = e), this.extract(t)
    }
  }
  static union() {
    if (1 === arguments.length) {
      if (Uc(arguments[0], Vc)) {
        return new km(arguments[0]).union()
      }
      if (arguments[0] instanceof hu) {
        return new km(arguments[0]).union()
      }
    } else if (2 === arguments.length) {
      return new km(arguments[0], arguments[1]).union()
    }
  }
  unionNoOpt(t) {
    const e = this._geomFact.createPoint()
    return am.overlayOp(t, e, hm.UNION)
  }
  unionWithNull(t, e) {
    return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e)
  }
  extract() {
    if (Uc(arguments[0], Vc)) {
      const t = arguments[0]
      this._extracter = Um.extract(t)
    } else if (arguments[0] instanceof hu) {
      const t = arguments[0]
      this._extracter = Um.extract(t)
    }
  }
  union() {
    if (
      (null === this._geomFact && (this._geomFact = this._extracter.getFactory()),
      null === this._geomFact)
    )
      return null
    if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension())
    const t = this._extracter.getExtract(0),
      e = this._extracter.getExtract(1),
      n = this._extracter.getExtract(2)
    let i = null
    if (t.size() > 0) {
      const e = this._geomFact.buildGeometry(t)
      i = this.unionNoOpt(e)
    }
    let s = null
    if (e.size() > 0) {
      const t = this._geomFact.buildGeometry(e)
      s = this.unionNoOpt(t)
    }
    let r = null
    n.size() > 0 && (r = Hm.union(n))
    const o = this.unionWithNull(s, r)
    let a = null
    return (
      (a = null === i ? o : null === o ? i : Bm.union(i, o)),
      null === a ? this._geomFact.createGeometryCollection() : a
    )
  }
}
var Wm = Object.freeze({ __proto__: null, UnaryUnionOp: km }),
  Ym = Object.freeze({ __proto__: null, IsValidOp: bm, ConsistentAreaTester: _m }),
  jm = Object.freeze({
    __proto__: null,
    BoundaryOp: kg,
    IsSimpleOp: Yg,
    buffer: Sf,
    distance: Rf,
    linemerge: Yf,
    overlay: cm,
    polygonize: Rm,
    relate: zm,
    union: Wm,
    valid: Ym
  })
Td.CoordinateOperation
class qm {
  constructor() {
    qm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._geom = null),
      (this._pts = null),
      (this._start = null),
      (this._end = null),
      2 === arguments.length)
    ) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._pts = t), (this._start = e), (this._end = e + 1)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._pts = t), (this._start = e), (this._end = n)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      ;(this._geom = t), (this._pts = e), (this._start = n), (this._end = i)
    }
  }
  computeDistanceLineLine(t, e) {
    let n = Mc.MAX_VALUE
    for (let i = this._start; i < this._end - 1; i++) {
      const s = this._pts.getCoordinate(i),
        r = this._pts.getCoordinate(i + 1)
      for (let o = t._start; o < t._end - 1; o++) {
        const a = t._pts.getCoordinate(o),
          l = t._pts.getCoordinate(o + 1),
          h = ou.segmentToSegment(s, r, a, l)
        if (
          h < n &&
          ((n = h),
          null !== e && this.updateNearestLocationsLineLine(i, s, r, t, o, a, l, e),
          n <= 0)
        )
          return n
      }
    }
    return n
  }
  updateNearestLocationsPointLine(t, e, n, i, s, r) {
    r[0] = new Af(this._geom, this._start, new Oc(t))
    const o = new dd(i, s).closestPoint(t)
    r[1] = new Af(e._geom, n, new Oc(o))
  }
  size() {
    return this._end - this._start
  }
  getCoordinate(t) {
    return this._pts.getCoordinate(this._start + t)
  }
  nearestLocations(t) {
    const e = this.isPoint(),
      n = t.isPoint(),
      i = new Array(2).fill(null)
    if (e && n) {
      const e = this._pts.getCoordinate(this._start),
        n = t._pts.getCoordinate(t._start)
      ;(i[0] = new Af(this._geom, this._start, new Oc(e))),
        (i[1] = new Af(t._geom, t._start, new Oc(n)))
    } else if (e) {
      const e = this._pts.getCoordinate(this._start)
      this.computeDistancePointLine(e, t, i)
    } else if (n) {
      const e = t._pts.getCoordinate(t._start)
      this.computeDistancePointLine(e, this, i)
      const n = i[0]
      ;(i[0] = i[1]), (i[1] = n)
    } else this.computeDistanceLineLine(t, i)
    return i
  }
  getEnvelope() {
    const t = new Xc()
    for (let e = this._start; e < this._end; e++)
      t.expandToInclude(this._pts.getX(e), this._pts.getY(e))
    return t
  }
  updateNearestLocationsLineLine(t, e, n, i, s, r, o, a) {
    const l = new dd(e, n),
      h = new dd(r, o),
      c = l.closestPoints(h)
    ;(a[0] = new Af(this._geom, t, new Oc(c[0]))), (a[1] = new Af(i._geom, s, new Oc(c[1])))
  }
  toString() {
    const t = new Kc()
    t.append('LINESTRING ( ')
    const e = new Oc()
    for (let n = this._start; n < this._end; n++)
      n > this._start && t.append(', '), this._pts.getCoordinate(n, e), t.append(e.x + ' ' + e.y)
    return t.append(' )'), t.toString()
  }
  computeDistancePointLine(t, e, n) {
    let i = Mc.MAX_VALUE
    for (let s = e._start; s < e._end - 1; s++) {
      const r = e._pts.getCoordinate(s),
        o = e._pts.getCoordinate(s + 1),
        a = ou.pointToSegment(t, r, o)
      if (
        a < i &&
        ((i = a), null !== n && this.updateNearestLocationsPointLine(t, e, s, r, o, n), i <= 0)
      )
        return i
    }
    return i
  }
  isPoint() {
    return this._end - this._start == 1
  }
  distance(t) {
    const e = this.isPoint(),
      n = t.isPoint()
    let i = null
    if (e && n) {
      const e = this._pts.getCoordinate(this._start),
        n = t._pts.getCoordinate(t._start)
      i = e.distance(n)
    } else if (e) {
      const e = this._pts.getCoordinate(this._start)
      i = this.computeDistancePointLine(e, t, null)
    } else if (n) {
      const e = t._pts.getCoordinate(t._start)
      i = this.computeDistancePointLine(e, this, null)
    } else i = this.computeDistanceLineLine(t, null)
    return i
  }
}
class Zm {
  static addFacetSequences(t, e, n) {
    let i = 0
    const s = e.size()
    for (; i <= s - 1; ) {
      let r = i + Zm.FACET_SEQUENCE_SIZE + 1
      r >= s - 1 && (r = s)
      const o = new qm(t, e, i, r)
      n.add(o), (i += Zm.FACET_SEQUENCE_SIZE)
    }
  }
  static computeFacetSequences(t) {
    const e = new Yc()
    return (
      t.apply(
        new (class {
          get interfaces_() {
            return [lu]
          }
          filter(t) {
            let n = null
            ;(t instanceof mu || t instanceof xu) &&
              ((n = t.getCoordinateSequence()), Zm.addFacetSequences(t, n, e))
          }
        })()
      ),
      e
    )
  }
  static build(t) {
    const e = new Ag(Zm.STR_TREE_NODE_CAPACITY)
    for (let n = Zm.computeFacetSequences(t).iterator(); n.hasNext(); ) {
      const t = n.next()
      e.insert(t.getEnvelope(), t)
    }
    return e.build(), e
  }
}
;(Zm.FACET_SEQUENCE_SIZE = 6), (Zm.STR_TREE_NODE_CAPACITY = 4)
class Xm {
  constructor() {
    Xm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._minClearance = null), (this._minClearancePts = null)
    const t = arguments[0]
    this._inputGeom = t
  }
  static getLine(t) {
    return new Xm(t).getLine()
  }
  static getDistance(t) {
    return new Xm(t).getDistance()
  }
  getLine() {
    return (
      this.compute(),
      null === this._minClearancePts || null === this._minClearancePts[0]
        ? this._inputGeom.getFactory().createLineString()
        : this._inputGeom.getFactory().createLineString(this._minClearancePts)
    )
  }
  compute() {
    if (null !== this._minClearancePts) return null
    if (
      ((this._minClearancePts = new Array(2).fill(null)),
      (this._minClearance = Mc.MAX_VALUE),
      this._inputGeom.isEmpty())
    )
      return null
    const t = Zm.build(this._inputGeom).nearestNeighbour(new Km()),
      e = new Km()
    ;(this._minClearance = e.distance(t[0], t[1])), (this._minClearancePts = e.getCoordinates())
  }
  getDistance() {
    return this.compute(), this._minClearance
  }
}
class Km {
  constructor() {
    Km.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._minDist = Mc.MAX_VALUE), (this._minPts = new Array(2).fill(null))
  }
  vertexDistance(t, e) {
    for (let n = 0; n < t.size(); n++)
      for (let i = 0; i < e.size(); i++) {
        const s = t.getCoordinate(n),
          r = e.getCoordinate(i)
        if (!s.equals2D(r)) {
          const t = s.distance(r)
          if (
            t < this._minDist &&
            ((this._minDist = t), (this._minPts[0] = s), (this._minPts[1] = r), 0 === t)
          )
            return t
        }
      }
    return this._minDist
  }
  getCoordinates() {
    return this._minPts
  }
  segmentDistance(t, e) {
    for (let n = 0; n < t.size(); n++)
      for (let i = 1; i < e.size(); i++) {
        const s = t.getCoordinate(n),
          r = e.getCoordinate(i - 1),
          o = e.getCoordinate(i)
        if (!s.equals2D(r) && !s.equals2D(o)) {
          const t = ou.pointToSegment(s, r, o)
          if (t < this._minDist && ((this._minDist = t), this.updatePts(s, r, o), 0 === t)) return t
        }
      }
    return this._minDist
  }
  distance() {
    if (arguments[0] instanceof vg && arguments[1] instanceof vg) {
      const t = arguments[1],
        e = arguments[0].getItem(),
        n = t.getItem()
      return (this._minDist = Mc.MAX_VALUE), this.distance(e, n)
    }
    if (arguments[0] instanceof qm && arguments[1] instanceof qm) {
      const t = arguments[0],
        e = arguments[1]
      return (
        this.vertexDistance(t, e),
        1 === t.size() && 1 === e.size()
          ? this._minDist
          : this._minDist <= 0
            ? this._minDist
            : (this.segmentDistance(t, e),
              this._minDist <= 0 || this.segmentDistance(e, t),
              this._minDist)
      )
    }
  }
  updatePts(t, e, n) {
    this._minPts[0] = t
    const i = new dd(e, n)
    this._minPts[1] = new Oc(i.closestPoint(t))
  }
  get interfaces_() {
    return [Sg]
  }
}
Xm.MinClearanceDistance = Km
class Jm {
  constructor() {
    Jm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._minClearance = null), (this._minClearancePts = null)
    const t = arguments[0]
    this._inputGeom = t
  }
  static getLine(t) {
    return new Jm(t).getLine()
  }
  static getDistance(t) {
    return new Jm(t).getDistance()
  }
  getLine() {
    return this.compute(), this._inputGeom.getFactory().createLineString(this._minClearancePts)
  }
  updateClearance() {
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      t < this._minClearance &&
        ((this._minClearance = t),
        (this._minClearancePts[0] = new Oc(e)),
        (this._minClearancePts[1] = new Oc(n)))
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      if (t < this._minClearance) {
        ;(this._minClearance = t), (this._minClearancePts[0] = new Oc(e))
        const s = new dd(n, i)
        this._minClearancePts[1] = new Oc(s.closestPoint(e))
      }
    }
  }
  compute() {
    if (null !== this._minClearancePts) return null
    ;(this._minClearancePts = new Array(2).fill(null)),
      (this._minClearance = Mc.MAX_VALUE),
      this._inputGeom.apply(new Qm(this))
  }
  getDistance() {
    return this.compute(), this._minClearance
  }
}
class Qm {
  constructor() {
    Qm.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.smc = null
    const t = arguments[0]
    this.smc = t
  }
  filter(t) {
    this.smc._inputGeom.apply(new $m(this.smc, t))
  }
  get interfaces_() {
    return [cu]
  }
}
class $m {
  constructor() {
    $m.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this.smc = null), (this._queryPt = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this.smc = t), (this._queryPt = e)
  }
  isGeometryChanged() {
    return !1
  }
  checkVertexDistance(t) {
    const e = t.distance(this._queryPt)
    e > 0 && this.smc.updateClearance(e, this._queryPt, t)
  }
  filter(t, e) {
    this.checkVertexDistance(t.getCoordinate(e)),
      e > 0 && this.checkSegmentDistance(t.getCoordinate(e - 1), t.getCoordinate(e))
  }
  checkSegmentDistance(t, e) {
    if (this._queryPt.equals2D(t) || this._queryPt.equals2D(e)) return null
    const n = ou.pointToSegment(this._queryPt, e, t)
    n > 0 && this.smc.updateClearance(n, this._queryPt, e, t)
  }
  isDone() {
    return !1
  }
  get interfaces_() {
    return [Zc]
  }
}
;(Jm.VertexCoordinateFilter = Qm), (Jm.ComputeMCCoordinateSequenceFilter = $m)
class ty {
  constructor() {
    ty.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pts = null),
      (this._usePt = null),
      (this._distanceTolerance = null),
      (this._seg = new dd())
    const t = arguments[0]
    this._pts = t
  }
  static simplify(t, e) {
    const n = new ty(t)
    return n.setDistanceTolerance(e), n.simplify()
  }
  simplifySection(t, e) {
    if (t + 1 === e) return null
    ;(this._seg.p0 = this._pts[t]), (this._seg.p1 = this._pts[e])
    let n = -1,
      i = t
    for (let s = t + 1; s < e; s++) {
      const t = this._seg.distance(this._pts[s])
      t > n && ((n = t), (i = s))
    }
    if (n <= this._distanceTolerance) for (let n = t + 1; n < e; n++) this._usePt[n] = !1
    else this.simplifySection(t, i), this.simplifySection(i, e)
  }
  setDistanceTolerance(t) {
    this._distanceTolerance = t
  }
  simplify() {
    this._usePt = new Array(this._pts.length).fill(null)
    for (let t = 0; t < this._pts.length; t++) this._usePt[t] = !0
    this.simplifySection(0, this._pts.length - 1)
    const t = new qc()
    for (let e = 0; e < this._pts.length; e++) this._usePt[e] && t.add(new Oc(this._pts[e]))
    return t.toCoordinateArray()
  }
}
class ey {
  constructor() {
    ey.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._distanceTolerance = null), (this._isEnsureValidTopology = !0)
    const t = arguments[0]
    this._inputGeom = t
  }
  static simplify(t, e) {
    const n = new ey(t)
    return n.setDistanceTolerance(e), n.getResultGeometry()
  }
  setEnsureValid(t) {
    this._isEnsureValidTopology = t
  }
  getResultGeometry() {
    return this._inputGeom.isEmpty()
      ? this._inputGeom.copy()
      : new ny(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom)
  }
  setDistanceTolerance(t) {
    if (t < 0) throw new Ec('Tolerance must be non-negative')
    this._distanceTolerance = t
  }
}
class ny extends Nd {
  constructor() {
    super(), ny.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isEnsureValidTopology = !0), (this._distanceTolerance = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._isEnsureValidTopology = t), (this._distanceTolerance = e)
  }
  transformPolygon(t, e) {
    if (t.isEmpty()) return null
    const n = super.transformPolygon.call(this, t, e)
    return e instanceof Ou ? n : this.createValidArea(n)
  }
  createValidArea(t) {
    return this._isEnsureValidTopology ? t.buffer(0) : t
  }
  transformCoordinates(t, e) {
    const n = t.toCoordinateArray()
    let i = null
    return (
      (i = 0 === n.length ? new Array(0).fill(null) : ty.simplify(n, this._distanceTolerance)),
      this._factory.getCoordinateSequenceFactory().create(i)
    )
  }
  transformMultiPolygon(t, e) {
    const n = super.transformMultiPolygon.call(this, t, e)
    return this.createValidArea(n)
  }
  transformLinearRing(t, e) {
    const n = e instanceof Eu,
      i = super.transformLinearRing.call(this, t, e)
    return !n || i instanceof Ru ? i : null
  }
}
ey.DPTransformer = ny
class iy extends dd {
  constructor() {
    super(), iy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._parent = null), (this._index = null), 2 === arguments.length)) {
      const t = arguments[0],
        e = arguments[1]
      iy.constructor_.call(this, t, e, null, -1)
    } else if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3]
      dd.constructor_.call(this, t, e), (this._parent = n), (this._index = i)
    }
  }
  getIndex() {
    return this._index
  }
  getParent() {
    return this._parent
  }
}
class sy {
  constructor() {
    sy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (
      ((this._parentLine = null),
      (this._segs = null),
      (this._resultSegs = new Yc()),
      (this._minimumSize = null),
      1 === arguments.length)
    ) {
      const t = arguments[0]
      sy.constructor_.call(this, t, 2)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      ;(this._parentLine = t), (this._minimumSize = e), this.init()
    }
  }
  static extractCoordinates(t) {
    const e = new Array(t.size() + 1).fill(null)
    let n = null
    for (let i = 0; i < t.size(); i++) (n = t.get(i)), (e[i] = n.p0)
    return (e[e.length - 1] = n.p1), e
  }
  addToResult(t) {
    this._resultSegs.add(t)
  }
  asLineString() {
    return this._parentLine.getFactory().createLineString(sy.extractCoordinates(this._resultSegs))
  }
  getResultSize() {
    const t = this._resultSegs.size()
    return 0 === t ? 0 : t + 1
  }
  getParent() {
    return this._parentLine
  }
  getSegment(t) {
    return this._segs[t]
  }
  getParentCoordinates() {
    return this._parentLine.getCoordinates()
  }
  getMinimumSize() {
    return this._minimumSize
  }
  asLinearRing() {
    return this._parentLine.getFactory().createLinearRing(sy.extractCoordinates(this._resultSegs))
  }
  getSegments() {
    return this._segs
  }
  init() {
    const t = this._parentLine.getCoordinates()
    this._segs = new Array(t.length - 1).fill(null)
    for (let e = 0; e < t.length - 1; e++) {
      const n = new iy(t[e], t[e + 1], this._parentLine, e)
      this._segs[e] = n
    }
  }
  getResultCoordinates() {
    return sy.extractCoordinates(this._resultSegs)
  }
}
class ry {
  constructor() {
    ry.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._index = new yg()
  }
  remove(t) {
    this._index.remove(new Xc(t.p0, t.p1), t)
  }
  add() {
    if (arguments[0] instanceof sy) {
      const t = arguments[0].getSegments()
      for (let e = 0; e < t.length; e++) {
        const n = t[e]
        this.add(n)
      }
    } else if (arguments[0] instanceof dd) {
      const t = arguments[0]
      this._index.insert(new Xc(t.p0, t.p1), t)
    }
  }
  query(t) {
    const e = new Xc(t.p0, t.p1),
      n = new oy(t)
    this._index.query(e, n)
    return n.getItems()
  }
}
class oy {
  constructor() {
    oy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._querySeg = null), (this._items = new Yc())
    const t = arguments[0]
    this._querySeg = t
  }
  visitItem(t) {
    const e = t
    Xc.intersects(e.p0, e.p1, this._querySeg.p0, this._querySeg.p1) && this._items.add(t)
  }
  getItems() {
    return this._items
  }
  get interfaces_() {
    return [Xd]
  }
}
class ay {
  constructor() {
    ay.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._li = new ud()),
      (this._inputIndex = new ry()),
      (this._outputIndex = new ry()),
      (this._line = null),
      (this._linePts = null),
      (this._distanceTolerance = 0)
    const t = arguments[0],
      e = arguments[1]
    ;(this._inputIndex = t), (this._outputIndex = e)
  }
  static isInLineSection(t, e, n) {
    if (n.getParent() !== t.getParent()) return !1
    const i = n.getIndex()
    return i >= e[0] && i < e[1]
  }
  flatten(t, e) {
    const n = this._linePts[t],
      i = this._linePts[e],
      s = new dd(n, i)
    return this.remove(this._line, t, e), this._outputIndex.add(s), s
  }
  hasBadIntersection(t, e, n) {
    return !!this.hasBadOutputIntersection(n) || !!this.hasBadInputIntersection(t, e, n)
  }
  setDistanceTolerance(t) {
    this._distanceTolerance = t
  }
  simplifySection(t, e, n) {
    n += 1
    const i = new Array(2).fill(null)
    if (t + 1 === e) {
      const e = this._line.getSegment(t)
      return this._line.addToResult(e), null
    }
    let s = !0
    if (this._line.getResultSize() < this._line.getMinimumSize()) {
      n + 1 < this._line.getMinimumSize() && (s = !1)
    }
    const r = new Array(1).fill(null),
      o = this.findFurthestPoint(this._linePts, t, e, r)
    r[0] > this._distanceTolerance && (s = !1)
    const a = new dd()
    if (
      ((a.p0 = this._linePts[t]),
      (a.p1 = this._linePts[e]),
      (i[0] = t),
      (i[1] = e),
      this.hasBadIntersection(this._line, i, a) && (s = !1),
      s)
    ) {
      const n = this.flatten(t, e)
      return this._line.addToResult(n), null
    }
    this.simplifySection(t, o, n), this.simplifySection(o, e, n)
  }
  hasBadOutputIntersection(t) {
    for (let e = this._outputIndex.query(t).iterator(); e.hasNext(); ) {
      const n = e.next()
      if (this.hasInteriorIntersection(n, t)) return !0
    }
    return !1
  }
  findFurthestPoint(t, e, n, i) {
    const s = new dd()
    ;(s.p0 = t[e]), (s.p1 = t[n])
    let r = -1,
      o = e
    for (let i = e + 1; i < n; i++) {
      const e = t[i],
        n = s.distance(e)
      n > r && ((r = n), (o = i))
    }
    return (i[0] = r), o
  }
  simplify(t) {
    ;(this._line = t),
      (this._linePts = t.getParentCoordinates()),
      this.simplifySection(0, this._linePts.length - 1, 0)
  }
  remove(t, e, n) {
    for (let i = e; i < n; i++) {
      const e = t.getSegment(i)
      this._inputIndex.remove(e)
    }
  }
  hasInteriorIntersection(t, e) {
    return this._li.computeIntersection(t.p0, t.p1, e.p0, e.p1), this._li.isInteriorIntersection()
  }
  hasBadInputIntersection(t, e, n) {
    for (let i = this._inputIndex.query(n).iterator(); i.hasNext(); ) {
      const s = i.next()
      if (this.hasInteriorIntersection(s, n)) {
        if (ay.isInLineSection(t, e, s)) continue
        return !0
      }
    }
    return !1
  }
}
class ly {
  constructor() {
    ly.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputIndex = new ry()), (this._outputIndex = new ry()), (this._distanceTolerance = 0)
  }
  setDistanceTolerance(t) {
    this._distanceTolerance = t
  }
  simplify(t) {
    for (let e = t.iterator(); e.hasNext(); ) this._inputIndex.add(e.next())
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = new ay(this._inputIndex, this._outputIndex)
      t.setDistanceTolerance(this._distanceTolerance), t.simplify(e.next())
    }
  }
}
class hy {
  constructor() {
    hy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._lineSimplifier = new ly()), (this._linestringMap = null)
    const t = arguments[0]
    this._inputGeom = t
  }
  static simplify(t, e) {
    const n = new hy(t)
    return n.setDistanceTolerance(e), n.getResultGeometry()
  }
  getResultGeometry() {
    if (this._inputGeom.isEmpty()) return this._inputGeom.copy()
    ;(this._linestringMap = new Bu()),
      this._inputGeom.apply(new uy(this)),
      this._lineSimplifier.simplify(this._linestringMap.values())
    return new cy(this._linestringMap).transform(this._inputGeom)
  }
  setDistanceTolerance(t) {
    if (t < 0) throw new Ec('Tolerance must be non-negative')
    this._lineSimplifier.setDistanceTolerance(t)
  }
}
class cy extends Nd {
  constructor() {
    super(), cy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._linestringMap = null
    const t = arguments[0]
    this._linestringMap = t
  }
  transformCoordinates(t, e) {
    if (0 === t.size()) return null
    if (e instanceof mu) {
      const t = this._linestringMap.get(e)
      return this.createCoordinateSequence(t.getResultCoordinates())
    }
    return super.transformCoordinates.call(this, t, e)
  }
}
class uy {
  constructor() {
    uy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this.tps = null
    const t = arguments[0]
    this.tps = t
  }
  filter(t) {
    if (t instanceof mu) {
      const e = t
      if (e.isEmpty()) return null
      const n = e.isClosed() ? 4 : 2,
        i = new sy(e, n)
      this.tps._linestringMap.put(e, i)
    }
  }
  get interfaces_() {
    return [lu]
  }
}
;(hy.LineStringTransformer = cy), (hy.LineStringMapBuilderFilter = uy)
class dy {
  constructor() {
    dy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pts = null), (this._tolerance = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._pts = t), (this._tolerance = e * e)
  }
  static simplify(t, e) {
    return new dy(t, e).simplify()
  }
  simplifyVertex(t) {
    let e = t,
      n = e.getArea(),
      i = null
    for (; null !== e; ) {
      const t = e.getArea()
      t < n && ((n = t), (i = e)), (e = e._next)
    }
    return null !== i && n < this._tolerance && i.remove(), t.isLive() ? n : -1
  }
  simplify() {
    const t = py.buildLine(this._pts)
    let e = this._tolerance
    do {
      e = this.simplifyVertex(t)
    } while (e < this._tolerance)
    const n = t.getCoordinates()
    return n.length < 2 ? [n[0], new Oc(n[0])] : n
  }
}
class py {
  constructor() {
    py.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._pt = null),
      (this._prev = null),
      (this._next = null),
      (this._area = py.MAX_AREA),
      (this._isLive = !0)
    const t = arguments[0]
    this._pt = t
  }
  static buildLine(t) {
    let e = null,
      n = null
    for (let i = 0; i < t.length; i++) {
      const s = new py(t[i])
      null === e && (e = s), s.setPrev(n), null !== n && (n.setNext(s), n.updateArea()), (n = s)
    }
    return e
  }
  getCoordinates() {
    const t = new qc()
    let e = this
    do {
      t.add(e._pt, !1), (e = e._next)
    } while (null !== e)
    return t.toCoordinateArray()
  }
  getArea() {
    return this._area
  }
  updateArea() {
    if (null === this._prev || null === this._next) return (this._area = py.MAX_AREA), null
    this._area = Math.abs(xd.area(this._prev._pt, this._pt, this._next._pt))
  }
  remove() {
    const t = this._prev,
      e = this._next
    let n = null
    return (
      null !== this._prev && (this._prev.setNext(e), this._prev.updateArea(), (n = this._prev)),
      null !== this._next &&
        (this._next.setPrev(t), this._next.updateArea(), null === n && (n = this._next)),
      (this._isLive = !1),
      n
    )
  }
  isLive() {
    return this._isLive
  }
  setPrev(t) {
    this._prev = t
  }
  setNext(t) {
    this._next = t
  }
}
;(py.MAX_AREA = Mc.MAX_VALUE), (dy.VWVertex = py)
class gy {
  constructor() {
    gy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._inputGeom = null), (this._distanceTolerance = null), (this._isEnsureValidTopology = !0)
    const t = arguments[0]
    this._inputGeom = t
  }
  static simplify(t, e) {
    const n = new gy(t)
    return n.setDistanceTolerance(e), n.getResultGeometry()
  }
  setEnsureValid(t) {
    this._isEnsureValidTopology = t
  }
  getResultGeometry() {
    return this._inputGeom.isEmpty()
      ? this._inputGeom.copy()
      : new fy(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom)
  }
  setDistanceTolerance(t) {
    if (t < 0) throw new Ec('Tolerance must be non-negative')
    this._distanceTolerance = t
  }
}
class fy extends Nd {
  constructor() {
    super(), fy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isEnsureValidTopology = !0), (this._distanceTolerance = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._isEnsureValidTopology = t), (this._distanceTolerance = e)
  }
  transformPolygon(t, e) {
    if (t.isEmpty()) return null
    const n = super.transformPolygon.call(this, t, e)
    return e instanceof Ou ? n : this.createValidArea(n)
  }
  createValidArea(t) {
    return this._isEnsureValidTopology ? t.buffer(0) : t
  }
  transformCoordinates(t, e) {
    const n = t.toCoordinateArray()
    let i = null
    return (
      (i = 0 === n.length ? new Array(0).fill(null) : dy.simplify(n, this._distanceTolerance)),
      this._factory.getCoordinateSequenceFactory().create(i)
    )
  }
  transformMultiPolygon(t, e) {
    const n = super.transformMultiPolygon.call(this, t, e)
    return this.createValidArea(n)
  }
  transformLinearRing(t, e) {
    const n = e instanceof Eu,
      i = super.transformLinearRing.call(this, t, e)
    return !n || i instanceof Ru ? i : null
  }
}
gy.VWTransformer = fy
var my = Object.freeze({
  __proto__: null,
  DouglasPeuckerSimplifier: ey,
  TopologyPreservingSimplifier: hy,
  VWSimplifier: gy
})
class yy {
  constructor() {
    yy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._seg = null), (this._segLen = null), (this._splitPt = null), (this._minimumLen = 0)
    const t = arguments[0]
    ;(this._seg = t), (this._segLen = t.getLength())
  }
  static pointAlongReverse(t, e) {
    const n = new Oc()
    return (n.x = t.p1.x - e * (t.p1.x - t.p0.x)), (n.y = t.p1.y - e * (t.p1.y - t.p0.y)), n
  }
  splitAt() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = this._minimumLen / this._segLen
      if (t.distance(this._seg.p0) < this._minimumLen)
        return (this._splitPt = this._seg.pointAlong(e)), null
      if (t.distance(this._seg.p1) < this._minimumLen)
        return (this._splitPt = yy.pointAlongReverse(this._seg, e)), null
      this._splitPt = t
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = this.getConstrainedLength(t) / this._segLen
      e.equals2D(this._seg.p0)
        ? (this._splitPt = this._seg.pointAlong(n))
        : (this._splitPt = yy.pointAlongReverse(this._seg, n))
    }
  }
  setMinimumLength(t) {
    this._minimumLen = t
  }
  getConstrainedLength(t) {
    return t < this._minimumLen ? this._minimumLen : t
  }
  getSplitPoint() {
    return this._splitPt
  }
}
class xy {
  findSplitPoint(t, e) {}
}
class vy {
  static projectedSplitPoint(t, e) {
    return t.getLineSegment().project(e)
  }
  findSplitPoint(t, e) {
    const n = t.getLineSegment(),
      i = n.getLength() / 2,
      s = new yy(n),
      r = vy.projectedSplitPoint(t, e)
    let o = 2 * r.distance(e) * 0.8
    return o > i && (o = i), s.setMinimumLength(o), s.splitAt(r), s.getSplitPoint()
  }
  get interfaces_() {
    return [xy]
  }
}
class _y {
  static triArea(t, e, n) {
    return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x)
  }
  static isInCircleDDNormalized(t, e, n, i) {
    const s = $c.valueOf(t.x).selfSubtract(i.x),
      r = $c.valueOf(t.y).selfSubtract(i.y),
      o = $c.valueOf(e.x).selfSubtract(i.x),
      a = $c.valueOf(e.y).selfSubtract(i.y),
      l = $c.valueOf(n.x).selfSubtract(i.x),
      h = $c.valueOf(n.y).selfSubtract(i.y),
      c = s.multiply(a).selfSubtract(o.multiply(r)),
      u = o.multiply(h).selfSubtract(l.multiply(a)),
      d = l.multiply(r).selfSubtract(s.multiply(h)),
      p = s.multiply(s).selfAdd(r.multiply(r)),
      g = o.multiply(o).selfAdd(a.multiply(a)),
      f = l.multiply(l).selfAdd(h.multiply(h))
    return p.selfMultiply(u).selfAdd(g.selfMultiply(d)).selfAdd(f.selfMultiply(c)).doubleValue() > 0
  }
  static checkRobustInCircle(t, e, n, i) {
    const s = _y.isInCircleNonRobust(t, e, n, i),
      r = _y.isInCircleDDSlow(t, e, n, i),
      o = _y.isInCircleCC(t, e, n, i),
      a = xd.circumcentre(t, e, n)
    su.out.println('p radius diff a = ' + Math.abs(i.distance(a) - t.distance(a)) / t.distance(a)),
      (s === r && s === o) ||
        (su.out.println(
          'inCircle robustness failure (double result = ' +
            s +
            ', DD result = ' +
            r +
            ', CC result = ' +
            o +
            ')'
        ),
        su.out.println(hd.toLineString(new Pu([t, e, n, i]))),
        su.out.println('Circumcentre = ' + hd.toPoint(a) + ' radius = ' + t.distance(a)),
        su.out.println('p radius diff a = ' + Math.abs(i.distance(a) / t.distance(a) - 1)),
        su.out.println('p radius diff b = ' + Math.abs(i.distance(a) / e.distance(a) - 1)),
        su.out.println('p radius diff c = ' + Math.abs(i.distance(a) / n.distance(a) - 1)),
        su.out.println())
  }
  static isInCircleDDFast(t, e, n, i) {
    const s = $c
        .sqr(t.x)
        .selfAdd($c.sqr(t.y))
        .selfMultiply(_y.triAreaDDFast(e, n, i)),
      r = $c
        .sqr(e.x)
        .selfAdd($c.sqr(e.y))
        .selfMultiply(_y.triAreaDDFast(t, n, i)),
      o = $c
        .sqr(n.x)
        .selfAdd($c.sqr(n.y))
        .selfMultiply(_y.triAreaDDFast(t, e, i)),
      a = $c
        .sqr(i.x)
        .selfAdd($c.sqr(i.y))
        .selfMultiply(_y.triAreaDDFast(t, e, n))
    return s.selfSubtract(r).selfAdd(o).selfSubtract(a).doubleValue() > 0
  }
  static isInCircleCC(t, e, n, i) {
    const s = xd.circumcentre(t, e, n),
      r = t.distance(s)
    return i.distance(s) - r <= 0
  }
  static isInCircleNormalized(t, e, n, i) {
    const s = t.x - i.x,
      r = t.y - i.y,
      o = e.x - i.x,
      a = e.y - i.y,
      l = n.x - i.x,
      h = n.y - i.y
    return (
      (s * s + r * r) * (o * h - l * a) +
        (o * o + a * a) * (l * r - s * h) +
        (l * l + h * h) * (s * a - o * r) >
      0
    )
  }
  static isInCircleDDSlow(t, e, n, i) {
    const s = $c.valueOf(i.x),
      r = $c.valueOf(i.y),
      o = $c.valueOf(t.x),
      a = $c.valueOf(t.y),
      l = $c.valueOf(e.x),
      h = $c.valueOf(e.y),
      c = $c.valueOf(n.x),
      u = $c.valueOf(n.y),
      d = o
        .multiply(o)
        .add(a.multiply(a))
        .multiply(_y.triAreaDDSlow(l, h, c, u, s, r)),
      p = l
        .multiply(l)
        .add(h.multiply(h))
        .multiply(_y.triAreaDDSlow(o, a, c, u, s, r)),
      g = c
        .multiply(c)
        .add(u.multiply(u))
        .multiply(_y.triAreaDDSlow(o, a, l, h, s, r)),
      f = s
        .multiply(s)
        .add(r.multiply(r))
        .multiply(_y.triAreaDDSlow(o, a, l, h, c, u))
    return d.subtract(p).add(g).subtract(f).doubleValue() > 0
  }
  static isInCircleNonRobust(t, e, n, i) {
    return (
      (t.x * t.x + t.y * t.y) * _y.triArea(e, n, i) -
        (e.x * e.x + e.y * e.y) * _y.triArea(t, n, i) +
        (n.x * n.x + n.y * n.y) * _y.triArea(t, e, i) -
        (i.x * i.x + i.y * i.y) * _y.triArea(t, e, n) >
      0
    )
  }
  static isInCircleRobust(t, e, n, i) {
    return _y.isInCircleNormalized(t, e, n, i)
  }
  static triAreaDDSlow(t, e, n, i, s, r) {
    return n
      .subtract(t)
      .multiply(r.subtract(e))
      .subtract(i.subtract(e).multiply(s.subtract(t)))
  }
  static triAreaDDFast(t, e, n) {
    const i = $c.valueOf(e.x).selfSubtract(t.x).selfMultiply($c.valueOf(n.y).selfSubtract(t.y)),
      s = $c.valueOf(e.y).selfSubtract(t.y).selfMultiply($c.valueOf(n.x).selfSubtract(t.x))
    return i.selfSubtract(s)
  }
}
class wy {
  constructor() {
    wy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._p = null), 1 === arguments.length)) {
      const t = arguments[0]
      this._p = new Oc(t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      this._p = new Oc(t, e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      this._p = new Oc(t, e, n)
    }
  }
  static interpolateZ() {
    if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = e.distance(n),
        s = t.distance(e),
        r = n.getZ() - e.getZ()
      return e.getZ() + r * (s / i)
    }
    if (4 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = e.x,
        r = e.y,
        o = n.x - s,
        a = i.x - s,
        l = n.y - r,
        h = i.y - r,
        c = o * h - a * l,
        u = t.x - s,
        d = t.y - r,
        p = (h * u - a * d) / c,
        g = (-l * u + o * d) / c
      return e.getZ() + p * (n.getZ() - e.getZ()) + g * (i.getZ() - e.getZ())
    }
  }
  circleCenter(t, e) {
    const n = new wy(this.getX(), this.getY()),
      i = this.bisector(n, t),
      s = this.bisector(t, e),
      r = new yd(i, s)
    let o = null
    try {
      o = new wy(r.getX(), r.getY())
    } catch (i) {
      if (!(i instanceof md)) throw i
      su.err.println('a: ' + n + '  b: ' + t + '  c: ' + e), su.err.println(i)
    }
    return o
  }
  dot(t) {
    return this._p.x * t.getX() + this._p.y * t.getY()
  }
  magn() {
    return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y)
  }
  getZ() {
    return this._p.getZ()
  }
  bisector(t, e) {
    const n = e.getX() - t.getX(),
      i = e.getY() - t.getY(),
      s = new yd(t.getX() + n / 2, t.getY() + i / 2, 1),
      r = new yd(t.getX() - i + n / 2, t.getY() + n + i / 2, 1)
    return new yd(s, r)
  }
  equals() {
    if (1 === arguments.length) {
      const t = arguments[0]
      return this._p.x === t.getX() && this._p.y === t.getY()
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      return this._p.distance(t.getCoordinate()) < e
    }
  }
  getCoordinate() {
    return this._p
  }
  isInCircle(t, e, n) {
    return _y.isInCircleRobust(t._p, e._p, n._p, this._p)
  }
  interpolateZValue(t, e, n) {
    const i = t.getX(),
      s = t.getY(),
      r = e.getX() - i,
      o = n.getX() - i,
      a = e.getY() - s,
      l = n.getY() - s,
      h = r * l - o * a,
      c = this.getX() - i,
      u = this.getY() - s,
      d = (l * c - o * u) / h,
      p = (-a * c + r * u) / h
    return t.getZ() + d * (e.getZ() - t.getZ()) + p * (n.getZ() - t.getZ())
  }
  midPoint(t) {
    const e = (this._p.x + t.getX()) / 2,
      n = (this._p.y + t.getY()) / 2,
      i = (this._p.getZ() + t.getZ()) / 2
    return new wy(e, n, i)
  }
  rightOf(t) {
    return this.isCCW(t.dest(), t.orig())
  }
  isCCW(t, e) {
    return (
      (t._p.x - this._p.x) * (e._p.y - this._p.y) - (t._p.y - this._p.y) * (e._p.x - this._p.x) > 0
    )
  }
  getX() {
    return this._p.x
  }
  crossProduct(t) {
    return this._p.x * t.getY() - this._p.y * t.getX()
  }
  setZ(t) {
    this._p.setZ(t)
  }
  times(t) {
    return new wy(t * this._p.x, t * this._p.y)
  }
  cross() {
    return new wy(this._p.y, -this._p.x)
  }
  leftOf(t) {
    return this.isCCW(t.orig(), t.dest())
  }
  toString() {
    return 'POINT (' + this._p.x + ' ' + this._p.y + ')'
  }
  sub(t) {
    return new wy(this._p.x - t.getX(), this._p.y - t.getY())
  }
  getY() {
    return this._p.y
  }
  classify(t, e) {
    const n = this,
      i = e.sub(t),
      s = n.sub(t),
      r = i.crossProduct(s)
    return r > 0
      ? wy.LEFT
      : r < 0
        ? wy.RIGHT
        : i.getX() * s.getX() < 0 || i.getY() * s.getY() < 0
          ? wy.BEHIND
          : i.magn() < s.magn()
            ? wy.BEYOND
            : t.equals(n)
              ? wy.ORIGIN
              : e.equals(n)
                ? wy.DESTINATION
                : wy.BETWEEN
  }
  sum(t) {
    return new wy(this._p.x + t.getX(), this._p.y + t.getY())
  }
  distance(t, e) {
    return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2))
  }
  circumRadiusRatio(t, e) {
    const n = this.circleCenter(t, e),
      i = this.distance(n, t)
    let s = this.distance(this, t),
      r = this.distance(t, e)
    return r < s && (s = r), (r = this.distance(e, this)), r < s && (s = r), i / s
  }
}
;(wy.LEFT = 0),
  (wy.RIGHT = 1),
  (wy.BEYOND = 2),
  (wy.BEHIND = 3),
  (wy.BETWEEN = 4),
  (wy.ORIGIN = 5),
  (wy.DESTINATION = 6)
class Ey extends wy {
  constructor() {
    super(), Ey.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._isOnConstraint = null), (this._constraint = null)
    const t = arguments[0]
    wy.constructor_.call(this, t)
  }
  getConstraint() {
    return this._constraint
  }
  setOnConstraint(t) {
    this._isOnConstraint = t
  }
  merge(t) {
    t._isOnConstraint && ((this._isOnConstraint = !0), (this._constraint = t._constraint))
  }
  isOnConstraint() {
    return this._isOnConstraint
  }
  setConstraint(t) {
    ;(this._isOnConstraint = !0), (this._constraint = t)
  }
}
class by {
  constructor() {
    by.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._rot = null), (this._vertex = null), (this._next = null), (this._data = null)
  }
  static makeEdge(t, e) {
    const n = new by(),
      i = new by(),
      s = new by(),
      r = new by()
    ;(n._rot = i),
      (i._rot = s),
      (s._rot = r),
      (r._rot = n),
      n.setNext(n),
      i.setNext(r),
      s.setNext(s),
      r.setNext(i)
    const o = n
    return o.setOrig(t), o.setDest(e), o
  }
  static swap(t) {
    const e = t.oPrev(),
      n = t.sym().oPrev()
    by.splice(t, e),
      by.splice(t.sym(), n),
      by.splice(t, e.lNext()),
      by.splice(t.sym(), n.lNext()),
      t.setOrig(e.dest()),
      t.setDest(n.dest())
  }
  static splice(t, e) {
    const n = t.oNext().rot(),
      i = e.oNext().rot(),
      s = e.oNext(),
      r = t.oNext(),
      o = i.oNext(),
      a = n.oNext()
    t.setNext(s), e.setNext(r), n.setNext(o), i.setNext(a)
  }
  static connect(t, e) {
    const n = by.makeEdge(t.dest(), e.orig())
    return by.splice(n, t.lNext()), by.splice(n.sym(), e), n
  }
  equalsNonOriented(t) {
    return !!this.equalsOriented(t) || !!this.equalsOriented(t.sym())
  }
  toLineSegment() {
    return new dd(this._vertex.getCoordinate(), this.dest().getCoordinate())
  }
  dest() {
    return this.sym().orig()
  }
  oNext() {
    return this._next
  }
  equalsOriented(t) {
    return !(
      !this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) ||
      !this.dest().getCoordinate().equals2D(t.dest().getCoordinate())
    )
  }
  dNext() {
    return this.sym().oNext().sym()
  }
  lPrev() {
    return this._next.sym()
  }
  rPrev() {
    return this.sym().oNext()
  }
  rot() {
    return this._rot
  }
  oPrev() {
    return this._rot._next._rot
  }
  sym() {
    return this._rot._rot
  }
  setOrig(t) {
    this._vertex = t
  }
  lNext() {
    return this.invRot().oNext().rot()
  }
  getLength() {
    return this.orig().getCoordinate().distance(this.dest().getCoordinate())
  }
  invRot() {
    return this._rot.sym()
  }
  setDest(t) {
    this.sym().setOrig(t)
  }
  setData(t) {
    this._data = t
  }
  getData() {
    return this._data
  }
  delete() {
    this._rot = null
  }
  orig() {
    return this._vertex
  }
  rNext() {
    return this._rot._next.invRot()
  }
  toString() {
    const t = this._vertex.getCoordinate(),
      e = this.dest().getCoordinate()
    return hd.toLineString(t, e)
  }
  isLive() {
    return null !== this._rot
  }
  getPrimary() {
    return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0
      ? this
      : this.sym()
  }
  dPrev() {
    return this.invRot().oNext().invRot()
  }
  setNext(t) {
    this._next = t
  }
}
class My {
  constructor() {
    My.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._subdiv = null), (this._isUsingTolerance = !1)
    const t = arguments[0]
    ;(this._subdiv = t), (this._isUsingTolerance = t.getTolerance() > 0)
  }
  insertSite(t) {
    let e = this._subdiv.locate(t)
    if (this._subdiv.isVertexOfEdge(e, t)) return e
    this._subdiv.isOnEdge(e, t.getCoordinate()) && ((e = e.oPrev()), this._subdiv.delete(e.oNext()))
    let n = this._subdiv.makeEdge(e.orig(), t)
    by.splice(n, e)
    const i = n
    do {
      ;(n = this._subdiv.connect(e, n.sym())), (e = n.oPrev())
    } while (e.lNext() !== i)
    for (;;) {
      const s = e.oPrev()
      if (s.dest().rightOf(e) && t.isInCircle(e.orig(), s.dest(), e.dest()))
        by.swap(e), (e = e.oPrev())
      else {
        if (e.oNext() === i) return n
        e = e.oNext().lPrev()
      }
    }
  }
  insertSites(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this.insertSite(t)
    }
  }
}
class Sy {
  locate(t) {}
}
class Ay {
  constructor() {
    Ay.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._subdiv = null), (this._lastEdge = null)
    const t = arguments[0]
    ;(this._subdiv = t), this.init()
  }
  init() {
    this._lastEdge = this.findEdge()
  }
  locate(t) {
    this._lastEdge.isLive() || this.init()
    const e = this._subdiv.locateFromEdge(t, this._lastEdge)
    return (this._lastEdge = e), e
  }
  findEdge() {
    return this._subdiv.getEdges().iterator().next()
  }
  get interfaces_() {
    return [Sy]
  }
}
class Ty extends Rc {
  constructor() {
    super(), Ty.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._seg = null), 1 === arguments.length)) {
      if ('string' == typeof arguments[0]) {
        const t = arguments[0]
        Rc.constructor_.call(this, t)
      } else if (arguments[0] instanceof dd) {
        const t = arguments[0]
        Rc.constructor_.call(
          this,
          'Locate failed to converge (at edge: ' +
            t +
            ').  Possible causes include invalid Subdivision topology or very close sites'
        ),
          (this._seg = new dd(t))
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      Rc.constructor_.call(this, Ty.msgWithSpatial(t, e)), (this._seg = new dd(e))
    }
  }
  static msgWithSpatial(t, e) {
    return null !== e ? t + ' [ ' + e + ' ]' : t
  }
  getSegment() {
    return this._seg
  }
}
class Iy {
  visit(t) {}
}
class Ry {
  constructor() {
    Ry.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._visitedKey = 0),
      (this._quadEdges = new Yc()),
      (this._startingEdge = null),
      (this._tolerance = null),
      (this._edgeCoincidenceTolerance = null),
      (this._frameVertex = new Array(3).fill(null)),
      (this._frameEnv = null),
      (this._locator = null),
      (this._seg = new dd()),
      (this._triEdges = new Array(3).fill(null))
    const t = arguments[0],
      e = arguments[1]
    ;(this._tolerance = e),
      (this._edgeCoincidenceTolerance = e / Ry.EDGE_COINCIDENCE_TOL_FACTOR),
      this.createFrame(t),
      (this._startingEdge = this.initSubdiv()),
      (this._locator = new Ay(this))
  }
  static getTriangleEdges(t, e) {
    if (((e[0] = t), (e[1] = e[0].lNext()), (e[2] = e[1].lNext()), e[2].lNext() !== e[0]))
      throw new Ec('Edges do not form a triangle')
  }
  getTriangleVertices(t) {
    const e = new Ny()
    return this.visitTriangles(e, t), e.getTriangleVertices()
  }
  isFrameVertex(t) {
    return (
      !!t.equals(this._frameVertex[0]) ||
      !!t.equals(this._frameVertex[1]) ||
      !!t.equals(this._frameVertex[2])
    )
  }
  isVertexOfEdge(t, e) {
    return !(!e.equals(t.orig(), this._tolerance) && !e.equals(t.dest(), this._tolerance))
  }
  connect(t, e) {
    const n = by.connect(t, e)
    return this._quadEdges.add(n), n
  }
  getVoronoiCellPolygon(t, e) {
    const n = new Yc(),
      i = t
    do {
      const e = t.rot().orig().getCoordinate()
      n.add(e), (t = t.oPrev())
    } while (t !== i)
    const s = new qc()
    s.addAll(n, !1),
      s.closeRing(),
      s.size() < 4 && (su.out.println(s), s.add(s.get(s.size() - 1), !0))
    const r = s.toCoordinateArray(),
      o = e.createPolygon(e.createLinearRing(r)),
      a = i.orig()
    return o.setUserData(a.getCoordinate()), o
  }
  setLocator(t) {
    this._locator = t
  }
  initSubdiv() {
    const t = this.makeEdge(this._frameVertex[0], this._frameVertex[1]),
      e = this.makeEdge(this._frameVertex[1], this._frameVertex[2])
    by.splice(t.sym(), e)
    const n = this.makeEdge(this._frameVertex[2], this._frameVertex[0])
    return by.splice(e.sym(), n), by.splice(n.sym(), t), t
  }
  isFrameBorderEdge(t) {
    const e = new Array(3).fill(null)
    Ry.getTriangleEdges(t, e)
    const n = new Array(3).fill(null)
    Ry.getTriangleEdges(t.sym(), n)
    const i = t.lNext().dest()
    if (this.isFrameVertex(i)) return !0
    const s = t.sym().lNext().dest()
    return !!this.isFrameVertex(s)
  }
  makeEdge(t, e) {
    const n = by.makeEdge(t, e)
    return this._quadEdges.add(n), n
  }
  visitTriangles(t, e) {
    this._visitedKey++
    const n = new pp()
    n.push(this._startingEdge)
    const i = new Gu()
    for (; !n.empty(); ) {
      const s = n.pop()
      if (!i.contains(s)) {
        const r = this.fetchTriangleToVisit(s, n, e, i)
        null !== r && t.visit(r)
      }
    }
  }
  isFrameEdge(t) {
    return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()))
  }
  isOnEdge(t, e) {
    this._seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate())
    return this._seg.distance(e) < this._edgeCoincidenceTolerance
  }
  getEnvelope() {
    return new Xc(this._frameEnv)
  }
  createFrame(t) {
    const e = t.getWidth(),
      n = t.getHeight()
    let i = 0
    ;(i = e > n ? 10 * e : 10 * n),
      (this._frameVertex[0] = new wy((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + i)),
      (this._frameVertex[1] = new wy(t.getMinX() - i, t.getMinY() - i)),
      (this._frameVertex[2] = new wy(t.getMaxX() + i, t.getMinY() - i)),
      (this._frameEnv = new Xc(
        this._frameVertex[0].getCoordinate(),
        this._frameVertex[1].getCoordinate()
      )),
      this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())
  }
  getTriangleCoordinates(t) {
    const e = new Py()
    return this.visitTriangles(e, t), e.getTriangles()
  }
  getVertices(t) {
    const e = new Gu()
    for (let n = this._quadEdges.iterator(); n.hasNext(); ) {
      const i = n.next(),
        s = i.orig()
      ;(!t && this.isFrameVertex(s)) || e.add(s)
      const r = i.dest()
      ;(!t && this.isFrameVertex(r)) || e.add(r)
    }
    return e
  }
  fetchTriangleToVisit(t, e, n, i) {
    let s = t,
      r = 0,
      o = !1
    do {
      ;(this._triEdges[r] = s), this.isFrameEdge(s) && (o = !0)
      const t = s.sym()
      i.contains(t) || e.push(t), i.add(s), r++, (s = s.lNext())
    } while (s !== t)
    return o && !n ? null : this._triEdges
  }
  getEdges() {
    if (0 === arguments.length) return this._quadEdges
    if (1 === arguments.length) {
      const t = arguments[0],
        e = this.getPrimaryEdges(!1),
        n = new Array(e.size()).fill(null)
      let i = 0
      for (let s = e.iterator(); s.hasNext(); ) {
        const e = s.next()
        n[i++] = t.createLineString([e.orig().getCoordinate(), e.dest().getCoordinate()])
      }
      return t.createMultiLineString(n)
    }
  }
  getVertexUniqueEdges(t) {
    const e = new Yc(),
      n = new Gu()
    for (let i = this._quadEdges.iterator(); i.hasNext(); ) {
      const s = i.next(),
        r = s.orig()
      n.contains(r) || (n.add(r), (!t && this.isFrameVertex(r)) || e.add(s))
      const o = s.sym(),
        a = o.orig()
      n.contains(a) || (n.add(a), (!t && this.isFrameVertex(a)) || e.add(o))
    }
    return e
  }
  getTriangleEdges(t) {
    const e = new Cy()
    return this.visitTriangles(e, t), e.getTriangleEdges()
  }
  getPrimaryEdges(t) {
    this._visitedKey++
    const e = new Yc(),
      n = new pp()
    n.push(this._startingEdge)
    const i = new Gu()
    for (; !n.empty(); ) {
      const s = n.pop()
      if (!i.contains(s)) {
        const r = s.getPrimary()
        ;(!t && this.isFrameEdge(r)) || e.add(r),
          n.push(s.oNext()),
          n.push(s.sym().oNext()),
          i.add(s),
          i.add(s.sym())
      }
    }
    return e
  }
  delete(t) {
    by.splice(t, t.oPrev()), by.splice(t.sym(), t.sym().oPrev())
    const e = t.sym(),
      n = t.rot(),
      i = t.rot().sym()
    this._quadEdges.remove(t),
      this._quadEdges.remove(e),
      this._quadEdges.remove(n),
      this._quadEdges.remove(i),
      t.delete(),
      e.delete(),
      n.delete(),
      i.delete()
  }
  locateFromEdge(t, e) {
    let n = 0
    const i = this._quadEdges.size()
    let s = e
    for (;;) {
      if ((n++, n > i)) throw new Ty(s.toLineSegment())
      if (t.equals(s.orig()) || t.equals(s.dest())) break
      if (t.rightOf(s)) s = s.sym()
      else if (t.rightOf(s.oNext())) {
        if (t.rightOf(s.dPrev())) break
        s = s.dPrev()
      } else s = s.oNext()
    }
    return s
  }
  getTolerance() {
    return this._tolerance
  }
  getVoronoiCellPolygons(t) {
    this.visitTriangles(new Ly(), !0)
    const e = new Yc()
    for (let n = this.getVertexUniqueEdges(!1).iterator(); n.hasNext(); ) {
      const i = n.next()
      e.add(this.getVoronoiCellPolygon(i, t))
    }
    return e
  }
  getVoronoiDiagram(t) {
    const e = this.getVoronoiCellPolygons(t)
    return t.createGeometryCollection(ku.toGeometryArray(e))
  }
  getTriangles(t) {
    const e = this.getTriangleCoordinates(!1),
      n = new Array(e.size()).fill(null)
    let i = 0
    for (let s = e.iterator(); s.hasNext(); ) {
      const e = s.next()
      n[i++] = t.createPolygon(t.createLinearRing(e))
    }
    return t.createGeometryCollection(n)
  }
  insertSite(t) {
    let e = this.locate(t)
    if (t.equals(e.orig(), this._tolerance) || t.equals(e.dest(), this._tolerance)) return e
    let n = this.makeEdge(e.orig(), t)
    by.splice(n, e)
    const i = n
    do {
      ;(n = this.connect(e, n.sym())), (e = n.oPrev())
    } while (e.lNext() !== i)
    return i
  }
  locate() {
    if (1 === arguments.length) {
      if (arguments[0] instanceof wy) {
        const t = arguments[0]
        return this._locator.locate(t)
      }
      if (arguments[0] instanceof Oc) {
        const t = arguments[0]
        return this._locator.locate(new wy(t))
      }
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = this._locator.locate(new wy(t))
      if (null === n) return null
      let i = n
      n.dest().getCoordinate().equals2D(t) && (i = n.sym())
      let s = i
      do {
        if (s.dest().getCoordinate().equals2D(e)) return s
        s = s.oNext()
      } while (s !== i)
      return null
    }
  }
}
class Ly {
  visit(t) {
    const e = t[0].orig().getCoordinate(),
      n = t[1].orig().getCoordinate(),
      i = t[2].orig().getCoordinate(),
      s = xd.circumcentreDD(e, n, i),
      r = new wy(s)
    for (let e = 0; e < 3; e++) t[e].rot().setOrig(r)
  }
  get interfaces_() {
    return [Iy]
  }
}
class Cy {
  constructor() {
    Cy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._triList = new Yc()
  }
  getTriangleEdges() {
    return this._triList
  }
  visit(t) {
    this._triList.add(t)
  }
  get interfaces_() {
    return [Iy]
  }
}
class Ny {
  constructor() {
    Ny.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._triList = new Yc()
  }
  visit(t) {
    this._triList.add([t[0].orig(), t[1].orig(), t[2].orig()])
  }
  getTriangleVertices() {
    return this._triList
  }
  get interfaces_() {
    return [Iy]
  }
}
class Py {
  constructor() {
    Py.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._coordList = new qc()), (this._triCoords = new Yc())
  }
  checkTriangleSize(t) {
    t.length >= 2 ? hd.toLineString(t[0], t[1]) : t.length >= 1 && hd.toPoint(t[0])
  }
  visit(t) {
    this._coordList.clear()
    for (let e = 0; e < 3; e++) {
      const n = t[e].orig()
      this._coordList.add(n.getCoordinate())
    }
    if (this._coordList.size() > 0) {
      this._coordList.closeRing()
      const t = this._coordList.toCoordinateArray()
      if (4 !== t.length) return null
      this._triCoords.add(t)
    }
  }
  getTriangles() {
    return this._triCoords
  }
  get interfaces_() {
    return [Iy]
  }
}
;(Ry.TriangleCircumcentreVisitor = Ly),
  (Ry.TriangleEdgesListVisitor = Cy),
  (Ry.TriangleVertexListVisitor = Ny),
  (Ry.TriangleCoordinatesVisitor = Py),
  (Ry.EDGE_COINCIDENCE_TOL_FACTOR = 1e3)
class Dy {
  constructor() {
    Dy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._ls = null), (this._data = null), 2 === arguments.length)) {
      const t = arguments[0],
        e = arguments[1]
      this._ls = new dd(t, e)
    } else if (3 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2]
      ;(this._ls = new dd(t, e)), (this._data = n)
    } else if (6 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5]
      Dy.constructor_.call(this, new Oc(t, e, n), new Oc(i, s, r))
    } else if (7 === arguments.length) {
      const t = arguments[0],
        e = arguments[1],
        n = arguments[2],
        i = arguments[3],
        s = arguments[4],
        r = arguments[5],
        o = arguments[6]
      Dy.constructor_.call(this, new Oc(t, e, n), new Oc(i, s, r), o)
    }
  }
  getLineSegment() {
    return this._ls
  }
  getEndZ() {
    return this._ls.getCoordinate(1).getZ()
  }
  getStartZ() {
    return this._ls.getCoordinate(0).getZ()
  }
  intersection(t) {
    return this._ls.intersection(t.getLineSegment())
  }
  getStart() {
    return this._ls.getCoordinate(0)
  }
  getEnd() {
    return this._ls.getCoordinate(1)
  }
  getEndY() {
    return this._ls.getCoordinate(1).y
  }
  getStartX() {
    return this._ls.getCoordinate(0).x
  }
  equalsTopo(t) {
    return this._ls.equalsTopo(t.getLineSegment())
  }
  getStartY() {
    return this._ls.getCoordinate(0).y
  }
  setData(t) {
    this._data = t
  }
  getData() {
    return this._data
  }
  getEndX() {
    return this._ls.getCoordinate(1).x
  }
  toString() {
    return this._ls.toString()
  }
}
class Oy extends Rc {
  constructor() {
    super(), Oy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this._pt = null), 1 === arguments.length)) {
      const t = arguments[0]
      Rc.constructor_.call(this, t)
    } else if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      Rc.constructor_.call(this, Oy.msgWithCoord(t, e)), (this._pt = new Oc(e))
    }
  }
  static msgWithCoord(t, e) {
    return null !== e ? t + ' [ ' + hd.toPoint(e) + ' ]' : t
  }
  getCoordinate() {
    return this._pt
  }
}
class Fy {
  constructor() {
    Fy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._initialVertices = null),
      (this._segVertices = null),
      (this._segments = new Yc()),
      (this._subdiv = null),
      (this._incDel = null),
      (this._convexHull = null),
      (this._splitFinder = new vy()),
      (this._kdt = null),
      (this._vertexFactory = null),
      (this._computeAreaEnv = null),
      (this._splitPt = null),
      (this._tolerance = null)
    const t = arguments[0],
      e = arguments[1]
    ;(this._initialVertices = new Yc(t)), (this._tolerance = e), (this._kdt = new lg(e))
  }
  static computeVertexEnvelope(t) {
    const e = new Xc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e.expandToInclude(t.getCoordinate())
    }
    return e
  }
  getInitialVertices() {
    return this._initialVertices
  }
  getKDT() {
    return this._kdt
  }
  enforceConstraints() {
    this.addConstraintVertices()
    let t = 0,
      e = 0
    do {
      ;(e = this.enforceGabriel(this._segments)), t++
    } while (e > 0 && t < Fy.MAX_SPLIT_ITER)
    if (t === Fy.MAX_SPLIT_ITER)
      throw new Oy(
        'Too many splitting iterations while enforcing constraints.  Last split point was at: ',
        this._splitPt
      )
  }
  insertSites(t) {
    for (let e = t.iterator(); e.hasNext(); ) {
      const t = e.next()
      this.insertSite(t)
    }
  }
  getVertexFactory() {
    return this._vertexFactory
  }
  getPointArray() {
    const t = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null)
    let e = 0
    for (let n = this._initialVertices.iterator(); n.hasNext(); ) {
      const i = n.next()
      t[e++] = i.getCoordinate()
    }
    for (let n = this._segVertices.iterator(); n.hasNext(); ) {
      const i = n.next()
      t[e++] = i.getCoordinate()
    }
    return t
  }
  setConstraints(t, e) {
    ;(this._segments = t), (this._segVertices = e)
  }
  computeConvexHull() {
    const t = new ku(),
      e = this.getPointArray(),
      n = new fp(e, t)
    this._convexHull = n.getConvexHull()
  }
  addConstraintVertices() {
    this.computeConvexHull(), this.insertSites(this._segVertices)
  }
  findNonGabrielPoint(t) {
    const e = t.getStart(),
      n = t.getEnd(),
      i = new Oc((e.x + n.x) / 2, (e.y + n.y) / 2),
      s = e.distance(i),
      r = new Xc(i)
    r.expandBy(s)
    const o = this._kdt.query(r)
    let a = null,
      l = Mc.MAX_VALUE
    for (let t = o.iterator(); t.hasNext(); ) {
      const r = t.next().getCoordinate()
      if (r.equals2D(e) || r.equals2D(n)) continue
      const o = i.distance(r)
      if (o < s) {
        const t = o
        ;(null === a || t < l) && ((a = r), (l = t))
      }
    }
    return a
  }
  getConstraintSegments() {
    return this._segments
  }
  setSplitPointFinder(t) {
    this._splitFinder = t
  }
  getConvexHull() {
    return this._convexHull
  }
  getTolerance() {
    return this._tolerance
  }
  enforceGabriel(t) {
    const e = new Yc()
    let n = 0
    const i = new Yc()
    for (let s = t.iterator(); s.hasNext(); ) {
      const t = s.next(),
        r = this.findNonGabrielPoint(t)
      if (null === r) continue
      this._splitPt = this._splitFinder.findSplitPoint(t, r)
      const o = this.createVertex(this._splitPt, t)
      this.insertSite(o).getCoordinate().equals2D(this._splitPt)
      const a = new Dy(
          t.getStartX(),
          t.getStartY(),
          t.getStartZ(),
          o.getX(),
          o.getY(),
          o.getZ(),
          t.getData()
        ),
        l = new Dy(o.getX(), o.getY(), o.getZ(), t.getEndX(), t.getEndY(), t.getEndZ(), t.getData())
      e.add(a), e.add(l), i.add(t), (n += 1)
    }
    return t.removeAll(i), t.addAll(e), n
  }
  createVertex() {
    if (1 === arguments.length) {
      const t = arguments[0]
      let e = null
      return (
        (e = null !== this._vertexFactory ? this._vertexFactory.createVertex(t, null) : new Ey(t)),
        e
      )
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = null
      return (
        (n = null !== this._vertexFactory ? this._vertexFactory.createVertex(t, e) : new Ey(t)),
        n.setOnConstraint(!0),
        n
      )
    }
  }
  getSubdivision() {
    return this._subdiv
  }
  computeBoundingBox() {
    const t = Fy.computeVertexEnvelope(this._initialVertices),
      e = Fy.computeVertexEnvelope(this._segVertices),
      n = new Xc(t)
    n.expandToInclude(e)
    const i = 0.2 * n.getWidth(),
      s = 0.2 * n.getHeight(),
      r = Math.max(i, s)
    ;(this._computeAreaEnv = new Xc(n)), this._computeAreaEnv.expandBy(r)
  }
  setVertexFactory(t) {
    this._vertexFactory = t
  }
  formInitialDelaunay() {
    this.computeBoundingBox(),
      (this._subdiv = new Ry(this._computeAreaEnv, this._tolerance)),
      this._subdiv.setLocator(new Ay(this._subdiv)),
      (this._incDel = new My(this._subdiv)),
      this.insertSites(this._initialVertices)
  }
  insertSite() {
    if (arguments[0] instanceof Ey) {
      const t = arguments[0],
        e = this._kdt.insert(t.getCoordinate(), t)
      if (e.isRepeated()) {
        const n = e.getData()
        return n.merge(t), n
      }
      return this._incDel.insertSite(t), t
    }
    if (arguments[0] instanceof Oc) {
      const t = arguments[0]
      this.insertSite(this.createVertex(t))
    }
  }
}
Fy.MAX_SPLIT_ITER = 99
class Gy {
  constructor() {
    Gy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._siteCoords = null), (this._tolerance = 0), (this._subdiv = null)
  }
  static extractUniqueCoordinates(t) {
    if (null === t) return new qc()
    const e = t.getCoordinates()
    return Gy.unique(e)
  }
  static envelope(t) {
    const e = new Xc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e.expandToInclude(t)
    }
    return e
  }
  static unique(t) {
    const e = Cu.copyDeep(t)
    _u.sort(e)
    return new qc(e, !1)
  }
  static toVertices(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      e.add(new wy(t))
    }
    return e
  }
  create() {
    if (null !== this._subdiv) return null
    const t = Gy.envelope(this._siteCoords),
      e = Gy.toVertices(this._siteCoords)
    this._subdiv = new Ry(t, this._tolerance)
    new My(this._subdiv).insertSites(e)
  }
  setTolerance(t) {
    this._tolerance = t
  }
  setSites() {
    if (arguments[0] instanceof hu) {
      const t = arguments[0]
      this._siteCoords = Gy.extractUniqueCoordinates(t)
    } else if (Uc(arguments[0], Vc)) {
      const t = arguments[0]
      this._siteCoords = Gy.unique(Cu.toCoordinateArray(t))
    }
  }
  getEdges(t) {
    return this.create(), this._subdiv.getEdges(t)
  }
  getSubdivision() {
    return this.create(), this._subdiv
  }
  getTriangles(t) {
    return this.create(), this._subdiv.getTriangles(t)
  }
}
class zy {
  constructor() {
    zy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._siteCoords = null),
      (this._constraintLines = null),
      (this._tolerance = 0),
      (this._subdiv = null),
      (this._constraintVertexMap = new Wp())
  }
  static createConstraintSegments() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = Dd.getLines(t),
        n = new Yc()
      for (let t = e.iterator(); t.hasNext(); ) {
        const e = t.next()
        zy.createConstraintSegments(e, n)
      }
      return n
    }
    if (2 === arguments.length) {
      const t = arguments[1],
        e = arguments[0].getCoordinates()
      for (let n = 1; n < e.length; n++) t.add(new Dy(e[n - 1], e[n]))
    }
  }
  createSiteVertices(t) {
    const e = new Yc()
    for (let n = t.iterator(); n.hasNext(); ) {
      const t = n.next()
      this._constraintVertexMap.containsKey(t) || e.add(new Ey(t))
    }
    return e
  }
  create() {
    if (null !== this._subdiv) return null
    const t = Gy.envelope(this._siteCoords)
    let e = new Yc()
    null !== this._constraintLines &&
      (t.expandToInclude(this._constraintLines.getEnvelopeInternal()),
      this.createVertices(this._constraintLines),
      (e = zy.createConstraintSegments(this._constraintLines)))
    const n = this.createSiteVertices(this._siteCoords),
      i = new Fy(n, this._tolerance)
    i.setConstraints(e, new Yc(this._constraintVertexMap.values())),
      i.formInitialDelaunay(),
      i.enforceConstraints(),
      (this._subdiv = i.getSubdivision())
  }
  setTolerance(t) {
    this._tolerance = t
  }
  setConstraints(t) {
    this._constraintLines = t
  }
  setSites(t) {
    this._siteCoords = Gy.extractUniqueCoordinates(t)
  }
  getEdges(t) {
    return this.create(), this._subdiv.getEdges(t)
  }
  getSubdivision() {
    return this.create(), this._subdiv
  }
  getTriangles(t) {
    return this.create(), this._subdiv.getTriangles(t)
  }
  createVertices(t) {
    const e = t.getCoordinates()
    for (let t = 0; t < e.length; t++) {
      const n = new Ey(e[t])
      this._constraintVertexMap.put(e[t], n)
    }
  }
}
class By {
  constructor() {
    By.constructor_.apply(this, arguments)
  }
  static constructor_() {
    ;(this._siteCoords = null),
      (this._tolerance = 0),
      (this._subdiv = null),
      (this._clipEnv = null),
      (this._diagramEnv = null)
  }
  static clipGeometryCollection(t, e) {
    const n = t.getFactory().toGeometry(e),
      i = new Yc()
    for (let s = 0; s < t.getNumGeometries(); s++) {
      const r = t.getGeometryN(s)
      let o = null
      e.contains(r.getEnvelopeInternal())
        ? (o = r)
        : e.intersects(r.getEnvelopeInternal()) &&
          ((o = hm.intersection(n, r)), o.setUserData(r.getUserData())),
        null === o || o.isEmpty() || i.add(o)
    }
    return t.getFactory().createGeometryCollection(ku.toGeometryArray(i))
  }
  create() {
    if (null !== this._subdiv) return null
    const t = Gy.envelope(this._siteCoords)
    if (((this._diagramEnv = this._clipEnv), null === this._diagramEnv)) {
      this._diagramEnv = t
      const e = this._diagramEnv.getDiameter()
      this._diagramEnv.expandBy(e)
    }
    const e = Gy.toVertices(this._siteCoords)
    this._subdiv = new Ry(t, this._tolerance)
    new My(this._subdiv).insertSites(e)
  }
  getDiagram(t) {
    this.create()
    const e = this._subdiv.getVoronoiDiagram(t)
    return By.clipGeometryCollection(e, this._diagramEnv)
  }
  setTolerance(t) {
    this._tolerance = t
  }
  setSites() {
    if (arguments[0] instanceof hu) {
      const t = arguments[0]
      this._siteCoords = Gy.extractUniqueCoordinates(t)
    } else if (Uc(arguments[0], Vc)) {
      const t = arguments[0]
      this._siteCoords = Gy.unique(Cu.toCoordinateArray(t))
    }
  }
  setClipEnvelope(t) {
    this._clipEnv = t
  }
  getSubdivision() {
    return this.create(), this._subdiv
  }
}
var Uy = Object.freeze({ __proto__: null, Vertex: wy }),
  Vy = Object.freeze({
    __proto__: null,
    ConformingDelaunayTriangulationBuilder: zy,
    DelaunayTriangulationBuilder: Gy,
    VoronoiDiagramBuilder: By,
    quadedge: Uy
  })
class Hy {
  constructor() {
    Hy.constructor_.apply(this, arguments)
  }
  static constructor_() {
    this._counts = new Bu()
  }
  count(t) {
    const e = this._counts.get(t)
    return null === e ? 0 : e.count()
  }
  add(t) {
    const e = this._counts.get(t)
    null === e ? this._counts.put(t, new ky(1)) : e.increment()
  }
}
class ky {
  constructor() {
    ky.constructor_.apply(this, arguments)
  }
  static constructor_() {
    if (((this.count = 0), 0 === arguments.length));
    else if (1 === arguments.length) {
      const t = arguments[0]
      this.count = t
    }
  }
  count() {
    return this.count
  }
  increment() {
    this.count++
  }
}
function Wy() {}
function Yy() {}
function jy() {}
Hy.Counter = ky
class qy extends wc {}
function Zy() {}
class Xy {
  static chars(t, e) {
    const n = new Array(e).fill(null)
    for (let i = 0; i < e; i++) n[i] = t
    return new String(n)
  }
  static getStackTrace() {
    if (1 === arguments.length) {
      const t = arguments[0],
        e = new jy(),
        n = new Wy()
      return t.printStackTrace(n), e.toString()
    }
    if (2 === arguments.length) {
      const t = arguments[0],
        e = arguments[1]
      let n = ''
      new Yy(Xy.getStackTrace(t))
      const i = new Zy()
      for (let t = 0; t < e; t++)
        try {
          n += i.readLine() + Xy.NEWLINE
        } catch (t) {
          if (!(t instanceof qy)) throw t
          Cc.shouldNeverReachHere()
        }
      return n
    }
  }
  static spaces(t) {
    return Xy.chars(' ', t)
  }
  static split(t, e) {
    const n = e.length,
      i = new Yc()
    let s = '' + t,
      r = s.indexOf(e)
    for (; r >= 0; ) {
      const t = s.substring(0, r)
      i.add(t), (s = s.substring(r + n)), (r = s.indexOf(e))
    }
    s.length > 0 && i.add(s)
    const o = new Array(i.size()).fill(null)
    for (let t = 0; t < o.length; t++) o[t] = i.get(t)
    return o
  }
}
Xy.NEWLINE = su.getProperty('line.separator')
class Ky {
  constructor(t) {
    ;(this.rootApp = t),
      (this.pointer = new _()),
      (this.pathGroup = null),
      (this.devGroup = null),
      (this.vertexShader =
        '\n    uniform float time;\n    varying vec3 pos;\n    void main()\t{\n      pos = position;\n      vec3 p = position;\n      // p.y = sin(p.x * .1 - time) * cos(p.z * .1 - time) * 5.;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);\n    }\n  '),
      (this.fragmentShader =
        '\n    /* based on http://madebyevan.com/shaders/grid/ */\n\n    varying vec3 pos;\n    uniform float time;\n \n    float line(float width, vec3 step){\n      vec3 tempCoord = pos / step;\n\n      vec2 coord = tempCoord.xz;\n\n      vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord * width);\n      float line = min(grid.x, grid.y);\n\n      return 1. - min(line, 1.0);\n    }\n\n    void main() {\n      float v = line(10., vec3(1.)) + line(1.5, vec3(1.));\n      vec3 c = v * vec3(1.1, 1.1, 0.1) * (sin(time * 5. - length(pos.xz) * .5) * .5 + .5);\n      c = mix(vec3(0.5), c, v);\n\n      gl_FragColor = vec4(c, 1);\n    }\n  '),
      this._init()
  }
  _init() {
    this.rootApp.addEventListener('onAnimate', () => {
      this._pathAnimation()
    }),
      this.rootApp.renderer.domElement.addEventListener('dblclick', (t) => {
        if ('path' === this.rootApp.eventApp.curEvent) {
          const e = this.rootApp.renderer.domElement.getBoundingClientRect()
          ;(this.pointer.x = ((t.clientX - e.left) / (e.right - e.left)) * 2 - 1),
            (this.pointer.y = (-(t.clientY - e.top) / (e.bottom - e.top)) * 2 + 1),
            this.rootApp.raycaster.setFromCamera(this.pointer, this.rootApp.camera)
          let n = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
            i = this.rootApp.curBuildingApp.floorApp.floorGltfs[n],
            s = i.getObjectByName('group_room')
          ;(this.pathGroup = i.getObjectByName('group_path')),
            (this.devGroup = i.getObjectByName('group_dev'))
          const r = this.rootApp.raycaster.intersectObjects(s.children, !0)
          if (r.length > 0) {
            const t = r[0].object
            this.onClickPath(r[0].point, t)
          }
        }
      })
  }
  _pathAnimation() {
    if (this.pathGroup)
      for (let t of this.pathGroup.children)
        'startPoint' === t.name
          ? (t.material.uniforms.time.value = this.rootApp.clock.getElapsedTime())
          : (t.material.map.offset.x = 2 * this.rootApp.clock.getElapsedTime())
  }
  _createStartPoint() {
    let t = new sn(50, 50, 100, 100)
    t.rotateX(0.5 * -Math.PI)
    let e = new He({
        uniforms: { time: { value: 0 } },
        vertexShader: this.vertexShader,
        fragmentShader: this.fragmentShader,
        extensions: { derivatives: !0 }
      }),
      n = new Fe(t, e)
    return (n.name = 'startPoint'), n
  }
  onClickPath(t, e) {
    let n = this.pathGroup,
      i = n.userData.safeExit
    n.worldToLocal(t)
    let s = this._createStartPoint()
    s.position.set(t.x, 10, t.z), s.scale.set(20, 20, 20), n.add(s)
    let r = JSON.parse(JSON.stringify(n.userData.path))
    const o = new _(t.x, t.z)
    let a = o.x + '_' + o.y,
      l = {},
      h = this._getRoomPoly(e.userData)
    for (let t of e.userData.offset) {
      const e = new _(t[0], t[1]),
        n = o.distanceTo(e)
      this._pathIfOK(h, o, t) && (l[t[0] + '_' + t[1]] = n)
    }
    ;(r[a] = l), (r = this._setPathNetWeight(r))
    let c = new vc(r),
      u = []
    for (let t of i) {
      let e = t[0] + '_' + t[1],
        n = c.findShortestPath(a, e)
      n && u.push(n)
    }
    let d = this._getColorPath(u, r)
    this._drawPaths(d), (n.visible = !0), this.rootApp.render()
  }
  _getRoomPoly(t) {
    let e = new kd.GeometryFactory(),
      n = t.interiors,
      i = t.room,
      s = [],
      r = []
    for (let t of i) s.push(new kd.Coordinate(t[0], t[1]))
    let o = e.createLinearRing(s)
    for (let t of n) {
      let n = []
      for (let e of t) n.push(new kd.Coordinate(e[0], e[1]))
      let i = e.createLinearRing(n)
      r.push(i)
    }
    return e.createPolygon(o, r)
  }
  _pathIfOK(t, e, n) {
    let i = new kd.GeometryFactory().createLineString([
      new kd.Coordinate(n[0], n[1]),
      new kd.Coordinate(e.x, e.y)
    ])
    return jm.relate.RelateOp.contains(t, i)
  }
  _setPathNetWeight(t) {
    let e = this.devGroup,
      n = []
    if (
      (e.traverse(function (t) {
        t &&
          t.name &&
          t.name.startsWith('Glow_') &&
          16711680 === t.userData.color &&
          n.push([parseInt(t.position.x), parseInt(t.position.z)])
      }),
      0 === n.length)
    )
      return t
    let i = new kd.GeometryFactory()
    for (let e in t) {
      let s = e.split('_'),
        r = new kd.Coordinate(s[0], s[1]),
        o = t[e]
      for (let s in o) {
        let o = s.split('_'),
          a = new kd.Coordinate(o[0], o[1]),
          l = i.createLineString([r, a]),
          h = 0
        for (let t of n) {
          let e = i.createPoint(new kd.Coordinate(t[0], t[1])),
            n = jm.distance.DistanceOp.distance(e, l)
          if (n < 5e3) {
            let t = i.createPoint(r)
            if (jm.distance.DistanceOp.distance(e, t) > n + 10) {
              h += 1 / Math.expm1(n / 1e8)
            }
          }
        }
        t[e][s] = t[e][s] + h
      }
    }
    return t
  }
  _getColorPath(t, e) {
    let n = [],
      i = {},
      s = 0,
      r = null
    for (let i of t) {
      let t = 0,
        o = {}
      for (let n in i)
        if (parseInt(n) + 1 < i.length) {
          let s = i[n],
            r = i[parseInt(n) + 1]
          t += e[s][r]
        }
      0 === s
        ? ((s = t), (r = i))
        : s > t
          ? ((o.distance = t),
            (o.color = 'y'),
            (o.path = r),
            (s = t),
            (r = i),
            yh.path_show_all_path && n.push(o))
          : ((o.distance = t), (o.color = 'y'), (o.path = i), yh.path_show_all_path && n.push(o))
    }
    return (i.distance = s), (i.color = 'g'), (i.path = r), n.push(i), n
  }
  _drawPaths(t) {
    for (let e of t) {
      let t = e.path,
        n = e.distance,
        i = e.color,
        s = new se({ side: 2, map: this._createTexture(n, i) }),
        r = this._createPath(t, n),
        o = new Fe(r, s)
      o.translateY(100), this.pathGroup.add(o)
    }
  }
  _createPath(t, e) {
    let n = []
    for (let e of t) {
      let t = e.split('_'),
        i = new _(parseInt(t[0]), parseInt(t[1]))
      n.push(i)
    }
    let i = new no(n),
      s = parseInt(e / 1e3),
      r = i.getSpacedPoints(s).reverse(),
      o = new sn(1, 1, s, 1),
      a = 0,
      l = 0
    for (let t in r)
      if (1 * t + 1 < r.length) {
        let e = r[t],
          n = r[1 * t + 1],
          i = Math.atan2(e.y - n.y, e.x - n.x)
        ;(a = 80 * Math.sign(i)),
          (l = 80 * Math.cos(i)),
          o.attributes.position.setXYZ(1 * t, e.x - a, 0, e.y + l),
          o.attributes.position.setXYZ(1 * t + s + 1, e.x + a, 0, e.y - l)
      } else {
        let e = r[t]
        o.attributes.position.setXYZ(1 * t, e.x - a, 0, e.y + l),
          o.attributes.position.setXYZ(1 * t + s + 1, e.x + a, 0, e.y - l)
      }
    return o
  }
  _createTexture(t, e) {
    let n = document.createElement('canvas'),
      i = 20
    ;(n.width = 80), (n.height = i)
    let s = n.getContext('2d')
    'y' === e
      ? ((s.fillStyle = 'rgba(0,0,128,1)'), (s.strokeStyle = '#ffff00'))
      : ((s.fillStyle = '#00ff00'), (s.strokeStyle = '#ff00ff')),
      s.fillRect(0, 0, n.width, n.height),
      (s.lineWidth = i),
      s.beginPath(),
      s.moveTo(0, 10),
      s.lineTo(i, 10),
      s.stroke()
    let r = new Or(n)
    return (r.wrapS = 1e3), r.repeat.set(parseInt(t / 2e3), 1), r
  }
  delPath() {
    for (let t in this.rootApp.curBuildingApp.floorApp.floorGltfs) {
      let e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t].getObjectByName('group_path')
      for (; e.children.length > 0; ) e.remove(e.children[0])
    }
  }
  showALlPath(t) {
    yh.path_show_all_path = t
  }
  setAllSafeExitColor(t) {
    try {
      let e = new L(t),
        n = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
        i = this.rootApp.curBuildingApp.floorApp.floorGltfs[n].getObjectByName('group_safeexit')
      console.log('eeeeeeee==eee', i)
      let s = i.children[0]
      s.userData.materialColor || (s.userData.materialColor = s.material.color),
        (s.material.color = e),
        (s.material.visible = !0)
    } catch (t) {
      console.log(t)
    }
  }
  resetAllSafeExitColor() {
    try {
      let t = this.rootApp.curBuildingApp.floorAnimationApp.floornum,
        e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t]
      if (e) {
        let t = e.getObjectByName('group_safeexit').children[0]
        t.userData.materialColor &&
          ((t.material.color = t.userData.materialColor), (t.material.visible = !1))
      }
    } catch (t) {
      console.log(t)
    }
  }
}
class Jy {
  constructor(t) {
    ;(this.rootApp = t),
      (this.smokeSpreadGroup = null),
      (this.flagAnimate = !1),
      (this.polySpaces = []),
      (this.devSmokeSpreads = []),
      (this.floornum = null),
      (this.allVNpolys = []),
      (this.curOneVNpoly = null),
      (this.curVNpolys = []),
      (this.smokeSpreadGroupRoomVN = null),
      (this.geometryFactory = new kd.GeometryFactory())
    let e = new ma().load(
      'data:image/png;base64,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'
    )
    ;(this.material2l = new Bo({ color: 0, opacity: 0.6, transparent: !0, side: 2, visible: !0 })),
      (this.hight = 1),
      this.rootApp.addEventListener('onPostInit', () => {}),
      (this.VNMaterial = new Bo({ map: e, opacity: 0.4, transparent: !0, side: 2 })),
      (this.VNMaterialInit = new Bo({ color: 16776960, opacity: 0, transparent: !0, side: 2 }))
  }
  init() {
    let t = this.rootApp.curBuildingApp.floorAnimationApp.floornum
    if (t == this.floornum) return
    let e = this.rootApp.curBuildingApp.floorApp.floorGltfs[t]
    ;(this.smokeSpreadGroupRoomVN = e.getObjectByName('group_smokeSpreadRoomVN')),
      this.smokeSpreadGroupRoomVN ||
        ((this.smokeSpreadGroupRoomVN = new Is()),
        (this.smokeSpreadGroupRoomVN.name = 'group_smokeSpreadRoomVN'),
        e.getObjectByName('group_floor_' + t).add(this.smokeSpreadGroupRoomVN),
        this.smokeSpreadGroupRoomVN.translateY(3e3),
        (this.floornum = t),
        (this.allVNpolys = []),
        (this.curOneVNpoly = null),
        (this.curVNpolys = []),
        this._getVNPloy(e),
        console.log('this.smokeSpreadGroupRoomVN=======', this.smokeSpreadGroupRoomVN))
  }
  _getVNPloy(t) {
    let e = t.getObjectByName('group_room'),
      n = t.getObjectByName('group_dev')
    for (let t of e.children) {
      let e = t.userData.room,
        i = []
      for (let t of e) i.push(new kd.Coordinate(t[0], t[1]))
      let s = this.geometryFactory.createLinearRing(i),
        r = this.geometryFactory.createPolygon(s),
        o = []
      for (let e of n.children)
        if (e.userData.devInfo.roomId === t.name) {
          e.userData.devInfo.url.endsWith('25.gltf') && o.push(e)
        }
      this._getDevVNinOneRoom(r, o)
    }
  }
  _getDevVNinOneRoom(t, e) {
    if (0 == e.length) return
    if (1 == e.length)
      return t.setUserData('vn_' + e[0].name), this.allVNpolys.push(t), this._createVNMesh(t), t
    let n = t.computeEnvelopeInternal(),
      i = new kd.CoordinateList()
    for (let t of e) i.add(new kd.Coordinate(t.position.x, t.position.z))
    let s = new Vy.VoronoiDiagramBuilder()
    ;(s._siteCoords = i), s.setClipEnvelope(n)
    let r = s.getDiagram(this.geometryFactory)
    for (let n = 0; n < r.getNumGeometries(); n++)
      try {
        let i = jm.overlay.OverlayOp.intersection(t, r.getGeometryN(n))
        for (let t of e) {
          let e = this.geometryFactory.createPoint(new kd.Coordinate(t.position.x, t.position.z))
          jm.relate.RelateOp.contains(i, e) && i.setUserData('vn_' + t.name)
        }
        this.allVNpolys.push(i), this._createVNMesh(i)
      } catch (t) {}
  }
  _createVNMesh(t) {
    let e = t.getCoordinates(),
      n = new Array(e.length)
    for (let t in e) n[t] = new _(e[t].x, e[t].y)
    let i = new io(n)
    const s = new Oo(i)
    s.rotateX(Math.PI / 2)
    const r = new Fe(s, this.VNMaterialInit)
    ;(r.name = t.getUserData()),
      (r.userData.smokeSpreadRoomVN = t),
      (r.userData.name = t.getUserData()),
      this.smokeSpreadGroupRoomVN.add(r)
  }
  devSmokeSpreadVN(t) {
    'string' == typeof t && (t = [t])
    for (let e of t) {
      let t = this.smokeSpreadGroupRoomVN.getObjectByName('vn_' + e)
      if (!t) return void console.log('=====devn===not found==', e)
      ;(t.userData.oldMaterial = t.material), (t.material = this.VNMaterial)
      let n = t.userData.smokeSpreadRoomVN,
        i = this.rootApp.scene.getObjectByName(e)
      console.log('=============dev===============', i)
      let s = new Qy(this, n, i, 0.2, this.material2l, this.hight + 30)
      this.devSmokeSpreads.push(s)
    }
  }
  openSmokeSpreadVN() {
    ;(this.flagAnimate = !0), this.init()
  }
  closeSmokeSpreadVN() {
    this.flagAnimate = !1
  }
  clearAllVNSmokeSpread() {
    for (let t of this.devSmokeSpreads) t.clearAnimate()
    ;(this.curOneVNpoly = null), (this.curVNpolys = [])
  }
  clearVNSmokeSpreadByName(t) {
    for (let e in this.devSmokeSpreads) {
      let n = this.devSmokeSpreads[e]
      if (n.dev.name === t) {
        n.clearAnimate(), this.devSmokeSpreads.splice(e, 1)
        break
      }
    }
  }
}
class Qy {
  constructor(t, e, n, i, s, r) {
    let o = n.position,
      a = [o.x, o.z]
    ;(this.dev = n),
      (this.geometryFactory = new kd.GeometryFactory()),
      (this.devPoint = this.geometryFactory.createPoint(new kd.Coordinate(a[0], a[1]))),
      (this.smokeSpread = t),
      (this.poly = e),
      (this.speed = i),
      (this.hight = r),
      (this.material = s),
      (this.meshMame = 'n_' + this.devPoint.getX() + '_' + this.devPoint.getY() + '_' + this.speed),
      (this.flagAnimate = !0),
      (this.timeCount = 0),
      (this.tmpTimeCount = 0),
      (this.curPoly = null),
      (this.curLastBufferPolys = []),
      this.smokeSpread.rootApp.addEventListener('onAnimate', (t) => {
        this.smokeSpreadAnimation(t.delta)
      }),
      (this.flagComputEnd = !0),
      this.init()
  }
  init() {
    let t = jm.buffer.BufferOp.bufferOp(this.devPoint, 500)
    ;(this.curPoly = t), this.curLastBufferPolys.push(t)
  }
  smokeSpreadAnimation(t) {
    this.smokeSpread.flagAnimate &&
      this.flagAnimate &&
      ((this.tmpTimeCount = this.tmpTimeCount + t),
      this.tmpTimeCount > this.speed &&
        this.flagComputEnd &&
        ((this.tmpTimeCount = 0),
        (this.flagComputEnd = !1),
        this.getPoly(100),
        (this.flagComputEnd = !0)))
  }
  clearAnimate() {
    let t = this.smokeSpread.smokeSpreadGroupRoomVN.getObjectByName(this.meshMame)
    t && this.smokeSpread.smokeSpreadGroupRoomVN.remove(t), (this.flagAnimate = !1)
    let e = this.smokeSpread.smokeSpreadGroupRoomVN.getObjectByName('vn_' + this.dev.name)
    e && (e.material = e.userData.oldMaterial)
  }
  getPoly(t) {
    let e = this.curPoly
    for (let n of this.curLastBufferPolys) {
      let i = jm.buffer.BufferOp.bufferOp(n, t)
      e = jm.overlay.OverlayOp.union(e, i)
    }
    let n = jm.overlay.OverlayOp.intersection(this.poly, e)
    if ('MultiPolygon' === n.getGeometryType())
      for (let t = 0; t < n.getNumGeometries(); t++) {
        let e = n.getGeometryN(t)
        if (jm.relate.RelateOp.contains(e, this.devPoint)) {
          n = e
          break
        }
      }
    if ('GeometryCollection' === n.getGeometryType())
      for (let t = 0; t < n.getNumGeometries(); t++) {
        let e = n.getGeometryN(t)
        if (jm.relate.RelateOp.contains(e, this.devPoint)) {
          n = e
          break
        }
      }
    ;(n = my.TopologyPreservingSimplifier.simplify(n, 1)),
      (this.curPoly = my.TopologyPreservingSimplifier.simplify(this.curPoly, 1))
    let i = jm.overlay.OverlayOp.difference(n, this.curPoly)
    if ((i.isEmpty() && (this.flagAnimate = !1), 'MultiPolygon' === i.getGeometryType())) {
      let t = []
      for (let e = 0; e < i.getNumGeometries(); e++) {
        let n = i.getGeometryN(e)
        t.push(n)
      }
      this.curLastBufferPolys = t
    } else this.curLastBufferPolys = [i]
    this.curPoly = n
    let s = this._createMesh(this.curPoly, this.hight),
      r = this.smokeSpread.smokeSpreadGroupRoomVN.getObjectByName(this.meshMame)
    r && this.smokeSpread.smokeSpreadGroupRoomVN.remove(r),
      this.smokeSpread.smokeSpreadGroupRoomVN.add(s)
  }
  _createMesh(t, e) {
    let n = t.getExteriorRing().getCoordinates(),
      i = []
    for (let t of n) i.push([t.x, t.y])
    let s = new Array(i.length)
    for (let t in i) s[t] = new _(i[t][0], i[t][1])
    let r = new io(s),
      o = new Oo(r)
    o.rotateX(Math.PI / 2), o.translate(0, e, 0)
    let a = new Fe(o, this.material)
    return (a.name = this.meshMame), a
  }
}
class $y {
  constructor(t) {
    ;(this.rootApp = t), (this.dir = new H()), (this.sph = new el()), (this.img = null)
  }
  compassTransform(t) {
    yh.showCompass && this.img && (this.img.style.transform = `rotate(${Number(t)}deg)`)
  }
  compassRender() {
    yh.showCompass &&
      this.img &&
      (this.rootApp.camera.getWorldDirection(this.dir),
      this.sph.setFromVector3(this.dir),
      (this.img.style.transform = `rotate(${v.radToDeg(this.sph.theta) + yh.compassInitValue}deg)`))
  }
  createCompassDiv() {
    yh.showCompass &&
      ((this.img = document.createElement('img')),
      (this.img.id = 'compass'),
      (this.img.src =
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjwAAAI8CAQAAABfBrkRAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAACPKADAAQAAAABAAACPAAAAADgCwHuAAA+9ElEQVR42u2dd3wURf/Hd68kIeVIJZUAgRQSQoAYShIhCS2ERxAVBJ8HFUF9VEREUERpgoBSgwrqj6LoowgiRSkiGkAIIApESug9BUKSM40kV/b3B+12bu9yPTuXzzuvBHZub29n5juf+87szHcYBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECUsCgC1H6jwaEKYHoAdW74DHtLBCQIRgiaWG1bbgOcRVfjID8AwtOUa5q10BI4Cz6XM+k6kB4ID3DiemaN/o88n7O5OHAQHxgkaFq1TEoNa0SAhASBMyISptgTZ/SKkB4ID3DCWmb1REdIflijUsGZITysQbHiTJYzAOEBTiA7fNFhBQRI911CQsGZIDyGno0Z/wvpgfAAp5Ud/V++/PDfR8oDJ+j1mDJUrX8NziRPCkB4AKU1TMqOob+GfBVDomHoEw1fxdAvpAfCA5yshvVl58G/ZIqQx8P/5QQ7SKxR6RG6AmdQyiA8To0MRdCEvlj4ssMS/9dNMyQ89/4+SBF6YtaQ8HAMw7A8kbl3xEJwIDzAuQRIX3Ye/EhMEJ4HokN6PUKfpO9N33sXe/8aDE96GD1BAhAe4CTdLWHBkej85Xe37nWodGWHIzpJQh4P3+t5cBX+dbR3hYiF6EB4gPOKj77skL+6Xg/pq+j/CAmPsM+j6yVp76dKdKSH4XW3IEIQHuAk0sPq/I9lJDqCIyGEhzUoPFqD0sMalR79jtodAZLclSGM8UB4gBN3tliicyXRkR0JMdZzTwju+Skcw931UfjSI+zx6PpNfJ+JZbQMx2jvio7+jCEA4QFO2cniiw7/h/R57omG9u5fUnoeeCsP/CpjwqNlOIa5ex2WN5IEnwfCA5y4w0WKjlTnr0Sgs6UrGXd+tYI+j+F50LrixfI6V9r7IzwPzoT4QHiAk/k8jJ7PI31E0dxVLdFINBK1lGM1Eq2EYTj2zi/DsBzL3fkr1bKcVHtbveMfwushhOfJ5nIpw2h5j9MlHMNIOJlWwv1R+Xfdfcl5IHGQmibZ9wfOWrus3sjOAy/n7m/1d+7dTL8opxqevq6UN8zM96cY1T5ZkOH3H325y4+M9v6P5q7/pL1/RcNzhIDTIEERNDkhIkVIypn19cPK3x7MyBgpI2OkBn6MouGPJkkMjAoBCA9wOtnhPdPSmtnYo4YYlZ0GhEzL3h1Nami+NIDwACfzdvjDy2bi3i67IyM1Ij5GUfMf4bOCkxYhQBAeQL3ksMQiBmJwmTO7mQ8awsgMyI7ExK4Wa+AJGoDwAKeVIN5As/nC07JfjIdhn0fbUFdLeKqi7ioxAOEBTiM6uv6O7nIJs5F6LO6t5+eY2NXSsoKTFXWXWUB8IDzA6cRHb6SHs6Chd/2XQBfr3t+GhEcoBhDGdSA8wAklh9/dYg0sBzUZ34QXwgVFp0Hh4ViDvg6A8AAnExyGGE/RfbJl0ZVfGqjXxbq77MK4B6WREKHHyKUWAMIDnEZ+WIPdLZazqLnH9PeQ68rN/ZnQUhOsjhWUHQDhAU7sAZF+j0W4+S3uprPwQleCGBM8HtZAZwvyA+EBTtfZEvR4LL10/wE6a750Vro36EHpDylDbiA8oAmIEW9GD2dhs2/ZNc2X5/FITRkz0hp+ngX5gfAAp/N5hPc1t6Kxs7J3+wqGEjMKxxcctoHduACEBziFCDW8b6jJJFkgPITHxUBuIDzA2b0eRm9kxapH2IqW78ZaIDz6vhi8HQgPcHLp0W3sJjT00qKKW4ZfHdFPX3gaDIuhv3EygPCAJiQ+JkjP9es//Wr41ajU1u5EqHjYFIDwAAH5YfUeshtl+iG1ytBrMrd5KToTAk0dXEbHCsIDmroP1FAEwvM1fx82/GpaHyKsGGvS56KLBeEBTRaOYe7sAGFEIziG+XyP4dcDY54K4629gk0BCA8wTXyMn/HZpZJrhl9+tbdOREEJPBkA4QG2kSZux27DL3fq5SHTDSLPQXoAhAdYB8sxHMNNPaSqM3SGW/M5XXRiKMOmAIQH2MbjuXI774DhE/6VcX+MB10tAOEBJoiKScLDcMuNdLbaJKT68LbnAwDCA6zsamkZjtGuunzjosFzpG/3xFMtAOEBNu5qMRzD7fjN8CkpvXR2rgAAwgOs62xJOOauzzPlQH2NobOaB70ZY3JgMUgThAdFABpEe8fjKazL+93wSf/uhcfpAMIDbMSdx+l3xOdjI8tFY5NaN8NSCADhAbbrjGkZjtEy2jXXis4YOknmOrO7KYPLWuwoASA8wASPR3vP42G4n3caPrPfwwz2xgIQHmBTj4djtIx20sH6SkOnBUUMD4XsAAgPsJ3Hc/fvrfpjuw2f+9LD8HgAhAfYyuPR8Xmydxp+AN+1u6cUj9MBhAfYwuO5P7jMcAz3TUHBCUPnunlN79SQrOBhO4DwAFPQ6no8DPfzDsOnDklBcQEID7C5x8No3zhYpzR0dkRsDx+UGYDwAJt7PErVsV0GZUoyv59UboqeoVghPKBpcnfxpwnn8TwehvtwB2fwXSnpzTxNMDkOxQ/hAU1PbszpamnJnx+KC4/Y5E4AhAc0Acnhy88DaTEuPPc6WTo/27ZbfR+QHQgPaFKiY25XS3u3m6UjPOMP3i610uuywPsCEB5Ap+xwAr6P2V0tRlujPrrDslthH0gNp+d9QYQgPMBJBYi7/9ckf0MiKDyM9oPtnNYqj4cTEESID4QHOJm3wxkQIVO7Wnd+NPf+3XKj4JBFJsfpSB+8HQgPaEJSxPN6GhxcfiA5mrv/0zBaRrvtJ6v8Lt2RHkgPhAc4pb/DMLqDyfz/MSYJD9/n0TCa1w7V3DD/hlh+J4/scgEID3BqMXqwFMLUrpaG5/doa9V//2hhV0vLG2Pi4PVAeIBzCg3/CRKn+9NgV0tz90dXejSMhtG8t5VTW+DxCMsOJAfCA5y2o8UQsqNtyOPR6Wrpyo6W0TCa7bcK9lnk8eiKj/6YD4DwACcTIL7omPBUS2LE42E02zaaeytS7f1VX5zAY3UA4QFOJz+cgL+jNfGplq7k3P//K4drrlvY1dLyvB6ID4QHOK3oMHzJufvTkFDoejw8f4dRq9UnfzC7q6Xv8+j6PehwQXiA04mPgM9j8uAyKTsaRsOop23h6i3oammJUR4OozwQHuCccsPwROe+AEi4Bj0UIcm5+7OjtPhXCz0erWmjTADCA+iVH/4Yj+5q84a7Wlqe+Nz5q74nPT+vM+dGZA9khxPobj24WwDhAU4kPQ9k5470aMycx6PldbrUjHrU4dsXTL8N3kxoUnIgOBAe0ASkxwSP5/7jdK3ASM9dr+fcd2Z5PBq9zhaDB+tNC4Tcdv76Ze/+lTAswzIsI9H7Ye/+vXcmKVL81eTM3Ws+uBqrcx32/nXuiZ2uyGmIxaZaRqjjhZnMTo8MRdAkPB1WRzIe+Dy68sQZER4hf+SewHCMlpHc/asvPHfeQ0Qv1PF4MIkQwgOaUHdLyzB35YJhOEZyX3b0hYcR9EPY+9LD3RcfrY7wPLiKsPTwR3nI2DyQIAgPcCp/hxQf9q4PJNGRC13hYQQ7WnyPh70rOxKGZbQ6/g7Lu8aDER3DQ8sQHQgPcELx0Y24fM9HYe7Lh66nwggs3iSFR3ekh9MRHb7wMMTaMC3vL6fX4QIQHuB0nSxd+dEyEoYh5ILV84sYg50gluhw8a8i5DfxxUYrMIcH0gPhAU7l7+h3uPRFh73vy3AC0mOa8DCEgOlLj67kaAVEBxIE4QFOKEBkirBgCIkPv6vF3ZcdRk++DAmPfkgOBEBtkmAeT1OpX5b3y+r925Dw8D0SlrimvuiwAsLDCC6S4BD4HcIDnLWG9aWCMSIXZJdHSA50r9jQdYQfzuuHPsVqLQgPcEKfR9/zIdMZA9IjJAVCVxSyKV3fybjkQHggPMDpalhfKBgDXgqjJwCckeuT12CNCI/wA3rIDoQHNAnpMfyXYRiGeVuRFK1o3ayF3N/NV+7v6i33dVFIXSRyqYyVS2USuUTGMFq1VqVRa1VqjbZeU19fUV9eq1Tful1WV1p385/LuWeyKwTES19whKQNwgPhAU4oPaTUsAyzJji8m0esaxv3cPcQzyC35qYaieH+WN0/1cXVhVXXai9V5N848HSxoH8D2YHwgCZSy/flZoZraqJ3kkeCZ/vmbZv5WmYmDSnHvffWlikvVOdX55X+eeDPGXVGunGQHQgPcM563hzcop93L99EnxipnLPCVMxVjDvX0KiUp8v+Uu65uXNwscCbIDwQHuBcNZ0Tqhjq29Oni6Ilw9q6hXNmmxvLVVwrP1K2t2J9egFEB8IDnI4cmVtf30f90nwjhWucs8pIOGuNjis7V7Jbuan2l3Q16grCA5xBcry9nwl4JKCbi6eYezJ3zLC+quRQyY/KL9OVqDcID6CUbYrg/wQMC+ohdbGdr/LAZDi7mZ6mvvhAybqir7MqUIcQHkCTl+OmeDrwyaAUqasVF+FqlBUlFcqqyspKZWVZVUlVQWVZbaW6Wl2hqlSXq5VqhvGW+ci8ZAq5h8xL5usW6hXg6evp7eXl5eml8FYEuHtbY13quhv7b3xXsSa9FvUJ4QGiZ39S0LjQwa5elkhN1a0b14oKrpdcLDlaknOrVGXdnfjJ0/07B0QEhAUEhwa29PS3xNbqKgs2Fy9NOYx6hfAAsfo5nj4vhj3r18G8d2lUNy8VXrlw7fC1H65etKN3EeH2WHhSy7YtQ1q1aCOVm/fe0hPXvyj/LL0KdQzhAaIiNz7onbBH5O6mv6O24vrZ02d+O7v6stLBT5K8ZaNaZ0TFRIdFuSlMf5eq5vqPxe8nH0ddQ3iAOEQnM3xySE+WNbUBXzpxOG9D/sYbjX/nQwIfb5+U0KaDqYLJcYV7r85L3oE6h/CARmSdtO1zrV7zizOt1ZZeOZm3I2/p+WqNuHLhIR3XLjMhLsGvlWnWWHrySvaFVcM0qH8ID3A4OTLf8RETPINN8ROKzuw/uORwrshnx6R6j0tK6R4cbYrvVlV0cVHZEkw3hPAAh3o6US+3fcsztGHNKT534OCSP/aW05O3nj7ju/boHhTZsGVWFVz44OwyeD4QHuAAOPbIC22nNA9v6LyKG/t3L9q/q5TOXPbxm5CSkqYIbOi8f65emNPlcxYrvCA8wJ4cHtFutneE8XO0qrN/rs2ZfUpDeXOUsu/GDk+PekjSwMN35cXz7yZ9C9uA8AC7kNu5zSdBPRpohIV7fp2x75gTzXjp5DkjtVdv7xDjZxUfuPRK8lHYCIQH2JQc//DFrUdIpMbOKcj/duvkYxon7HZI2XmdRgwMbW/Uz9Nc/vbq6+m3YCsQHmAb0ZEFTG43ydXIZDtOc+aPj7Yuu+Tc5fBym1cHRndljYhvXcX5+afmYrgZwgOsZt/D7Vf6Rhp+XaP667fp23Y0kW/6TP+ZWYkZxpZclJ3LH536O+wGwgMs5mePiOy2zxr+jteqj+1+Y9Pu8qZVKmk+Cx/tlCaRGfb/Lnxx8bX+1bAfCA+wgEOPxn5seK4Op/n798kbdzTRMY1M/3lDOj5sWJKrCk6N7bYJNgThAWaxy6/dilaDDdfO6dwp34thtVVjMiRwzhMxyQZf5q5sPj+mTylsCcIDTPV1Bsat8mhh6NWbF+d/teAsSolhGGZi1KSRLQzOa6q+efK5bltRShAe0CB/yr0+jhzDSoRfrVGuXzt6nwYzde8jZVemDh3u7m3A7dGeW1E59iEVygnCA4yQGx/9na+B+Spa1b7tT2++glCgerRyWzM4dYChGc5l+WeeRBwfCA8wSN7E2FkyN+HXis5MWLG2EGVkiOEhi8YERwu/pr59alrCApQRhAfo+zrNgte2HiT8mur2xrVP/YoOVkOdrm96Dxkubyb86uUtRcOTb6OUIDxAh5yYjlsMTRO8cGTMqqY2V8dS0nxWPNe2i4Eu17m/B6WfRhlBeMBdDg1NWCm8L0R91erV/z0oxntu794v5MDNP0S499Wn3UeNerB9oS51lXmju62HvUF4AMMw+Qujxws/xbp+6pnlv5WJ745DXTY/1aUPyzLMtRPPfia+O8zw/fKlsFihVzjtmSXt34DNQXiaOLnNwreE9hF6RavesX7I1npRjuv8/UJ8r/sdmGtRU0tF97jahd04MHOo8LKKgl1XB2G0p7GRoAgaj73BUX8Iy46ycOz0gT+JU3bejHogOwzj23JVX/HdYz038Kex05WCTwFD+0T9sTcY1gePp6l6O/Hx24XXYp3c139lQb1Y7/v8620f0j2uuhU0oVqUoShCXX4eHZcq9EpVwfEBmNsDj6cJcmBAl/1CsqPVbPiiw3Lxys7gwIhEfoqn/5Ju4rzXgvoOyzd8oRUQRc/QLvsPDIAVQniaGH+9mLRZ6DlWTflbs5/4Rcx3Pi1Lf/uZwSJuwk/88tbsGoHJCK5eSZv/ehGW2FhIUQSOJ29SwmKhgc/CM4/M/a5AzHce7zntJf0ArB4+3Ok9JaLt0pbuzh3Qzstf7ztXGpT12O1Pc2GP8HiaBCdmdvxA6PH5sZyo98W+6d7CvjIXofRRWWK+61xl1PvHcvTTWUnHD07MhEVCeJoA+QvjpgkN6e/Z1HlFtcijBfvJU/sIv9K60zBRPyeq1nResUcoMBgbNy1/IawSwuPknP0sZoJ+Ksdt+DKNghm1S1ObGQg/wbBTBor97tPWb/iSE5igEDPh7GewTAiPE3N+TeQL+qla9ecfP7FT/HcvZQdkGn61Q2qiQuw5eGLn5x9rBfZbj3zh/BpYJ4THab2dtiP1U9W1s+eLczUWydxOPmFGZEm+oJ/48/Dfg7PnqwUiGrUdCa8HwuOU5C8U8nbqKl6bPf0EHTkY0cAAco8+QS7iz8X0E6/NrqsQ8now1gPhcTpOzBQa26ks+fdMWrbhe76V8LLLB7h6ZfekISfLLv17ZqXAw/+YCXjCBeFxKvImxU3VTy27mjVjQzEteXj9Xw2fk5kppWIJzobirBllV/XT46bmTYK1QnichL9ejJ+n/wC98HSPWfuUtOQhwzfahGURiuCFiXTkZ5+yx6xC/aBgbPw8zGaG8DgFBwYkfKQ/XbDwdKd5Z2voycWsARKT5rgPy6IlR2drOs3Tlx5WkvAR1nBBeKgnN77zd/o7fZddTV9YQtGWKxFuSWmmnRkc/WoELbkqUaUv1O9wSeWdv8uNh+VCeChmb3D8dv2loJUlgz+gydthmOwMubup5479Fz35Olsz+AP9YWZXr/jtiNcD4aHX22kWu1M/8EVdxah59IztMAzDeEjT+pt+dmRSpj89edunHDVP/+G6Z2jsztxmsGAID5WEb/HrQKapayd8SM+TrDss6eZphpSwkplZNOVuQ/GED/WnFPp1CN8CC4bwUEj+Qv2gplr1nMW0zNt5gLnRdrr0au9OU/6WXZqzWH8hRWgfTCi0J4jHYxcODe24gAyYxXH/t2ziEdpyMi124GAzv8tkEbf/d4amPO6+GVKc2JWsL79uWfkrTsGW4fFQQ05Mwkr9R+g/rKFjTRYfSyLt9OynoOwL7b8Hf1ij32lMWJkTA2uG8FBCbrOOW/SfZe3ZRMMKdJJhwa07mf8uD5+lybTl9Imd+vF6XL06bsEgM4SHEoLX6m9GnJeTRuUOllMGWrYPyb+y6Mtr2vo8vSiFvpHBa2HREB4KyJvYehCZVngmZTWNeUlUdEi17J1+4e9ROAkvZXWh3thU60F5E2HVEB6xd7PiY2eRaTXlj2eLPaipMAv66c+6NpVnBtKX32rN0KX6O1LEvoeZzBAeUfOnPHqdzI2fptVMX3rwHxpzE+TSo4/l7w6PfyaMwi8O5fSl5D5csmbR6/6Uw7ohPKLF62NfvacgG79acJbO3GT3FNr5y3Te+BeNuV5wduNXZJpvjNfHsG4Ij0g5NDByDJl2cp+4t+czjJTNzLTuCnE9kr1pzPkTv5zcR6ZFjjk0EBYO4REhu/ziVpFzd5SF/VfSmp8FXRRWLpSUyOb1pzPv/VcqC/kprCRu1S4/WDmER3S0W+HRgp+iVU/5RLx7oDfEkzb4hu+W0dKVxrwX1E/5hFxE4dGi3QpYOYRHbN2sR1vpLSzYvn75ZVrz82pEcLT1V3HxXJJGZ/6XX96hN++q1eBDj8LSITwi4meP2E/IiXbXTw7eSm+ObBVVp2+mC0tnCQzZev0kkcTGfvKzB6wdwiMaIrI9Q/gp9VUjl2s4WvOT6R+ZZJsrebVYnERnGdRzz3xaX8VP8wyJyIa1Q3hEwr6H2z5Lpq1cvbuc3hzNzGJtZhePZ9FaCr+Vrdabb9722X0Pw+IhPCIgR9Z+JUusxb5w5OWD9OaovXuXXra7WmDkm1G0lsR/D14gwpiw0vYr1yGUDISn8QmYTC4JVd0es4rmHC3sQ86+to4XKJ4BM2aV6jY/xTcy9m1YPYSnsf0d/3Z6W8BtXEtzN0sh7WnjPdAjEgcH0loau8s36q1Obzcpxx+WD+FpVMIXuyr4KUVnnvqV5hxlJ3v42PaKLDsti97yeOrXImLFuqsifDEsH8LTiOR2bj2Cn6JVTVhB79MshmGYR+wgEh17xnvSWh4absIKLbEHWusRuZ1h/RCeRqPNMnJ/zX3b1xbSnKP34v3CbX9VmcvCPvSWydrCfduJRiNtswzWD+FpJA6PCOrOT6lRPr2Z7jzZK4pOal8/igNLPL25htgJLaj74RFoARCeRoBj280m09avvVJLteyEhdsp5FUz7+wUesvlSu16/SHm2RyLVgDhcThHXvAmdgm/eXH0PrrzZM8IOlkDpBQ31NH7bl7kp3hHHHkBrQDC42DWSdtOIdPmf0X3sHKyd1wP+13dJ2xOAr1lo+Hm64UHazsFUwkhPA4mcmxzYhD2dC6tkQbvMbe/RGbP6z9FdSitBWdP5/JTmodHvYyWAOFxIDkyctogp5nyPd15aunaPcO+nxAW+3wrmktoyvccEY257Vs5MrQGCI/D8H3dM5Sf8vfvG2/QnaclaS52n2sznmqfZ+ONv3/np3iG+r6O1gDhcRDrpBGEuWnVkzfSnScXtm+m/T8lpnuGL82lNHkjGZcw4nWM80B4HETb5zyJaMTHdu+4RXeeFid5tXCAsUlnZdJcSjtuHdtN+DzBbZ9Di4DwOIRW4/nHGtUbm2jPk6Oi5iSlR7jRXE5vbNKojFsDgPDYhdxMv1h+yl+/0bwanWEY5s2owEjHfJLcfXEGzSW1u/yv3/gpfrG5mWgVEB67Ez6Zf8xppm6lPU+OjJiT0d+D6lGRqVvJZ1ukRQAIj+39nfiQnvyUM4d2ltKdp8GBEYmO+zRP/0XdaC6tnaVnDvFTQnpib3UIj50JeoclJv5/tI32PE0dwDp0McOQAXSXF1njLBv0DloGhMeO5HiGPcJPKchfdonuPMV7JvRy7CcGRExtT3OJLbtUkM9PCXskxxOtA8JjN3xelLvzU76hfnxnYR+Zi6M/cxTl+5CTtS5393kRrQPCYzfCnuUfKwvfPkZ3jvzkqX0d/6ltOg0LprnU3j5G7q1OWgaA8NiM/Ul+Hfgpe36lez06w2SnNPNuhI9l36ba59Fwe4i42n4d9iehhUB47ELQOP6xVjWD8vg7UjarkQZ641MTFTSX3Ix9ZBxm0joAhMcm5LiFDuannD18rIruPM1J8AlrJMmTz+9Lc8kdqzp7mJ8SOjjHDa0EwmNzFE+7evFTvs2hPU9PNeK2M8l9glxoLjuy9l29FE+jlUB4bE7gk/zjihvv59Odo+dbhcU13qe7KrKp3oX8/fyKG8YtBEB4rGabIpAIVr5/N+0Dy40dHacf1VGYNdz+3YTwpGxToKVAeGxK8H9krrwEbtF+unOU4RvTvXHvwDt4QReaS3DRfob31SNzDf4PWgqEx6YEDOMfF5/bRfkKrVmZkkZfrDmM6ofqu0qLzxm3EgDhsYoc7yBi/4UDB+nOUYRbUnrj30VI9KsRNJciaQVBPXK80VogPLbrFDwj5T2B4bglf9Cdo8UZ5OKPxmEs1T7Pkj84XmdL6uL9DFoLhMd2HS1iaWjRmb1Uh/7ykGb0F8edRHbN9Ke3HPeWF50xbikAwmN5R0sWQESQ2U95R2tRN0+RNHdWMpPqIBmkJQR0w4Y3EB4b4daX2PiFW3KY7hyJKSJOl7Qod3pLculh/pMtF0+3vmgxEB6b4Pso/7j0Sq6S5vxMbR8goiFdmduS3vSW5T5l6RXj1gIgPBbin8Y/PplHd37EFg2nZ38FxVGYSWsgrQVAeCwiN9SX2IFhB9XCMyy4TSdx3ZGHT3YyveVJWoNvZG4oWg2Ex/pmMZThTexX1Sw9T3N+3h7IiG6hwiNZ9Jbn0vOqGl4C22woWg2Ex2oUxES7SyeqNfTmJlERnyq+u/ILf4/afRqqNZdO8FO809FqIDxW49uZf3yY6o7W/L5SuRjv62mKfR7SIkiLARAes8kJUhChsjZQHAwjyCW5jzjvrFXHkWG0lippEYqwnCC0HAiPVXj154+I1FZsvEFvbrIfdhVt4IZJ1C6e2HijtoKXwHr1R8uB8FiFgthz6vpZevMiZfuJeJZwXHIytQssSatQ9ELLgfBYhe9D/OPTZ+jNy4Iu3iLeVEYim0utn0BaBWk1AMJjFttcvWP4Kb9R7PGIPfpN94yWrnSWLGkV3jHbXNF6IDyWd7S68p8BaVSrL9Oal1cjQqLFfYcunkvS6Czb1Zc1vM1upHJFV7QeCI/FeCXyj29eUqppzQsNkW/69nehMgqzUn3zknHLARAeM/AgFhcUXqE1J5n+kRR8B3sFLqZ0P07SMjw6ofVAeCzGM5Z/fO4arTmZOYCloqYfp3QiIWkZpOUACI8ZKNryj/+iVHii3Luk0XGngZFvRtFYwqRlkJYDIDwmsze4mS8vgfvhKp05WdJbRs32us9TOZHwh6v8gGDNfPcGowVBeCzCjdhZovLWxVoq/TZpT4pmyLRNHBxIXxlfrK28Zdx6AITHRNyJfvpNSjta2ckePvTcLctOpTIKM2kd7hjlgfBYhisRILSogM580BbtJqFXvCd9pUxah0sEWhCExyKahfOPr5fQmIv34v3C6bpjmcvCPvSVM2kd7uFoQRAey4SHCNRwkUrhoTHSTWpfPzlt90xaRzMEQIXwWIYHEVXlKIXCMzKsVUcKJd87O4W2eyatwwNPtSA8lrBN4dqcl8Dl3KIvF7RGuckaIKVs8UTOLf4Dddfm2xRoRRAes/Fqzz+uUZaqaMtDsnccpfs3+IS9T5mnVqqqURq3IADhMQG3NvzjCgo7WnP7S6jdUPff1PlqpIWQFgQgPCYgI6axVZTTloOWrt0z6C3/sLjnW1EmPErjFgQgPCYg9+cfV1XRloMlaS6eNNfAeMp8nqpK4xYEIDymeDwB/OPKSrru34XtS3nI8ZjuGb403S9pIaQFAQiPKQ2XMHolZcKzOMmLcldfIp2VSdP9khbi4otWBOGxWnjKKOtqPZ5Ffx0kpUe40XO3pIVAeCA8FiAnFlbepMrjmRgVGOkEdeC+mKLhcdJC5D5oRRAe8z0eYvpXIVUez4sDnaMWMvp7SGm5V9JCXDCBEMJjQcEQG5SUUBSLZ3BgWycJNu7pv4ia/RpIC5FgixsIjwUFQyxTrKFof4mpA1jWWephCDVjVaSFSORoRRAeq4WnkpoFE/GeCU60hW5AxDuULD0gLQTCA+GxACmx2KCKGo9nYR+ZizPVxGhKxqtIC5HK0IogPOYXDGE2lZQIj588ta9z1USbTsOoCDFBWogEwgPhsb6rVU6J8CxJbubtZFXBvk2Fz1OOMR4Ij+09Hjo2L5ayA7Ocry7iUxMpeDSthMcD4WmqvN/RJ8z5ciWVf9gXdQvhaRJoie8vbyq+v/490DlrI6VPgOg7LqSFaNVoRRAe84WHeDjqQ4HwPN8qLM45a8NVsbSn2O+RtBCtCq0IwmO1x+NFgfCMH+i89ZEp+ijMXvB4IDzWoyG+rxSid/UzfGO6O299eAfP7yzuOyQtRAOPB8JjvcfjIXqPZ1amROrMNfLkv8R9fx7weCA8NhCeerq6WhFuSenOXSMh0a+Keltgva5WPVoRhMdq4fEVeUiqxelyd2evk7GiHsMiLQTCA+GxgPoK4vtW1IHTPaQZmc5fJ5FdM0UcQD3Uy7gFAQiPCajK+MctvMR8t4u6ejaBPQ1YyfQB4r27AE/jFgQgPKZ4PMQ+Wr6i9niGZDWNWklMixJth5K0kPpytCIIj/nCQ3xfeYvY43mnfUBE06gVuZt4ozCTFqK+hVYE4TEbNbEhrZeIhWf0wKZTL70yFSKdNEBaSH0pWhGEx2xUxPeVp2iFZ1hwm06N8bm3lZzW8Z/q4bOkhzjrgbQQFTweCI8FHs8N/rFCtFFu3h7IOHgxAaf5fUuHF9xfCXhu7ap6h+++MUik/h1pIaQFAQiPCdReIsxKpBvSJiriUx37ifXVMz/o+d3JaoYpVY34ddg0ZYFjP98vfGYHUQpPgHELAhAeE6jM5x+7e/uJcrXWh32lDr2viuJ/T5958sHx5hvdZlw97tg8PyPCZ3h+cndv4xYEIDwmkFVR9w8vgU0X4UyZAHlKH0d+3vVTydO+L+Knna2J/vDILkfeRauEkaILd5buz+/w1v2ThQmEEB5LqCYaWGcRdraW9nR1YFDQYzlx805WC3RLtYmrN3zpyKHmSaLzeUjrIK0HQHhM5DYxdhEhOuGRspkOm8nLcT/9r/OKCo2h15/YOXe+qsZRdxOXkiyywX7SOm4XoAVBeCyi5ir/OEx0wjO/s7eDNn5R1S5Y+Mg24+e88/czMypvOshsZXP7iasuSOsgrQdAeEyk/iL/ODhUbHfoqAg1VbdemPHm0YbP+7YgbVrhGcfcU/feoaLatpC0DtJ6AITHVI/nFP84sKW47u/ViJBoR3zOjXO9p35xzbRzj1TGzTm+1xF35eKZnSam2iCto/okWhCExyJqD/CPPf0jRBWT52WHTKTLz417/w8zns8o1R0/2/4dw9n/zvpluogmCnOEGxkdoO4gWhCExyJ6Ft3mLxRlHwsXz91l+kd3tfuHcLs2xH5Sanbs4Kwt2UvUdfa+Oa/AhUliqY3HwvkP02+X9cRTLQiPpVSc5x8niaizNX0Aa+e609Qv+6jvD5a9d/yfr7xXbfd4NENF81CdtAzScgCExwyqiLmnbUUjPFHuiWn2/YQa5WuzXjlk+fs/v5w59aadB1gDIydGiaM+SMuowqxlCI/lVB/jH4e0EsudLc6Q23W8qfTyI1M/sVI29ikTZp09ZN9yeEEkPg9pGaTlAAiPOd/6h/nHLdqIYyNjhbSXXSMsX/iz83u/2aCjVFwf+9HuTfa803YPDQ5s/PrwlrVoY9xyAITHDMr/5G/KJpWPai2G+1rSw8PHflff91P0kms2GhrWcOnrV3xiv818WfZdEURhHtWav1BXoyr/E60HwmMxWXXK0/yUDFGMKdgvIo1W/eWnD3+rsenD8OdzJ86utduCyU694hs9GjZpFcrTWXVoPRAeKygjvrliohv/nmZ28LPTY/26ynfnPPu77a+7+PyQqWXX7HPPMpcFfRq7RkirKIO/A+Gxjoo9/OMwEXg89opGU14wdNpcOy142HEracalo/a59sN9GztSEmkVpNUACI+ZVP7Mn4PrphjSyIOZI8NaJdjjulf+7j7jRzsu8bxYG7Pw4HZ7XLmZ95LkxqyRIYFu/NAkXOXPaDkQHqtIL664zk95vH3j3pF9ItH8+UvM/LN2DmpRz/X4+tsVWo3trzywUR+qkxZRcS29GC0HwmNtB+Qv/nFSQmPeTbJ3XIqtr8lp1n+R9EWtQ8J4PZUzc57tw8P7hM1rxFohLaL8CFoNhMdq/iH66206eDTivk5z+0lsPJNIVTN7/rBfHJeD9049Nb3C5uuYnmq0nSc8pG2I0PPlGOGB8FhP9Xr+KI/cfVy7xrqXUJfuvW17xcobT0+f5uBQ7RuKk6dft3HQiJZxzzfSrPJx7eT8TZW52+vRaiA81nduCsrO8VMyG82tz05zsemclcLTPaetLXR8Pk5Wx3xw9DfbXnN8I43zkNZQdi4ZQU8hPLbg1m7+cVwjCY8L28+mCyWO74mbe6yqcfJSremycsvXtgwPH9Mjw7cxckJaA2ktAMJjIWXEaiO/Vo0TaHxhkpfNHuVz3LZvO36uVDdmuQ7ePn+hqtZmhiyd1d/xeUj19mtl3FoAhMdCan8hnsOw4xslAJXtos+o67IXD/yp8Uv2rWPPT68qsdXVkjIcHyFyXBI/AFh9Ve0vaDEQHpuQri4hgjukdHf8XUyMCoy0UTen9OWZr/8ljrL98nrvacVnbXMtufvidEffP2kJJYfS1WgxEB4bUfIj/zg4uqePo+/BVpFnbl7oN+3/roinbP+o6DDn1D7bXCsj082h9tzTJzjauKUACI8VKL/U1PP6Wuz4ro69g8GB7R6yxXVOH0yYnasUV+mWquKW/7LeFuHhPf2zuznyzsd3ZXkdLU298ku0FgiP7TpbymJix4keDu5svTuAtcGOCjk/dPi4uF6MJdxv07Klahvc2RCHPlQnraD4QLoSrQXCY8vO1jr+cVBkHz/HfXq8Z6de1l5Do/r8k4wNGk6sJfzKH6+9V1Nu7VUCIt5x2Fq6Pn5BkcatBEB4rKToaw0/tBM7IcVxn76gj8zKXTNr/3lj9ou54i7jZZcGTi25bO1VnnOYzzMhhf9ES11X9DVaCoTHpmRVFO/np6SkSR20nZyf/OG+1l2h7OrgqdkUbLiyu7zzzHNWRiuO6DzMIfvJS9nUNH7Kjf1ZFWgpEB4bc+M7/rEi8N1Yx3zykuRmVk1YvHiky8ydpXSUckF9++zft1h1CXayQ3yed2PJ6ZykhQAIjw2oWFNXyU8ZnuaYT7Yu2szBbe0XXamlp5w1XM/vvvhUa8VsmI4PJyrsf5/DiTlDdZUVa9BKIDw2J722YDM/JSqpkwPCjM9L8Amz9L1azf/+r8f/6jnaynrU71Pm1FncbZHKP+xr7zvs5BlFTG8o2Jxei1YC4bEDxUuJopPPSLX/p1oeaaa+asbc/+yms6w/OPPEtHKLV3mn9AmwcxTmGakSuXHrABAeG5FyuPQEP6VXb3sPMD/fqmWcZe9UFg2fNovijXR/Kuk6/UqeZe91VSztac97k7K9iLhIpSdSsIUfhMdeXP+Cf+wdMq+TfT/R0igz104kT9t4g+7SPn87ZsFhC8OmZw6w51fCvE7eIcYtA0B4bEj5ZyoiIPoIu4bczPCN6WHJ+4782v7D/Br6y7tW23XNutWcBeHhvYPnd7bffZG1rqop/wytA8JjN9KrrhOLAEPbv9zGfp83q7/E7PjOnHbTV4mrqjXOUuZP7pr1Yb0FIvqk3b4SXm4TSsyOvv5jehVaB4THjhS/zxHPiF61m4FHuCVlmPse1e0PFwzZ4VxlPv3EyGkVZncbQ2JeibDP/ZA1znHF76NlQHjsSvLxwr38lOiumf72+azF6UQY8QapLBk9Y3Ke85X6uqLUaYVmD5SPtctXQqZ/NBGZoHBv8nG0DAiPnbk6j3/MSmfaZaasmyTDzAjLRWfTp3113TlL/XhV+7l/m7ltjH2+EmZmsVLjFgEgPPbweXaUnuKnJGak2SEsWHY3T7Oazcl98XP+cuK1QhWahM9/+oYzYzIkK5k+wNZ3keaTSHR/S08m70CrgPA4gCtL+MdS+cJHbf8pZkWW4X5e12F5qcrZS/6RrYsWqc2YH5yYFuVu2ztY+KiUmDh4JRstAsLjEC6sqiJ2wuyUZmunfkpMgMlDo+r6j7IzNzeNsp945KWZ1SYveJW7Lc6w5adn+ndK46dUFV1YhRYB4XEIwzQXFxGFKJs3xLafMdrkgdHq8nEzxzWhWbMrrvaZetPkEB+9MhU23HB63hByA+mLi4Zp0CIgPA6ibEkVsY6o48NDAm13/WHBESZOfyu5lDV1+eWmVfoH/+kw+/QB08718FnUw1afOySw48OEv1NQtgStAcLjMNLVFz7gp7DSOU/Y7vqTsxiTJvyf+6Pze3vLm175l6jaf/zbD6ad+6jNnjnOeYJ8nnXhA2xmA+FxKGeX/XOVnxKTPDHKNtdOVJDfrMLs3dx+aUF9U62B3hs++0hjwnC6X6sZcbb4vIlRMcn8lH+unl2GlgDhcSjDNBfmkGmTRtpmYeKHfaUNBnXQqlYu77VOwzXlOvjvwQmzbpuwq8OzNphIKGUnjSTTLszB+A6Ex+F0+Vx5kZ/SImKlDeLzBMhT+jR0Tl3FW3PG7EMdLL0waFrp1YbOapUwMszaT1qZ2oJ4yqi82OVz1ACEx+Gw3Pl3ybShw1tZvXv30p6uDQTuLL/+2LQFZ1EDDMMwu0oTZ1440tBZk6wc52nlNnQ4mXb+XZZD+UN4GoGkb4sP8lPcvdcMttalz2xgtu3lvK4ztpWg9O9xpTZ2Ue5W4+fEpSRbFS5/zWB34v3FB5K+RdlDeBqJSy9riV5+6oDhIdZc8YPO3kY3Z/ljR/sF52+j5HWp51K++fpzrZHxFolsbj/Lrz88JJX4MtBqLr2CcofwNBrJRy8T33sS+aIx1gwxGwssxmnWrur2Va0W5a7PyD3T5tYZiYnTvXeohVsiStlFY8j4ype/TT6KMofwNCJXXyd3QwiO/qa3pVd7JSIkxuD3es17H4z4FSVuiPfzn5ymLDT0qotntoWbQH/TOzian1JXcfV1lDeEp1FJv3V+Ppk2ZLilq9UNR5CpKB45bcZJlLcxNt9Inn7NYGScfgNcLPBE03yG6A8rz0+/hdKG8DQyJfPKzvFT5M1WPGfJlfRDTN2jID91+roilHVD5Ne0n39kl/BrXoELHjL/iiuekzfjp5SdOzUXJQ3haXyfR50/mgxH3rbLp93Nv9L0AaxgbeTlxM49jpi+JlGtSVz9wxpOcBxsmNkTCT/t3rYLP4XT5I/GtEEIjyhI/f3CF2TaqFEZvuZdxYXtnKKfynE//a/TigqYuhk8/vO8BSqBJ3+BkX38zLlOhu8oPc/1whepv6OEITwi4eJr5Gp1F88vXzJvTKFrc1cvMk1du3DhI9tQvuYyJe+56ZUCc50yW5nzRfDlSy4e/LSqgouvoXQhPKKhf/WpsQwxjzUsdqNZrv35Gi2x5LGq9MWZk/DY1iK+LkibWnSGTD1TavoVNg4MiyXdz1Nj+1ejbCE8IqLbpit6MQAzh77U2vQrFNfnH9I9vnG+79RVV1GylnKkMnbOcV63qPTyV9dMffdLrTOHkmlXNnfbhHKF8IiM82OqbxJFK5vzijnT1v7zVeHpe/8/vjd+9sF/UKrWoFR3/HT72nszmqtK3lhu6uTLUJc5r5CxBqtvnh+DMrUdLIrAVhwamLSFfC51cl+H5aZfwUM6Pykppub2pr8Wn0d52oYRoS8keze/fH3SHtOXmpx4KY6IM8BpDw/qthWlCeERJWc+i3qBTNvwxRO/oGRo4vu+jz9Lpp39PPpFlAy6WiKlcmzZaTJtyEhbRSYEjmBi1BC9kF9l+ZVjUTIQHtHykOrMMDXh0EukM8dZF5QBOI5k75njJERkZfXtM08+pELZQHjEbLjHT00j09x91o/zkKJsxI+HdP04d711dqemYW9024MxHptzaXPrQWRaXk6nFSgZsXNsTEI6mXZ5S5vBKBl4PBRQNJxcNsowCem7h6JkxM3uofqyU3auaDhKBsJDR3fr9t+D6irJ1F6Pft8PZSNevu/X61Eyra7y70HJiPcI4aGF9NN5o/VXSD/2tCVr1oEj+LT7Y0+TaZw2b3T6aZSNfcCgp11YcWp4c39i81yW7ZIoPb/7JkpHbMzs8PprEr2WcGZxp8UoG3uBwWW7cf2XUL0dstS1r81edgllIyZebpP9rkxvW6Jru8L7omzQ1aKQq4NKT5BpMrdFbz4ehLIRD48HLXpTX3ZKT1wfhLKB8FBJ8u1T/cg4PQzjqlg9ORUTCkVCqvfqyfobKFYVnOqHQWUID7X0LDo+QP/5llfA5rei3FE6jU+U++a3vALI1LrK4wN6IsI1hIdqr+f40Sc1etPtfcNz3giQo3QalwB5zhu+4WSqRnX0ScxUhvBQT4/tea/qP1oPiTk2GV5P43o7xybr72LGafNe7bEdpQPhcQISPzs+mQyMyjAhMQemYqynsUj1PjBVYPNE7vjkxM9QOo4A83gcwKe5QyUt9HaybNZ8aNezx/KxcY3DeTxo/bveAnvcn5zV8X2UDoTHiVi2e7iCnFDIMK4eg3uUnTqsRPk4kpfbfP6Ou8DmQ6cXxb2N0oHwOBmf7Px3iF8imSpz7Z8su4jZzI5jZoc5b5Hb1jAMw5z7POZVlI7jwMxlB3J+TduR+qla9f8t/+9BlI5DOr3dn3+JDOPOMAxz4at2T6N0IDxOy9nPIl/QT+W4H9Y8sROlY2++7/fY0ywr5O1EIaIyhMe5yV8YM0Eofc+mtPUoHXuye6h+4AuGYZjTi9q/gdKB8Dg9J2bGTRUq97yclNXV2CXdLnhI94/SD/PFMAx3claH6SgfCE+TIG9S/DxWYAZV4ZmhS3PxjMvmJHuvHxcSLaA62uOTE+ajfBoDPNVqBD7NHXSjRX/9CDBe/iOS68/nlqKEbMnEqFVv+4bpp2tUx8Z2XorygcfTpDgwoPN3rl766VrNxq+wBaDt+L7vkJESga/XusqjT2JxBISnCZIbH7/dM1TolZP7+q8sqEcJWUuoy8+jyc2I71BVcHwAloJCeJooe4Njd/p1EHpFWTjlk+WXUULW8FLrOa8ILYxgmNITp/oh8AWEpyl7Pc3Ct+gHSGUYhtGqt68fvFXDoYwsQcpuHjhgqNBUQYYp2HUVe0dAeED+wujxrGCUgOsnRy7fXY4SMpc0n69eCosTeoXTnlmCWTsQHsAwDMMcGpqwUmigmWHqq1avxnIK8/i0+6jnhFZjMUxdZd7obpimCeEB98iJ6bjFN1L4tQtHxqyC32Oqr7PiubZdhF8rO/f3IOyTBeEBPHKbBa9tbWBnA9XtjWuf+hXjPcaRst/0HjJc3kz41ctbioZjZAfCAwTImxg7S3+rlTsUnZmwYm0hysgQw0MWjQmOFn5NXXtqasIClBGEBxjye+Kj1/nGCL+mVe3b/vTmK7UoJZJWbmsGpw6QGAifX3b6zDDM2YHwAKP8Kff6OHIMayAWdo1y/drR+9Dp0u1grUwdOtzdQPRqTntuReXYh1QoJwgPaJBDA+NWebQw9OrNi/O/WnAWpcQwDDMxatLIFhGGXq2+efK5bltRShAeYCK7/NqtaDXYcO2czp3y/cYbTbuMhgTOeSIm2eDL3JXN58f0wYJbCA8w0+95NPYTzxCD7Urz9++TN+641TTLJtN/3pCOD7MGYytUFZ56pdsm2BCEB1jAzx4R2W2fNdy8tOpju9/Y1NTm+KT5LHy0U5rwcog7knzhi4uv9a+G/UB4gMXse7j9SkNTCxmGYTSqv36bunVnE+lS9PObNTAxQ2pk++eyc/mjU3+H3UB4gJXkyAImt5vkqjB8Bqc5c+ijbcsuOXc5vNzm1azobqyR0HV1Fefnn5o7DOFjITzARuLjH7649QiJ0XiRBfnfbH37mDM+apeyczs9NTC0vbFztJrL3159Pf0WbAXCA2xKbuc2y4K6Gz9HWbjn1xn7jjnRtsidPGek9urtHWL8rOKDl15OPgobgfAAu3B4RLvZ3hHGz9Gqzh7+Nuf9fNp9Hyn7TvsR6VFJEnkDYnvx/LtJ38I2IDzAjnDskRfaTmke3tB5FTf27160fxelg859/CakpKQpAhs675+rF+Z0+ZzFTG4ID7A/66SRY9tNEo7XzFep4nMHDi75Yy9FD9x7+ozv2qN7UGTDlllVcH7+uY8xlAzhAQ4kR+b7esTrnsEm+Ehc0Zn9B5ccFvuOXane45JSugdHsybYZFXRxcVli9PVsAMID2gEz6ftc63G+8Wa1kcrvXIyb0fe0vNi263UQzquXWZCXIJfK9OssfTUlSUXVsHTgfCARiU3M3xySE/WxJpU1Vw6cThvQ74YVnoNCXy8fVJCmw5yd9PO57jCvVfnJe9AnUN4gDjEJz7onbBHTG3ADMMwtRXXz54+89vZ1ZeVDu6weMtGtc6IiokOi3JTmP4uVc31H4vfR1wdCA8QGTmePi+GPSu8T5dhNKqblwqvXLh2+NoPVy/aMchYhNtj4Ukt27YMadWijVRu3ntLT1z/ovyz9CrUMYQHiJT9SUHjQgcL71nRUE+m8tbNa0UF10sulhwtyblVamX4LD95un/ngIiAsIDg0BYtvfwtsbW6yoLNxUtTDqNeITxA/L6Pm+LpwCeDUqSuVlyEq1FWlFSUV1VVViory6puVhZWldTWqCtVVepKdblaqWYYb5mPzEvmKfOSu8sC3EI8W3j5enp7eXl5eip8FAHu3tZYl7ruxv4b31WsSUeoVwgPoIltiuD/BAwL6iF1oeu+NfXFB0rWFX2dVYE6hPAAWr0fb+9nAh4J6ObiKf57ra8qOVTyo/LLdCXqDcIDnEF+ZG59fR/1T/ONFGWNc2Xnbu0u21T7C6YEQniAE5Ib6jFUke7bWREmiprnKq6XHVXm3F6fXIC6gfAA5/eAgrz6K3r5PuQdY+6jbVugUSlPl/1Zsafy5/Ri1AWEBzQ5trkqunolenTyjFW0beZr38+6XVZxoepU9bHKvyr+yKpD2UN4AGAYZm+wWw/3WNeIZuHNwjyCXJtbf8W6f6qLb1+/fbXuYs2p2gM9i1DGAMIDjPtCCq/2bm1kgXJ/WYCLr4uv3MdFIXGVyCVyqUwik8glMobRqrUqrVqj1qq0Km1dfYWqvL6svkxdorqlvlF7qTIfD8QBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYDv+H/2K9WWEWmgPAAAAAElFTkSuQmCC'),
      (this.img.style.position = 'absolute'),
      (this.img.style.width = '150px'),
      (this.img.style.height = '150px'),
      this.rootApp.container.appendChild(this.img))
  }
}
class tx {
  static createButton(t) {
    const e = document.createElement('button')
    function n() {
      ;(e.style.display = ''),
        (e.style.cursor = 'auto'),
        (e.style.left = 'calc(50% - 75px)'),
        (e.style.width = '150px'),
        (e.onmouseenter = null),
        (e.onmouseleave = null),
        (e.onclick = null)
    }
    function i(t) {
      ;(t.style.position = 'absolute'),
        (t.style.bottom = '20px'),
        (t.style.padding = '12px 6px'),
        (t.style.border = '1px solid #fff'),
        (t.style.borderRadius = '4px'),
        (t.style.background = 'rgba(0,0,0,0.1)'),
        (t.style.color = '#fff'),
        (t.style.font = 'normal 13px sans-serif'),
        (t.style.textAlign = 'center'),
        (t.style.opacity = '0.5'),
        (t.style.outline = 'none'),
        (t.style.zIndex = '999')
    }
    if ('xr' in navigator)
      return (
        (e.id = 'VRButton'),
        (e.style.display = 'none'),
        i(e),
        navigator.xr
          .isSessionSupported('immersive-vr')
          .then(function (i) {
            i
              ? (function () {
                  let n = null
                  async function i(i) {
                    i.addEventListener('end', s),
                      await t.xr.setSession(i),
                      (e.textContent = 'EXIT VR'),
                      (n = i)
                  }
                  function s() {
                    n.removeEventListener('end', s), (e.textContent = 'ENTER VR'), (n = null)
                  }
                  ;(e.style.display = ''),
                    (e.style.cursor = 'pointer'),
                    (e.style.left = 'calc(50% - 50px)'),
                    (e.style.width = '100px'),
                    (e.textContent = 'ENTER VR'),
                    (e.onmouseenter = function () {
                      e.style.opacity = '1.0'
                    }),
                    (e.onmouseleave = function () {
                      e.style.opacity = '0.5'
                    }),
                    (e.onclick = function () {
                      if (null === n) {
                        const t = {
                          optionalFeatures: [
                            'local-floor',
                            'bounded-floor',
                            'hand-tracking',
                            'layers'
                          ]
                        }
                        navigator.xr.requestSession('immersive-vr', t).then(i)
                      } else n.end()
                    })
                })()
              : (n(), (e.textContent = 'VR NOT SUPPORTED')),
              i && tx.xrSessionIsGranted && e.click()
          })
          .catch(function (t) {
            n(),
              console.warn('Exception when trying to call xr.isSessionSupported', t),
              (e.textContent = 'VR NOT ALLOWED')
          }),
        e
      )
    {
      const t = document.createElement('a')
      return (
        !1 === window.isSecureContext
          ? ((t.href = document.location.href.replace(/^http:/, 'https:')),
            (t.innerHTML = 'WEBXR NEEDS HTTPS'))
          : ((t.href = 'https://immersiveweb.dev/'), (t.innerHTML = 'WEBXR NOT AVAILABLE')),
        (t.style.left = 'calc(50% - 90px)'),
        (t.style.width = '180px'),
        (t.style.textDecoration = 'none'),
        i(t),
        t
      )
    }
  }
  static registerSessionGrantedListener() {
    if ('xr' in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent)) return
      navigator.xr.addEventListener('sessiongranted', () => {
        tx.xrSessionIsGranted = !0
      })
    }
  }
}
;(tx.xrSessionIsGranted = !1), tx.registerSessionGrantedListener()
class ex extends a {
  constructor() {
    super(), (this.clock = new Ba())
  }
  __init() {
    ;(this.raycaster = new Qa()),
      (this.renderer = new Ds({ antialias: !0, alpha: !0, preserveDrawingBuffer: !0 })),
      this.renderer.setPixelRatio(window.devicePixelRatio),
      (this.container = document.getElementById(yh.container_id)),
      (this.comPassApp = new $y(this)),
      this.comPassApp.createCompassDiv(),
      (this.renderer.domElement.id = 'canvas_threejs'),
      this.container.appendChild(this.renderer.domElement),
      (this.width = this.container.offsetWidth),
      (this.height = this.container.offsetHeight),
      this.renderer.setSize(this.width, this.height)
    let t = this.width / this.height
    ;(this.scene = new Os()),
      (this.camera = new We(45 / ((t + 1) / 2), t, 1)),
      (this.scaleWhole = null),
      (this.css3DApp = new cc(this)),
      (this.css2DApp = new xc(this)),
      (this.controls = new mh(this.camera, this.renderer.domElement)),
      window.addEventListener('resize', () => {
        this._resize()
      }),
      (this.light = new Ca(16777215)),
      this.scene.add(this.light),
      (this.loader = new gl()),
      (this.wholeApp = new Oh(this)),
      (this.curBuildingApp = null),
      (this.devAnimate = new Fh(this)),
      (this.wholeDisplayEffect = new tc(this)),
      (this.eventApp = new ec(this)),
      (this.pathApp = new Ky(this)),
      (this.smokeSpreadRoomVN = new Jy(this))
  }
  load(t) {
    this.__init(),
      (xh.wholeJson = t),
      (function (t) {
        if (t) for (let e in t) yh[e] = t[e]
      })(t),
      this.wholeDisplayEffect.setParams(),
      this.wholeApp
        .createWhole(t)
        .then((t) => {
          this._init(t)
        })
        .catch((t) => console.error(t))
  }
  _init(t) {
    this.scaleWholeGroup(t),
      this.scene.add(t),
      t.position.set(0, 0, 0),
      this.setCamera(t),
      this.wholeDisplayEffect.setDisplayEffect()
    let e = 50 * this.scaleWhole
    this.css3DApp.css3dScene.scale.set(e, e, e),
      this.wholeApp.setfloorTipScale(),
      this.dispatchEvent({ type: 'onPostInit' }),
      this._animate()
  }
  scaleWholeGroup(t) {
    if (xh.wholeJson.wholeGroupScala) {
      let e = xh.wholeJson.wholeGroupScala
      t.scale.set(e, e, e), (this.scaleWhole = e)
    } else {
      const e = new Y().setFromObject(t),
        n = new H()
      e.getSize(n)
      let i = 1 / Math.max(n.x, n.y, n.z)
      ;(this.scaleWhole = i), t.scale.set(i, i, i)
      let s = new Y().setFromObject(t),
        r = new H()
      s.getCenter(r),
        t.position.sub(r),
        (t.position.y += 1.1 * r.y),
        (t.userData.initPosition = t.position.clone())
    }
  }
  setCamera(t) {
    const e = new Y().setFromObject(t),
      n = new H()
    e.getSize(n)
    let i = new H()
    e.getCenter(i),
      this.camera.position.set(yh.camera.x, yh.camera.y, yh.camera.z),
      this.camera.lookAt(this.scene.position),
      (this.camera.far = 5e4),
      (this.camera.near = 0.01),
      this.camera.updateProjectionMatrix(),
      this.controls.target.copy(i),
      (this.controls.enableDamping = !0),
      (this.controls.minDistance = 0.01),
      (this.controls.maxDistance = 3),
      (this.controls.minPolarAngle = 0),
      (this.controls.maxPolarAngle = (50 * Math.PI) / 100),
      this.controls.update(),
      this.controls.saveState()
  }
  _resize() {
    this.renderer.setSize(this.width, this.height),
      (this.camera.aspect = this.width / this.height),
      this.camera.updateProjectionMatrix(),
      this.render()
  }
  render() {
    this.controls.update(),
      this.css3DApp.css3dRenderer.render(this.css3DApp.css3dScene, this.camera),
      this.css2DApp.css2dRenderer.render(this.scene, this.camera),
      this.comPassApp.compassRender(),
      this.stats && this.stats.update(),
      this.wholeDisplayEffect.render()
  }
  _animate() {
    const t = this.clock.getDelta(),
      e = this.clock.getElapsedTime()
    this.dispatchEvent({ type: 'onAnimate', delta: t, elapsedTime: e }),
      requestAnimationFrame(() => {
        this._animate()
      }),
      this.render()
  }
}
function nx(t) {
  if (t.children.length > 0) for (let e = t.children.length - 1; e >= 0; e--) nx(t.children[e])
  t.isMesh &&
    (t.userData.initMaterial && t.userData.initMaterial.dispose(),
    t.geometry.dispose(),
    t.material.map &&
      (console.log('==obj.material.map==', t.material.map), t.material.map.dispose()),
    t.material.dispose()),
    t.parent && t.parent.remove(t)
}
function ix(t) {
  let e = t.scene,
    n = t.renderer,
    i = yh.container_id
  if ((e && nx(e), n)) {
    n.renderLists.dispose(), n.clear(), n.dispose()
    let t = document.getElementById(i)
    if (t) for (; t.hasChildNodes(); ) t.removeChild(t.lastChild)
  }
}
class sx extends ex {
  constructor() {
    super()
  }
  static disposeApp(t) {
    ix(t)
  }
  home() {
    this.wholeApp.home()
  }
  showOneBuilding(t) {
    this.wholeApp.showOneBuilding(t)
  }
  setIsMobile() {
    yh.isMobile = !0
  }
  showAllBuilding() {
    this.wholeApp.showAllBuilding()
  }
  addGlowDev(t, e) {
    this.devAnimate.addGlowDev(t, e)
  }
  delGlowDev(t) {
    this.devAnimate.delGlowDev(t)
  }
  delAllGlowDev() {
    this.devAnimate.delAllGlowDev()
  }
  visibleDev(t, e) {
    this.curBuildingApp.floorApp.devApp.visibleDev(t, e)
  }
  setDevColor(t, e) {
    this.curBuildingApp.floorApp.devApp.setDevColor(t, e)
  }
  resetDevColor(t) {
    this.curBuildingApp.floorApp.devApp.resetDevColor(t)
  }
  setAllDevColor(t) {
    this.curBuildingApp.floorApp.devApp.setAllDevColor(t)
  }
  resetAllDevColor() {
    this.curBuildingApp.floorApp.devApp.resetAllDevColor()
  }
  createPlanexyz(t, e, n, i) {
    this.css3DApp.createPlanexyz(t, e, n, i)
  }
  createPlane(t, e) {
    this.css3DApp.createPlane(t, e)
  }
  add3DLabByObjName(t, e) {
    this.css3DApp.addLabByObjName(t, e)
  }
  del3DByObjName(t) {
    this.css3DApp.delByObjName(t)
  }
  del3DAllPlane() {
    this.css3DApp.delAllPlane()
  }
  add2DLabByObjName(t, e, n) {
    this.css2DApp.addLabByObjName(t, e, n)
  }
  add2DLabByObj(t, e, n) {
    this.css2DApp.addLab(t, e, n)
  }
  del2DAllPlane() {
    this.css2DApp.delAllLab()
  }
  setDevMode() {
    this.eventApp.curEvent = 'dev'
  }
  setPathMode() {
    this.eventApp.curEvent = 'path'
  }
  showALlPath(t) {
    this.pathApp.showALlPath(t)
  }
  delPath() {
    this.pathApp.delPath()
  }
  openSmokeSpread() {
    this.smokeSpread.openSmokeSpread()
  }
  closeSmokeSpread() {
    this.smokeSpread.closeSmokeSpread()
  }
  devSmokeSpread(t) {
    this.devAnimate.addGlowDev(t, 16711680), this.smokeSpread.devSmokeSpread(t)
  }
  clearAllSmokeSpread() {
    this.smokeSpread.clearAllSmokeSpread()
  }
  devSmokeSpreadVN(t) {
    this.smokeSpreadRoomVN.devSmokeSpreadVN(t)
  }
  openSmokeSpreadVN() {
    this.smokeSpreadRoomVN.openSmokeSpreadVN()
  }
  clearAllVNSmokeSpread() {
    this.smokeSpreadRoomVN.clearAllVNSmokeSpread()
  }
  clearVNSmokeSpreadByName(t) {
    this.smokeSpreadRoomVN.clearVNSmokeSpreadByName(t)
  }
  floorOpen(t) {
    this.curBuildingApp.floorAnimationApp.floorOpen(t)
  }
  setFloorColorMaterial(t, e, n) {
    this.wholeApp.setFloorColorMaterial(t, e, n)
  }
  resetFloorMaterial(t, e) {
    this.wholeApp.resetFloorMaterial(t, e)
  }
  setALlFloorColorMaterial(t, e) {
    this.wholeApp.setALlFloorColorMaterial(t, e)
  }
  resetAllFloorMaterial(t) {
    this.wholeApp.resetAllFloorMaterial(t)
  }
  closeOneBuildingTip(t) {
    this.wholeApp.closeOneBuildingTip(t)
  }
  showOneBuildingTip(t) {
    this.wholeApp.showOneBuildingTip(t)
  }
  showAllBuildingTip() {
    this.wholeApp.showAllBuildingTip()
  }
  closeAllBuildingTip() {
    this.wholeApp.closeAllBuildingTip()
  }
  showRoomTipByRoomId(t) {
    this.curBuildingApp.floorApp.roomApp.showRoomTipByRoomId(t)
  }
  delRoomTipByRoomId(t) {
    this.curBuildingApp.floorApp.roomApp.showRoomTipByRoomId(t)
  }
  showAllRoomTip() {
    this.curBuildingApp.floorApp.roomApp.showAllRoomTip()
  }
  delAllRoomTip() {
    this.curBuildingApp.floorApp.roomApp.delAllRoomTip()
  }
  setRoomColor(t, e) {
    this.curBuildingApp.floorApp.roomApp.setRoomColor(t, e)
  }
  resetRoomColor(t) {
    this.curBuildingApp.floorApp.roomApp.resetRoomColor(t)
  }
  resetAllRoomColor() {
    this.curBuildingApp.floorApp.roomApp.resetAllRoomColor()
  }
  setAllSafeExitColor(t) {
    this.pathApp.setAllSafeExitColor(t)
  }
  resetAllSafeExitColor() {
    this.pathApp.resetAllSafeExitColor()
  }
  getCurScenes() {
    return this.eventApp.getCurScenes()
  }
}
export { sx as Api3d }
